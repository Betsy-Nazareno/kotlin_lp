Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ACTUAL
    ADD
    ANNOTATION
    ARRAYOF
    ARROW
    AS
    AT_NO_WS
    BREAK
    BY
    CATCH
    CLASS
    COLONCOLON
    COMMA
    COMMENT
    COMPANION
    CONST
    CONSTRUCTOR
    CONTINUE
    CROSSINLINE
    DATA
    DECR
    DECREMENTIN
    DECREMENTONE
    DIVIDEIN
    DO
    DOUBLE_ARROW
    DOUBLE_SEMICOLON
    DYNAMIC
    ENUM
    EXCL_NO_WS
    EXPECT
    EXTERNAL
    FIELD
    FILE
    FINAL
    FINALLY
    FUN
    GET
    HASH
    IMPORT
    INCR
    INCREMENTIN
    INCREMENTONE
    INCREMENTTIMES
    INFIX
    INIT
    INLINE
    INNER
    INTERFACE
    INTERNAL
    IS
    LATEINIT
    LINEBREAK
    LINKEDLIST
    LISTOF
    LSQUARE
    MARK_1
    MARK_2
    MODIN
    NOINLINE
    OBJECT
    OPEN
    OPERATOR
    OUT
    OVERRIDE
    PACKAGE
    PARAM
    PEEK
    POLL
    PRIVATE
    PROPERTY
    PROTECTED
    PUBLIC
    QUEST_WS
    QUEUE
    RANGE
    RECEIVER
    REIFIED
    REMOVE
    RETURN
    RSQUARE
    SEALED
    SET
    SETPARAM
    SINGLE_QUOTE
    SUM
    SUPER
    SUSPEND
    TAILREC
    TEMPLATE
    THIS
    THROW
    TRY
    TYPEOF
    TYPE_ALIAS
    VALUE
    VAL_TIPO_1
    VARARG
    VAR_TIPO_1
    WHEN
    WHERE
    WHILE

Grammar

Rule 0     S' -> line
Rule 1     line -> impresion SEMICOLON
Rule 2     line -> expression
Rule 3     line -> asignacion
Rule 4     line -> asignacion SEMICOLON
Rule 5     line -> for
Rule 6     line -> if
Rule 7     line -> stack
Rule 8     line -> stack_actuar
Rule 9     line -> instance_arraylist
Rule 10    line -> def_estruct_tipoDato
Rule 11    impresion -> PRINT LPAREN term RPAREN
Rule 12    impresion -> PRINTLN LPAREN term RPAREN
Rule 13    for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL
Rule 14    keywordVariables -> VAR
Rule 15    keywordVariables -> VAL
Rule 16    asignacion -> keywordVariables asignacionSimple
Rule 17    asignacion -> asignacionSimple
Rule 18    asignacionSimple -> ID DOTS tipoDato EQUAL valor
Rule 19    asignacionSimple -> ID EQUAL valor
Rule 20    tipoDato -> TINT
Rule 21    tipoDato -> TLONG
Rule 22    tipoDato -> TFLOAT
Rule 23    tipoDato -> TDOUBLE
Rule 24    tipoDato -> TBOOLEAN
Rule 25    tipoDato -> TCHAR
Rule 26    tipoDato -> TSTRING
Rule 27    valor -> expression
Rule 28    expression -> expression PLUS term
Rule 29    expression -> expression MINUS term
Rule 30    expression -> expression TIMES term
Rule 31    expression -> expression DIVIDE term
Rule 32    expression -> expression MOD term
Rule 33    expression -> term
Rule 34    term -> factor
Rule 35    term -> LPAREN expression RPAREN
Rule 36    factor -> INT
Rule 37    factor -> FLOAT
Rule 38    factor -> LONG
Rule 39    factor -> CHAR
Rule 40    factor -> BOOLEAN
Rule 41    factor -> ID
Rule 42    factor -> STRING_1
Rule 43    if -> IF LPAREN condicion RPAREN LCURL line RCURL
Rule 44    if -> IF LPAREN condicion RPAREN LCURL line RCURL else
Rule 45    else -> ELSE LCURL line RCURL
Rule 46    condicion -> condicionL
Rule 47    condicion -> condicionR
Rule 48    condicion -> condicionN
Rule 49    condicionL -> term opL term
Rule 50    condicionR -> term opR term
Rule 51    condicionN -> EXCL_WS term
Rule 52    opL -> CONJ
Rule 53    opL -> DISJ
Rule 54    opR -> LANGLE
Rule 55    opR -> RANGLE
Rule 56    opR -> LE
Rule 57    opR -> GE
Rule 58    opR -> EXCL_EQ
Rule 59    opR -> EXCL_EQEQ
Rule 60    opR -> AS_SAFE
Rule 61    opR -> EQEQ
Rule 62    opR -> EQEQEQ
Rule 63    stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
Rule 64    def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE
Rule 65    instance_arraylist -> ARRAYLIST LPAREN RPAREN
Rule 66    stack_actuar -> ID DOT stack_funciones
Rule 67    stack_funciones -> stack_isEmpty
Rule 68    stack_funciones -> stack_push
Rule 69    stack_funciones -> stack_pop
Rule 70    stack_isEmpty -> ISEMPTY LPAREN RPAREN
Rule 71    stack_pop -> POP LPAREN RPAREN
Rule 72    stack_push -> PUSH LPAREN ID RPAREN

Terminals, with rules where they appear

ABSTRACT             : 
ACTUAL               : 
ADD                  : 
ANNOTATION           : 
ARRAYLIST            : 65
ARRAYOF              : 
ARROW                : 
AS                   : 
AS_SAFE              : 60
AT_NO_WS             : 
BOOLEAN              : 40
BREAK                : 
BY                   : 
CATCH                : 
CHAR                 : 39
CLASS                : 
COLONCOLON           : 
COMMA                : 
COMMENT              : 
COMPANION            : 
CONJ                 : 52
CONST                : 
CONSTRUCTOR          : 
CONTINUE             : 
CROSSINLINE          : 
DATA                 : 
DECR                 : 
DECREMENTIN          : 
DECREMENTONE         : 
DISJ                 : 53
DIVIDE               : 31
DIVIDEIN             : 
DO                   : 
DOT                  : 66
DOTS                 : 18 63
DOUBLE_ARROW         : 
DOUBLE_SEMICOLON     : 
DYNAMIC              : 
ELSE                 : 45
ENUM                 : 
EQEQ                 : 61
EQEQEQ               : 62
EQUAL                : 18 19 63
EXCL_EQ              : 58
EXCL_EQEQ            : 59
EXCL_NO_WS           : 
EXCL_WS              : 51
EXPECT               : 
EXTERNAL             : 
FIELD                : 
FILE                 : 
FINAL                : 
FINALLY              : 
FLOAT                : 37
FOR                  : 13
FUN                  : 
GE                   : 57
GET                  : 
HASH                 : 
ID                   : 13 13 18 19 41 63 66 72
IF                   : 43 44
IMPORT               : 
IN                   : 13
INCR                 : 
INCREMENTIN          : 
INCREMENTONE         : 
INCREMENTTIMES       : 
INFIX                : 
INIT                 : 
INLINE               : 
INNER                : 
INT                  : 36
INTERFACE            : 
INTERNAL             : 
IS                   : 
ISEMPTY              : 70
LANGLE               : 54 64
LATEINIT             : 
LCURL                : 13 43 44 45
LE                   : 56
LINEBREAK            : 
LINKEDLIST           : 
LISTOF               : 
LONG                 : 38
LPAREN               : 11 12 13 35 43 44 65 70 71 72
LSQUARE              : 
MARK_1               : 
MARK_2               : 
MINUS                : 29
MOD                  : 32
MODIN                : 
NOINLINE             : 
OBJECT               : 
OPEN                 : 
OPERATOR             : 
OUT                  : 
OVERRIDE             : 
PACKAGE              : 
PARAM                : 
PEEK                 : 
PLUS                 : 28
POLL                 : 
POP                  : 71
PRINT                : 11
PRINTLN              : 12
PRIVATE              : 
PROPERTY             : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 72
QUEST_WS             : 
QUEUE                : 
RANGE                : 
RANGLE               : 55 64
RCURL                : 13 43 44 45
RECEIVER             : 
REIFIED              : 
REMOVE               : 
RETURN               : 
RPAREN               : 11 12 13 35 43 44 65 70 71 72
RSQUARE              : 
SEALED               : 
SEMICOLON            : 1 4
SET                  : 
SETPARAM             : 
SINGLE_QUOTE         : 
STACK                : 64
STRING_1             : 42
SUM                  : 
SUPER                : 
SUSPEND              : 
TAILREC              : 
TBOOLEAN             : 24
TCHAR                : 25
TDOUBLE              : 23
TEMPLATE             : 
TFLOAT               : 22
THIS                 : 
THROW                : 
TIMES                : 30
TINT                 : 20
TLONG                : 21
TRY                  : 
TSTRING              : 26
TYPEOF               : 
TYPE_ALIAS           : 
VAL                  : 15
VALUE                : 
VAL_TIPO_1           : 
VAR                  : 14
VARARG               : 
VAR_TIPO_1           : 
WHEN                 : 
WHERE                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 3 4
asignacionSimple     : 16 17
condicion            : 43 44
condicionL           : 46
condicionN           : 48
condicionR           : 47
def_estruct_tipoDato : 10 63
else                 : 44
expression           : 2 27 28 29 30 31 32 35
factor               : 34
for                  : 5
if                   : 6
impresion            : 1
instance_arraylist   : 9 63
keywordVariables     : 16 63
line                 : 13 43 44 45 0
opL                  : 49
opR                  : 50
stack                : 7
stack_actuar         : 8
stack_funciones      : 66
stack_isEmpty        : 67
stack_pop            : 69
stack_push           : 68
term                 : 11 12 28 29 30 31 32 33 49 49 50 50 51
tipoDato             : 18 64
valor                : 18 19

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion
    (4) line -> . asignacion SEMICOLON
    (5) line -> . for
    (6) line -> . if
    (7) line -> . stack
    (8) line -> . stack_actuar
    (9) line -> . instance_arraylist
    (10) line -> . def_estruct_tipoDato
    (11) impresion -> . PRINT LPAREN term RPAREN
    (12) impresion -> . PRINTLN LPAREN term RPAREN
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (16) asignacion -> . keywordVariables asignacionSimple
    (17) asignacion -> . asignacionSimple
    (13) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (43) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (44) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (63) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (66) stack_actuar -> . ID DOT stack_funciones
    (65) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (64) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (14) keywordVariables -> . VAR
    (15) keywordVariables -> . VAL
    (18) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> . ID EQUAL valor
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    PRINT           shift and go to state 11
    PRINTLN         shift and go to state 14
    FOR             shift and go to state 17
    IF              shift and go to state 19
    ID              shift and go to state 18
    ARRAYLIST       shift and go to state 20
    STACK           shift and go to state 21
    LPAREN          shift and go to state 12
    VAR             shift and go to state 23
    VAL             shift and go to state 24
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    STRING_1        shift and go to state 30

    line                           shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    stack                          shift and go to state 7
    stack_actuar                   shift and go to state 8
    instance_arraylist             shift and go to state 9
    def_estruct_tipoDato           shift and go to state 10
    term                           shift and go to state 13
    keywordVariables               shift and go to state 15
    asignacionSimple               shift and go to state 16
    factor                         shift and go to state 22

state 1

    (0) S' -> line .



state 2

    (1) line -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 31


state 3

    (2) line -> expression .
    (28) expression -> expression . PLUS term
    (29) expression -> expression . MINUS term
    (30) expression -> expression . TIMES term
    (31) expression -> expression . DIVIDE term
    (32) expression -> expression . MOD term

    $end            reduce using rule 2 (line -> expression .)
    RCURL           reduce using rule 2 (line -> expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36


state 4

    (3) line -> asignacion .
    (4) line -> asignacion . SEMICOLON

    $end            reduce using rule 3 (line -> asignacion .)
    RCURL           reduce using rule 3 (line -> asignacion .)
    SEMICOLON       shift and go to state 37


state 5

    (5) line -> for .

    $end            reduce using rule 5 (line -> for .)
    RCURL           reduce using rule 5 (line -> for .)


state 6

    (6) line -> if .

    $end            reduce using rule 6 (line -> if .)
    RCURL           reduce using rule 6 (line -> if .)


state 7

    (7) line -> stack .

    $end            reduce using rule 7 (line -> stack .)
    RCURL           reduce using rule 7 (line -> stack .)


state 8

    (8) line -> stack_actuar .

    $end            reduce using rule 8 (line -> stack_actuar .)
    RCURL           reduce using rule 8 (line -> stack_actuar .)


state 9

    (9) line -> instance_arraylist .

    $end            reduce using rule 9 (line -> instance_arraylist .)
    RCURL           reduce using rule 9 (line -> instance_arraylist .)


state 10

    (10) line -> def_estruct_tipoDato .

    $end            reduce using rule 10 (line -> def_estruct_tipoDato .)
    RCURL           reduce using rule 10 (line -> def_estruct_tipoDato .)


state 11

    (11) impresion -> PRINT . LPAREN term RPAREN

    LPAREN          shift and go to state 38


state 12

    (35) term -> LPAREN . expression RPAREN
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    expression                     shift and go to state 39
    term                           shift and go to state 13
    factor                         shift and go to state 22

state 13

    (33) expression -> term .

    PLUS            reduce using rule 33 (expression -> term .)
    MINUS           reduce using rule 33 (expression -> term .)
    TIMES           reduce using rule 33 (expression -> term .)
    DIVIDE          reduce using rule 33 (expression -> term .)
    MOD             reduce using rule 33 (expression -> term .)
    $end            reduce using rule 33 (expression -> term .)
    RPAREN          reduce using rule 33 (expression -> term .)
    SEMICOLON       reduce using rule 33 (expression -> term .)
    RCURL           reduce using rule 33 (expression -> term .)


state 14

    (12) impresion -> PRINTLN . LPAREN term RPAREN

    LPAREN          shift and go to state 41


state 15

    (16) asignacion -> keywordVariables . asignacionSimple
    (63) stack -> keywordVariables . ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (18) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> . ID EQUAL valor

    ID              shift and go to state 43

    asignacionSimple               shift and go to state 42

state 16

    (17) asignacion -> asignacionSimple .

    SEMICOLON       reduce using rule 17 (asignacion -> asignacionSimple .)
    $end            reduce using rule 17 (asignacion -> asignacionSimple .)
    RCURL           reduce using rule 17 (asignacion -> asignacionSimple .)


state 17

    (13) for -> FOR . LPAREN ID IN ID RPAREN LCURL line RCURL

    LPAREN          shift and go to state 44


state 18

    (66) stack_actuar -> ID . DOT stack_funciones
    (18) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> ID . EQUAL valor
    (41) factor -> ID .

    DOT             shift and go to state 45
    DOTS            shift and go to state 46
    EQUAL           shift and go to state 47
    PLUS            reduce using rule 41 (factor -> ID .)
    MINUS           reduce using rule 41 (factor -> ID .)
    TIMES           reduce using rule 41 (factor -> ID .)
    DIVIDE          reduce using rule 41 (factor -> ID .)
    MOD             reduce using rule 41 (factor -> ID .)
    $end            reduce using rule 41 (factor -> ID .)
    RCURL           reduce using rule 41 (factor -> ID .)


state 19

    (43) if -> IF . LPAREN condicion RPAREN LCURL line RCURL
    (44) if -> IF . LPAREN condicion RPAREN LCURL line RCURL else

    LPAREN          shift and go to state 48


state 20

    (65) instance_arraylist -> ARRAYLIST . LPAREN RPAREN

    LPAREN          shift and go to state 49


state 21

    (64) def_estruct_tipoDato -> STACK . LANGLE tipoDato RANGLE

    LANGLE          shift and go to state 50


state 22

    (34) term -> factor .

    PLUS            reduce using rule 34 (term -> factor .)
    MINUS           reduce using rule 34 (term -> factor .)
    TIMES           reduce using rule 34 (term -> factor .)
    DIVIDE          reduce using rule 34 (term -> factor .)
    MOD             reduce using rule 34 (term -> factor .)
    $end            reduce using rule 34 (term -> factor .)
    RPAREN          reduce using rule 34 (term -> factor .)
    SEMICOLON       reduce using rule 34 (term -> factor .)
    RCURL           reduce using rule 34 (term -> factor .)
    CONJ            reduce using rule 34 (term -> factor .)
    DISJ            reduce using rule 34 (term -> factor .)
    LANGLE          reduce using rule 34 (term -> factor .)
    RANGLE          reduce using rule 34 (term -> factor .)
    LE              reduce using rule 34 (term -> factor .)
    GE              reduce using rule 34 (term -> factor .)
    EXCL_EQ         reduce using rule 34 (term -> factor .)
    EXCL_EQEQ       reduce using rule 34 (term -> factor .)
    AS_SAFE         reduce using rule 34 (term -> factor .)
    EQEQ            reduce using rule 34 (term -> factor .)
    EQEQEQ          reduce using rule 34 (term -> factor .)


state 23

    (14) keywordVariables -> VAR .

    ID              reduce using rule 14 (keywordVariables -> VAR .)


state 24

    (15) keywordVariables -> VAL .

    ID              reduce using rule 15 (keywordVariables -> VAL .)


state 25

    (36) factor -> INT .

    PLUS            reduce using rule 36 (factor -> INT .)
    MINUS           reduce using rule 36 (factor -> INT .)
    TIMES           reduce using rule 36 (factor -> INT .)
    DIVIDE          reduce using rule 36 (factor -> INT .)
    MOD             reduce using rule 36 (factor -> INT .)
    $end            reduce using rule 36 (factor -> INT .)
    RPAREN          reduce using rule 36 (factor -> INT .)
    SEMICOLON       reduce using rule 36 (factor -> INT .)
    RCURL           reduce using rule 36 (factor -> INT .)
    CONJ            reduce using rule 36 (factor -> INT .)
    DISJ            reduce using rule 36 (factor -> INT .)
    LANGLE          reduce using rule 36 (factor -> INT .)
    RANGLE          reduce using rule 36 (factor -> INT .)
    LE              reduce using rule 36 (factor -> INT .)
    GE              reduce using rule 36 (factor -> INT .)
    EXCL_EQ         reduce using rule 36 (factor -> INT .)
    EXCL_EQEQ       reduce using rule 36 (factor -> INT .)
    AS_SAFE         reduce using rule 36 (factor -> INT .)
    EQEQ            reduce using rule 36 (factor -> INT .)
    EQEQEQ          reduce using rule 36 (factor -> INT .)


state 26

    (37) factor -> FLOAT .

    PLUS            reduce using rule 37 (factor -> FLOAT .)
    MINUS           reduce using rule 37 (factor -> FLOAT .)
    TIMES           reduce using rule 37 (factor -> FLOAT .)
    DIVIDE          reduce using rule 37 (factor -> FLOAT .)
    MOD             reduce using rule 37 (factor -> FLOAT .)
    $end            reduce using rule 37 (factor -> FLOAT .)
    RPAREN          reduce using rule 37 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 37 (factor -> FLOAT .)
    RCURL           reduce using rule 37 (factor -> FLOAT .)
    CONJ            reduce using rule 37 (factor -> FLOAT .)
    DISJ            reduce using rule 37 (factor -> FLOAT .)
    LANGLE          reduce using rule 37 (factor -> FLOAT .)
    RANGLE          reduce using rule 37 (factor -> FLOAT .)
    LE              reduce using rule 37 (factor -> FLOAT .)
    GE              reduce using rule 37 (factor -> FLOAT .)
    EXCL_EQ         reduce using rule 37 (factor -> FLOAT .)
    EXCL_EQEQ       reduce using rule 37 (factor -> FLOAT .)
    AS_SAFE         reduce using rule 37 (factor -> FLOAT .)
    EQEQ            reduce using rule 37 (factor -> FLOAT .)
    EQEQEQ          reduce using rule 37 (factor -> FLOAT .)


state 27

    (38) factor -> LONG .

    PLUS            reduce using rule 38 (factor -> LONG .)
    MINUS           reduce using rule 38 (factor -> LONG .)
    TIMES           reduce using rule 38 (factor -> LONG .)
    DIVIDE          reduce using rule 38 (factor -> LONG .)
    MOD             reduce using rule 38 (factor -> LONG .)
    $end            reduce using rule 38 (factor -> LONG .)
    RPAREN          reduce using rule 38 (factor -> LONG .)
    SEMICOLON       reduce using rule 38 (factor -> LONG .)
    RCURL           reduce using rule 38 (factor -> LONG .)
    CONJ            reduce using rule 38 (factor -> LONG .)
    DISJ            reduce using rule 38 (factor -> LONG .)
    LANGLE          reduce using rule 38 (factor -> LONG .)
    RANGLE          reduce using rule 38 (factor -> LONG .)
    LE              reduce using rule 38 (factor -> LONG .)
    GE              reduce using rule 38 (factor -> LONG .)
    EXCL_EQ         reduce using rule 38 (factor -> LONG .)
    EXCL_EQEQ       reduce using rule 38 (factor -> LONG .)
    AS_SAFE         reduce using rule 38 (factor -> LONG .)
    EQEQ            reduce using rule 38 (factor -> LONG .)
    EQEQEQ          reduce using rule 38 (factor -> LONG .)


state 28

    (39) factor -> CHAR .

    PLUS            reduce using rule 39 (factor -> CHAR .)
    MINUS           reduce using rule 39 (factor -> CHAR .)
    TIMES           reduce using rule 39 (factor -> CHAR .)
    DIVIDE          reduce using rule 39 (factor -> CHAR .)
    MOD             reduce using rule 39 (factor -> CHAR .)
    $end            reduce using rule 39 (factor -> CHAR .)
    RPAREN          reduce using rule 39 (factor -> CHAR .)
    SEMICOLON       reduce using rule 39 (factor -> CHAR .)
    RCURL           reduce using rule 39 (factor -> CHAR .)
    CONJ            reduce using rule 39 (factor -> CHAR .)
    DISJ            reduce using rule 39 (factor -> CHAR .)
    LANGLE          reduce using rule 39 (factor -> CHAR .)
    RANGLE          reduce using rule 39 (factor -> CHAR .)
    LE              reduce using rule 39 (factor -> CHAR .)
    GE              reduce using rule 39 (factor -> CHAR .)
    EXCL_EQ         reduce using rule 39 (factor -> CHAR .)
    EXCL_EQEQ       reduce using rule 39 (factor -> CHAR .)
    AS_SAFE         reduce using rule 39 (factor -> CHAR .)
    EQEQ            reduce using rule 39 (factor -> CHAR .)
    EQEQEQ          reduce using rule 39 (factor -> CHAR .)


state 29

    (40) factor -> BOOLEAN .

    PLUS            reduce using rule 40 (factor -> BOOLEAN .)
    MINUS           reduce using rule 40 (factor -> BOOLEAN .)
    TIMES           reduce using rule 40 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 40 (factor -> BOOLEAN .)
    MOD             reduce using rule 40 (factor -> BOOLEAN .)
    $end            reduce using rule 40 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 40 (factor -> BOOLEAN .)
    SEMICOLON       reduce using rule 40 (factor -> BOOLEAN .)
    RCURL           reduce using rule 40 (factor -> BOOLEAN .)
    CONJ            reduce using rule 40 (factor -> BOOLEAN .)
    DISJ            reduce using rule 40 (factor -> BOOLEAN .)
    LANGLE          reduce using rule 40 (factor -> BOOLEAN .)
    RANGLE          reduce using rule 40 (factor -> BOOLEAN .)
    LE              reduce using rule 40 (factor -> BOOLEAN .)
    GE              reduce using rule 40 (factor -> BOOLEAN .)
    EXCL_EQ         reduce using rule 40 (factor -> BOOLEAN .)
    EXCL_EQEQ       reduce using rule 40 (factor -> BOOLEAN .)
    AS_SAFE         reduce using rule 40 (factor -> BOOLEAN .)
    EQEQ            reduce using rule 40 (factor -> BOOLEAN .)
    EQEQEQ          reduce using rule 40 (factor -> BOOLEAN .)


state 30

    (42) factor -> STRING_1 .

    PLUS            reduce using rule 42 (factor -> STRING_1 .)
    MINUS           reduce using rule 42 (factor -> STRING_1 .)
    TIMES           reduce using rule 42 (factor -> STRING_1 .)
    DIVIDE          reduce using rule 42 (factor -> STRING_1 .)
    MOD             reduce using rule 42 (factor -> STRING_1 .)
    $end            reduce using rule 42 (factor -> STRING_1 .)
    RPAREN          reduce using rule 42 (factor -> STRING_1 .)
    SEMICOLON       reduce using rule 42 (factor -> STRING_1 .)
    RCURL           reduce using rule 42 (factor -> STRING_1 .)
    CONJ            reduce using rule 42 (factor -> STRING_1 .)
    DISJ            reduce using rule 42 (factor -> STRING_1 .)
    LANGLE          reduce using rule 42 (factor -> STRING_1 .)
    RANGLE          reduce using rule 42 (factor -> STRING_1 .)
    LE              reduce using rule 42 (factor -> STRING_1 .)
    GE              reduce using rule 42 (factor -> STRING_1 .)
    EXCL_EQ         reduce using rule 42 (factor -> STRING_1 .)
    EXCL_EQEQ       reduce using rule 42 (factor -> STRING_1 .)
    AS_SAFE         reduce using rule 42 (factor -> STRING_1 .)
    EQEQ            reduce using rule 42 (factor -> STRING_1 .)
    EQEQEQ          reduce using rule 42 (factor -> STRING_1 .)


state 31

    (1) line -> impresion SEMICOLON .

    $end            reduce using rule 1 (line -> impresion SEMICOLON .)
    RCURL           reduce using rule 1 (line -> impresion SEMICOLON .)


state 32

    (28) expression -> expression PLUS . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 51
    factor                         shift and go to state 22

state 33

    (29) expression -> expression MINUS . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 52
    factor                         shift and go to state 22

state 34

    (30) expression -> expression TIMES . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 53
    factor                         shift and go to state 22

state 35

    (31) expression -> expression DIVIDE . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 54
    factor                         shift and go to state 22

state 36

    (32) expression -> expression MOD . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 55
    factor                         shift and go to state 22

state 37

    (4) line -> asignacion SEMICOLON .

    $end            reduce using rule 4 (line -> asignacion SEMICOLON .)
    RCURL           reduce using rule 4 (line -> asignacion SEMICOLON .)


state 38

    (11) impresion -> PRINT LPAREN . term RPAREN
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 56
    factor                         shift and go to state 22

state 39

    (35) term -> LPAREN expression . RPAREN
    (28) expression -> expression . PLUS term
    (29) expression -> expression . MINUS term
    (30) expression -> expression . TIMES term
    (31) expression -> expression . DIVIDE term
    (32) expression -> expression . MOD term

    RPAREN          shift and go to state 57
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36


state 40

    (41) factor -> ID .

    RPAREN          reduce using rule 41 (factor -> ID .)
    PLUS            reduce using rule 41 (factor -> ID .)
    MINUS           reduce using rule 41 (factor -> ID .)
    TIMES           reduce using rule 41 (factor -> ID .)
    DIVIDE          reduce using rule 41 (factor -> ID .)
    MOD             reduce using rule 41 (factor -> ID .)
    $end            reduce using rule 41 (factor -> ID .)
    SEMICOLON       reduce using rule 41 (factor -> ID .)
    RCURL           reduce using rule 41 (factor -> ID .)
    CONJ            reduce using rule 41 (factor -> ID .)
    DISJ            reduce using rule 41 (factor -> ID .)
    LANGLE          reduce using rule 41 (factor -> ID .)
    RANGLE          reduce using rule 41 (factor -> ID .)
    LE              reduce using rule 41 (factor -> ID .)
    GE              reduce using rule 41 (factor -> ID .)
    EXCL_EQ         reduce using rule 41 (factor -> ID .)
    EXCL_EQEQ       reduce using rule 41 (factor -> ID .)
    AS_SAFE         reduce using rule 41 (factor -> ID .)
    EQEQ            reduce using rule 41 (factor -> ID .)
    EQEQEQ          reduce using rule 41 (factor -> ID .)


state 41

    (12) impresion -> PRINTLN LPAREN . term RPAREN
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 58
    factor                         shift and go to state 22

state 42

    (16) asignacion -> keywordVariables asignacionSimple .

    SEMICOLON       reduce using rule 16 (asignacion -> keywordVariables asignacionSimple .)
    $end            reduce using rule 16 (asignacion -> keywordVariables asignacionSimple .)
    RCURL           reduce using rule 16 (asignacion -> keywordVariables asignacionSimple .)


state 43

    (63) stack -> keywordVariables ID . DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (18) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> ID . EQUAL valor

    DOTS            shift and go to state 59
    EQUAL           shift and go to state 47


state 44

    (13) for -> FOR LPAREN . ID IN ID RPAREN LCURL line RCURL

    ID              shift and go to state 60


state 45

    (66) stack_actuar -> ID DOT . stack_funciones
    (67) stack_funciones -> . stack_isEmpty
    (68) stack_funciones -> . stack_push
    (69) stack_funciones -> . stack_pop
    (70) stack_isEmpty -> . ISEMPTY LPAREN RPAREN
    (72) stack_push -> . PUSH LPAREN ID RPAREN
    (71) stack_pop -> . POP LPAREN RPAREN

    ISEMPTY         shift and go to state 65
    PUSH            shift and go to state 66
    POP             shift and go to state 67

    stack_funciones                shift and go to state 61
    stack_isEmpty                  shift and go to state 62
    stack_push                     shift and go to state 63
    stack_pop                      shift and go to state 64

state 46

    (18) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (20) tipoDato -> . TINT
    (21) tipoDato -> . TLONG
    (22) tipoDato -> . TFLOAT
    (23) tipoDato -> . TDOUBLE
    (24) tipoDato -> . TBOOLEAN
    (25) tipoDato -> . TCHAR
    (26) tipoDato -> . TSTRING

    TINT            shift and go to state 69
    TLONG           shift and go to state 70
    TFLOAT          shift and go to state 71
    TDOUBLE         shift and go to state 72
    TBOOLEAN        shift and go to state 73
    TCHAR           shift and go to state 74
    TSTRING         shift and go to state 75

    tipoDato                       shift and go to state 68

state 47

    (19) asignacionSimple -> ID EQUAL . valor
    (27) valor -> . expression
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    valor                          shift and go to state 76
    expression                     shift and go to state 77
    term                           shift and go to state 13
    factor                         shift and go to state 22

state 48

    (43) if -> IF LPAREN . condicion RPAREN LCURL line RCURL
    (44) if -> IF LPAREN . condicion RPAREN LCURL line RCURL else
    (46) condicion -> . condicionL
    (47) condicion -> . condicionR
    (48) condicion -> . condicionN
    (49) condicionL -> . term opL term
    (50) condicionR -> . term opR term
    (51) condicionN -> . EXCL_WS term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    EXCL_WS         shift and go to state 83
    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    condicion                      shift and go to state 78
    condicionL                     shift and go to state 79
    condicionR                     shift and go to state 80
    condicionN                     shift and go to state 81
    term                           shift and go to state 82
    factor                         shift and go to state 22

state 49

    (65) instance_arraylist -> ARRAYLIST LPAREN . RPAREN

    RPAREN          shift and go to state 84


state 50

    (64) def_estruct_tipoDato -> STACK LANGLE . tipoDato RANGLE
    (20) tipoDato -> . TINT
    (21) tipoDato -> . TLONG
    (22) tipoDato -> . TFLOAT
    (23) tipoDato -> . TDOUBLE
    (24) tipoDato -> . TBOOLEAN
    (25) tipoDato -> . TCHAR
    (26) tipoDato -> . TSTRING

    TINT            shift and go to state 69
    TLONG           shift and go to state 70
    TFLOAT          shift and go to state 71
    TDOUBLE         shift and go to state 72
    TBOOLEAN        shift and go to state 73
    TCHAR           shift and go to state 74
    TSTRING         shift and go to state 75

    tipoDato                       shift and go to state 85

state 51

    (28) expression -> expression PLUS term .

    PLUS            reduce using rule 28 (expression -> expression PLUS term .)
    MINUS           reduce using rule 28 (expression -> expression PLUS term .)
    TIMES           reduce using rule 28 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 28 (expression -> expression PLUS term .)
    MOD             reduce using rule 28 (expression -> expression PLUS term .)
    $end            reduce using rule 28 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 28 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 28 (expression -> expression PLUS term .)
    RCURL           reduce using rule 28 (expression -> expression PLUS term .)


state 52

    (29) expression -> expression MINUS term .

    PLUS            reduce using rule 29 (expression -> expression MINUS term .)
    MINUS           reduce using rule 29 (expression -> expression MINUS term .)
    TIMES           reduce using rule 29 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 29 (expression -> expression MINUS term .)
    MOD             reduce using rule 29 (expression -> expression MINUS term .)
    $end            reduce using rule 29 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 29 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 29 (expression -> expression MINUS term .)
    RCURL           reduce using rule 29 (expression -> expression MINUS term .)


state 53

    (30) expression -> expression TIMES term .

    PLUS            reduce using rule 30 (expression -> expression TIMES term .)
    MINUS           reduce using rule 30 (expression -> expression TIMES term .)
    TIMES           reduce using rule 30 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 30 (expression -> expression TIMES term .)
    MOD             reduce using rule 30 (expression -> expression TIMES term .)
    $end            reduce using rule 30 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 30 (expression -> expression TIMES term .)
    SEMICOLON       reduce using rule 30 (expression -> expression TIMES term .)
    RCURL           reduce using rule 30 (expression -> expression TIMES term .)


state 54

    (31) expression -> expression DIVIDE term .

    PLUS            reduce using rule 31 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 31 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 31 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 31 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 31 (expression -> expression DIVIDE term .)
    $end            reduce using rule 31 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 31 (expression -> expression DIVIDE term .)
    SEMICOLON       reduce using rule 31 (expression -> expression DIVIDE term .)
    RCURL           reduce using rule 31 (expression -> expression DIVIDE term .)


state 55

    (32) expression -> expression MOD term .

    PLUS            reduce using rule 32 (expression -> expression MOD term .)
    MINUS           reduce using rule 32 (expression -> expression MOD term .)
    TIMES           reduce using rule 32 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 32 (expression -> expression MOD term .)
    MOD             reduce using rule 32 (expression -> expression MOD term .)
    $end            reduce using rule 32 (expression -> expression MOD term .)
    RPAREN          reduce using rule 32 (expression -> expression MOD term .)
    SEMICOLON       reduce using rule 32 (expression -> expression MOD term .)
    RCURL           reduce using rule 32 (expression -> expression MOD term .)


state 56

    (11) impresion -> PRINT LPAREN term . RPAREN

    RPAREN          shift and go to state 86


state 57

    (35) term -> LPAREN expression RPAREN .

    PLUS            reduce using rule 35 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 35 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 35 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 35 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 35 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 35 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 35 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 35 (term -> LPAREN expression RPAREN .)
    RCURL           reduce using rule 35 (term -> LPAREN expression RPAREN .)
    CONJ            reduce using rule 35 (term -> LPAREN expression RPAREN .)
    DISJ            reduce using rule 35 (term -> LPAREN expression RPAREN .)
    LANGLE          reduce using rule 35 (term -> LPAREN expression RPAREN .)
    RANGLE          reduce using rule 35 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 35 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 35 (term -> LPAREN expression RPAREN .)
    EXCL_EQ         reduce using rule 35 (term -> LPAREN expression RPAREN .)
    EXCL_EQEQ       reduce using rule 35 (term -> LPAREN expression RPAREN .)
    AS_SAFE         reduce using rule 35 (term -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 35 (term -> LPAREN expression RPAREN .)
    EQEQEQ          reduce using rule 35 (term -> LPAREN expression RPAREN .)


state 58

    (12) impresion -> PRINTLN LPAREN term . RPAREN

    RPAREN          shift and go to state 87


state 59

    (63) stack -> keywordVariables ID DOTS . def_estruct_tipoDato EQUAL instance_arraylist
    (18) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (64) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (20) tipoDato -> . TINT
    (21) tipoDato -> . TLONG
    (22) tipoDato -> . TFLOAT
    (23) tipoDato -> . TDOUBLE
    (24) tipoDato -> . TBOOLEAN
    (25) tipoDato -> . TCHAR
    (26) tipoDato -> . TSTRING

    STACK           shift and go to state 21
    TINT            shift and go to state 69
    TLONG           shift and go to state 70
    TFLOAT          shift and go to state 71
    TDOUBLE         shift and go to state 72
    TBOOLEAN        shift and go to state 73
    TCHAR           shift and go to state 74
    TSTRING         shift and go to state 75

    def_estruct_tipoDato           shift and go to state 88
    tipoDato                       shift and go to state 68

state 60

    (13) for -> FOR LPAREN ID . IN ID RPAREN LCURL line RCURL

    IN              shift and go to state 89


state 61

    (66) stack_actuar -> ID DOT stack_funciones .

    $end            reduce using rule 66 (stack_actuar -> ID DOT stack_funciones .)
    RCURL           reduce using rule 66 (stack_actuar -> ID DOT stack_funciones .)


state 62

    (67) stack_funciones -> stack_isEmpty .

    $end            reduce using rule 67 (stack_funciones -> stack_isEmpty .)
    RCURL           reduce using rule 67 (stack_funciones -> stack_isEmpty .)


state 63

    (68) stack_funciones -> stack_push .

    $end            reduce using rule 68 (stack_funciones -> stack_push .)
    RCURL           reduce using rule 68 (stack_funciones -> stack_push .)


state 64

    (69) stack_funciones -> stack_pop .

    $end            reduce using rule 69 (stack_funciones -> stack_pop .)
    RCURL           reduce using rule 69 (stack_funciones -> stack_pop .)


state 65

    (70) stack_isEmpty -> ISEMPTY . LPAREN RPAREN

    LPAREN          shift and go to state 90


state 66

    (72) stack_push -> PUSH . LPAREN ID RPAREN

    LPAREN          shift and go to state 91


state 67

    (71) stack_pop -> POP . LPAREN RPAREN

    LPAREN          shift and go to state 92


state 68

    (18) asignacionSimple -> ID DOTS tipoDato . EQUAL valor

    EQUAL           shift and go to state 93


state 69

    (20) tipoDato -> TINT .

    EQUAL           reduce using rule 20 (tipoDato -> TINT .)
    RANGLE          reduce using rule 20 (tipoDato -> TINT .)


state 70

    (21) tipoDato -> TLONG .

    EQUAL           reduce using rule 21 (tipoDato -> TLONG .)
    RANGLE          reduce using rule 21 (tipoDato -> TLONG .)


state 71

    (22) tipoDato -> TFLOAT .

    EQUAL           reduce using rule 22 (tipoDato -> TFLOAT .)
    RANGLE          reduce using rule 22 (tipoDato -> TFLOAT .)


state 72

    (23) tipoDato -> TDOUBLE .

    EQUAL           reduce using rule 23 (tipoDato -> TDOUBLE .)
    RANGLE          reduce using rule 23 (tipoDato -> TDOUBLE .)


state 73

    (24) tipoDato -> TBOOLEAN .

    EQUAL           reduce using rule 24 (tipoDato -> TBOOLEAN .)
    RANGLE          reduce using rule 24 (tipoDato -> TBOOLEAN .)


state 74

    (25) tipoDato -> TCHAR .

    EQUAL           reduce using rule 25 (tipoDato -> TCHAR .)
    RANGLE          reduce using rule 25 (tipoDato -> TCHAR .)


state 75

    (26) tipoDato -> TSTRING .

    EQUAL           reduce using rule 26 (tipoDato -> TSTRING .)
    RANGLE          reduce using rule 26 (tipoDato -> TSTRING .)


state 76

    (19) asignacionSimple -> ID EQUAL valor .

    SEMICOLON       reduce using rule 19 (asignacionSimple -> ID EQUAL valor .)
    $end            reduce using rule 19 (asignacionSimple -> ID EQUAL valor .)
    RCURL           reduce using rule 19 (asignacionSimple -> ID EQUAL valor .)


state 77

    (27) valor -> expression .
    (28) expression -> expression . PLUS term
    (29) expression -> expression . MINUS term
    (30) expression -> expression . TIMES term
    (31) expression -> expression . DIVIDE term
    (32) expression -> expression . MOD term

    SEMICOLON       reduce using rule 27 (valor -> expression .)
    $end            reduce using rule 27 (valor -> expression .)
    RCURL           reduce using rule 27 (valor -> expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35
    MOD             shift and go to state 36


state 78

    (43) if -> IF LPAREN condicion . RPAREN LCURL line RCURL
    (44) if -> IF LPAREN condicion . RPAREN LCURL line RCURL else

    RPAREN          shift and go to state 94


state 79

    (46) condicion -> condicionL .

    RPAREN          reduce using rule 46 (condicion -> condicionL .)


state 80

    (47) condicion -> condicionR .

    RPAREN          reduce using rule 47 (condicion -> condicionR .)


state 81

    (48) condicion -> condicionN .

    RPAREN          reduce using rule 48 (condicion -> condicionN .)


state 82

    (49) condicionL -> term . opL term
    (50) condicionR -> term . opR term
    (52) opL -> . CONJ
    (53) opL -> . DISJ
    (54) opR -> . LANGLE
    (55) opR -> . RANGLE
    (56) opR -> . LE
    (57) opR -> . GE
    (58) opR -> . EXCL_EQ
    (59) opR -> . EXCL_EQEQ
    (60) opR -> . AS_SAFE
    (61) opR -> . EQEQ
    (62) opR -> . EQEQEQ

    CONJ            shift and go to state 97
    DISJ            shift and go to state 98
    LANGLE          shift and go to state 99
    RANGLE          shift and go to state 100
    LE              shift and go to state 101
    GE              shift and go to state 102
    EXCL_EQ         shift and go to state 103
    EXCL_EQEQ       shift and go to state 104
    AS_SAFE         shift and go to state 105
    EQEQ            shift and go to state 106
    EQEQEQ          shift and go to state 107

    opL                            shift and go to state 95
    opR                            shift and go to state 96

state 83

    (51) condicionN -> EXCL_WS . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 108
    factor                         shift and go to state 22

state 84

    (65) instance_arraylist -> ARRAYLIST LPAREN RPAREN .

    $end            reduce using rule 65 (instance_arraylist -> ARRAYLIST LPAREN RPAREN .)
    RCURL           reduce using rule 65 (instance_arraylist -> ARRAYLIST LPAREN RPAREN .)


state 85

    (64) def_estruct_tipoDato -> STACK LANGLE tipoDato . RANGLE

    RANGLE          shift and go to state 109


state 86

    (11) impresion -> PRINT LPAREN term RPAREN .

    SEMICOLON       reduce using rule 11 (impresion -> PRINT LPAREN term RPAREN .)


state 87

    (12) impresion -> PRINTLN LPAREN term RPAREN .

    SEMICOLON       reduce using rule 12 (impresion -> PRINTLN LPAREN term RPAREN .)


state 88

    (63) stack -> keywordVariables ID DOTS def_estruct_tipoDato . EQUAL instance_arraylist

    EQUAL           shift and go to state 110


state 89

    (13) for -> FOR LPAREN ID IN . ID RPAREN LCURL line RCURL

    ID              shift and go to state 111


state 90

    (70) stack_isEmpty -> ISEMPTY LPAREN . RPAREN

    RPAREN          shift and go to state 112


state 91

    (72) stack_push -> PUSH LPAREN . ID RPAREN

    ID              shift and go to state 113


state 92

    (71) stack_pop -> POP LPAREN . RPAREN

    RPAREN          shift and go to state 114


state 93

    (18) asignacionSimple -> ID DOTS tipoDato EQUAL . valor
    (27) valor -> . expression
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    valor                          shift and go to state 115
    expression                     shift and go to state 77
    term                           shift and go to state 13
    factor                         shift and go to state 22

state 94

    (43) if -> IF LPAREN condicion RPAREN . LCURL line RCURL
    (44) if -> IF LPAREN condicion RPAREN . LCURL line RCURL else

    LCURL           shift and go to state 116


state 95

    (49) condicionL -> term opL . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 117
    factor                         shift and go to state 22

state 96

    (50) condicionR -> term opR . term
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    LPAREN          shift and go to state 12
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 40
    STRING_1        shift and go to state 30

    term                           shift and go to state 118
    factor                         shift and go to state 22

state 97

    (52) opL -> CONJ .

    LPAREN          reduce using rule 52 (opL -> CONJ .)
    INT             reduce using rule 52 (opL -> CONJ .)
    FLOAT           reduce using rule 52 (opL -> CONJ .)
    LONG            reduce using rule 52 (opL -> CONJ .)
    CHAR            reduce using rule 52 (opL -> CONJ .)
    BOOLEAN         reduce using rule 52 (opL -> CONJ .)
    ID              reduce using rule 52 (opL -> CONJ .)
    STRING_1        reduce using rule 52 (opL -> CONJ .)


state 98

    (53) opL -> DISJ .

    LPAREN          reduce using rule 53 (opL -> DISJ .)
    INT             reduce using rule 53 (opL -> DISJ .)
    FLOAT           reduce using rule 53 (opL -> DISJ .)
    LONG            reduce using rule 53 (opL -> DISJ .)
    CHAR            reduce using rule 53 (opL -> DISJ .)
    BOOLEAN         reduce using rule 53 (opL -> DISJ .)
    ID              reduce using rule 53 (opL -> DISJ .)
    STRING_1        reduce using rule 53 (opL -> DISJ .)


state 99

    (54) opR -> LANGLE .

    LPAREN          reduce using rule 54 (opR -> LANGLE .)
    INT             reduce using rule 54 (opR -> LANGLE .)
    FLOAT           reduce using rule 54 (opR -> LANGLE .)
    LONG            reduce using rule 54 (opR -> LANGLE .)
    CHAR            reduce using rule 54 (opR -> LANGLE .)
    BOOLEAN         reduce using rule 54 (opR -> LANGLE .)
    ID              reduce using rule 54 (opR -> LANGLE .)
    STRING_1        reduce using rule 54 (opR -> LANGLE .)


state 100

    (55) opR -> RANGLE .

    LPAREN          reduce using rule 55 (opR -> RANGLE .)
    INT             reduce using rule 55 (opR -> RANGLE .)
    FLOAT           reduce using rule 55 (opR -> RANGLE .)
    LONG            reduce using rule 55 (opR -> RANGLE .)
    CHAR            reduce using rule 55 (opR -> RANGLE .)
    BOOLEAN         reduce using rule 55 (opR -> RANGLE .)
    ID              reduce using rule 55 (opR -> RANGLE .)
    STRING_1        reduce using rule 55 (opR -> RANGLE .)


state 101

    (56) opR -> LE .

    LPAREN          reduce using rule 56 (opR -> LE .)
    INT             reduce using rule 56 (opR -> LE .)
    FLOAT           reduce using rule 56 (opR -> LE .)
    LONG            reduce using rule 56 (opR -> LE .)
    CHAR            reduce using rule 56 (opR -> LE .)
    BOOLEAN         reduce using rule 56 (opR -> LE .)
    ID              reduce using rule 56 (opR -> LE .)
    STRING_1        reduce using rule 56 (opR -> LE .)


state 102

    (57) opR -> GE .

    LPAREN          reduce using rule 57 (opR -> GE .)
    INT             reduce using rule 57 (opR -> GE .)
    FLOAT           reduce using rule 57 (opR -> GE .)
    LONG            reduce using rule 57 (opR -> GE .)
    CHAR            reduce using rule 57 (opR -> GE .)
    BOOLEAN         reduce using rule 57 (opR -> GE .)
    ID              reduce using rule 57 (opR -> GE .)
    STRING_1        reduce using rule 57 (opR -> GE .)


state 103

    (58) opR -> EXCL_EQ .

    LPAREN          reduce using rule 58 (opR -> EXCL_EQ .)
    INT             reduce using rule 58 (opR -> EXCL_EQ .)
    FLOAT           reduce using rule 58 (opR -> EXCL_EQ .)
    LONG            reduce using rule 58 (opR -> EXCL_EQ .)
    CHAR            reduce using rule 58 (opR -> EXCL_EQ .)
    BOOLEAN         reduce using rule 58 (opR -> EXCL_EQ .)
    ID              reduce using rule 58 (opR -> EXCL_EQ .)
    STRING_1        reduce using rule 58 (opR -> EXCL_EQ .)


state 104

    (59) opR -> EXCL_EQEQ .

    LPAREN          reduce using rule 59 (opR -> EXCL_EQEQ .)
    INT             reduce using rule 59 (opR -> EXCL_EQEQ .)
    FLOAT           reduce using rule 59 (opR -> EXCL_EQEQ .)
    LONG            reduce using rule 59 (opR -> EXCL_EQEQ .)
    CHAR            reduce using rule 59 (opR -> EXCL_EQEQ .)
    BOOLEAN         reduce using rule 59 (opR -> EXCL_EQEQ .)
    ID              reduce using rule 59 (opR -> EXCL_EQEQ .)
    STRING_1        reduce using rule 59 (opR -> EXCL_EQEQ .)


state 105

    (60) opR -> AS_SAFE .

    LPAREN          reduce using rule 60 (opR -> AS_SAFE .)
    INT             reduce using rule 60 (opR -> AS_SAFE .)
    FLOAT           reduce using rule 60 (opR -> AS_SAFE .)
    LONG            reduce using rule 60 (opR -> AS_SAFE .)
    CHAR            reduce using rule 60 (opR -> AS_SAFE .)
    BOOLEAN         reduce using rule 60 (opR -> AS_SAFE .)
    ID              reduce using rule 60 (opR -> AS_SAFE .)
    STRING_1        reduce using rule 60 (opR -> AS_SAFE .)


state 106

    (61) opR -> EQEQ .

    LPAREN          reduce using rule 61 (opR -> EQEQ .)
    INT             reduce using rule 61 (opR -> EQEQ .)
    FLOAT           reduce using rule 61 (opR -> EQEQ .)
    LONG            reduce using rule 61 (opR -> EQEQ .)
    CHAR            reduce using rule 61 (opR -> EQEQ .)
    BOOLEAN         reduce using rule 61 (opR -> EQEQ .)
    ID              reduce using rule 61 (opR -> EQEQ .)
    STRING_1        reduce using rule 61 (opR -> EQEQ .)


state 107

    (62) opR -> EQEQEQ .

    LPAREN          reduce using rule 62 (opR -> EQEQEQ .)
    INT             reduce using rule 62 (opR -> EQEQEQ .)
    FLOAT           reduce using rule 62 (opR -> EQEQEQ .)
    LONG            reduce using rule 62 (opR -> EQEQEQ .)
    CHAR            reduce using rule 62 (opR -> EQEQEQ .)
    BOOLEAN         reduce using rule 62 (opR -> EQEQEQ .)
    ID              reduce using rule 62 (opR -> EQEQEQ .)
    STRING_1        reduce using rule 62 (opR -> EQEQEQ .)


state 108

    (51) condicionN -> EXCL_WS term .

    RPAREN          reduce using rule 51 (condicionN -> EXCL_WS term .)


state 109

    (64) def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .

    $end            reduce using rule 64 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)
    EQUAL           reduce using rule 64 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)
    RCURL           reduce using rule 64 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)


state 110

    (63) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL . instance_arraylist
    (65) instance_arraylist -> . ARRAYLIST LPAREN RPAREN

    ARRAYLIST       shift and go to state 20

    instance_arraylist             shift and go to state 119

state 111

    (13) for -> FOR LPAREN ID IN ID . RPAREN LCURL line RCURL

    RPAREN          shift and go to state 120


state 112

    (70) stack_isEmpty -> ISEMPTY LPAREN RPAREN .

    $end            reduce using rule 70 (stack_isEmpty -> ISEMPTY LPAREN RPAREN .)
    RCURL           reduce using rule 70 (stack_isEmpty -> ISEMPTY LPAREN RPAREN .)


state 113

    (72) stack_push -> PUSH LPAREN ID . RPAREN

    RPAREN          shift and go to state 121


state 114

    (71) stack_pop -> POP LPAREN RPAREN .

    $end            reduce using rule 71 (stack_pop -> POP LPAREN RPAREN .)
    RCURL           reduce using rule 71 (stack_pop -> POP LPAREN RPAREN .)


state 115

    (18) asignacionSimple -> ID DOTS tipoDato EQUAL valor .

    SEMICOLON       reduce using rule 18 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)
    $end            reduce using rule 18 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)
    RCURL           reduce using rule 18 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)


state 116

    (43) if -> IF LPAREN condicion RPAREN LCURL . line RCURL
    (44) if -> IF LPAREN condicion RPAREN LCURL . line RCURL else
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion
    (4) line -> . asignacion SEMICOLON
    (5) line -> . for
    (6) line -> . if
    (7) line -> . stack
    (8) line -> . stack_actuar
    (9) line -> . instance_arraylist
    (10) line -> . def_estruct_tipoDato
    (11) impresion -> . PRINT LPAREN term RPAREN
    (12) impresion -> . PRINTLN LPAREN term RPAREN
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (16) asignacion -> . keywordVariables asignacionSimple
    (17) asignacion -> . asignacionSimple
    (13) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (43) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (44) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (63) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (66) stack_actuar -> . ID DOT stack_funciones
    (65) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (64) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (14) keywordVariables -> . VAR
    (15) keywordVariables -> . VAL
    (18) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> . ID EQUAL valor
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    PRINT           shift and go to state 11
    PRINTLN         shift and go to state 14
    FOR             shift and go to state 17
    IF              shift and go to state 19
    ID              shift and go to state 18
    ARRAYLIST       shift and go to state 20
    STACK           shift and go to state 21
    LPAREN          shift and go to state 12
    VAR             shift and go to state 23
    VAL             shift and go to state 24
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    STRING_1        shift and go to state 30

    line                           shift and go to state 122
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    stack                          shift and go to state 7
    stack_actuar                   shift and go to state 8
    instance_arraylist             shift and go to state 9
    def_estruct_tipoDato           shift and go to state 10
    term                           shift and go to state 13
    keywordVariables               shift and go to state 15
    asignacionSimple               shift and go to state 16
    factor                         shift and go to state 22

state 117

    (49) condicionL -> term opL term .

    RPAREN          reduce using rule 49 (condicionL -> term opL term .)


state 118

    (50) condicionR -> term opR term .

    RPAREN          reduce using rule 50 (condicionR -> term opR term .)


state 119

    (63) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .

    $end            reduce using rule 63 (stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .)
    RCURL           reduce using rule 63 (stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .)


state 120

    (13) for -> FOR LPAREN ID IN ID RPAREN . LCURL line RCURL

    LCURL           shift and go to state 123


state 121

    (72) stack_push -> PUSH LPAREN ID RPAREN .

    $end            reduce using rule 72 (stack_push -> PUSH LPAREN ID RPAREN .)
    RCURL           reduce using rule 72 (stack_push -> PUSH LPAREN ID RPAREN .)


state 122

    (43) if -> IF LPAREN condicion RPAREN LCURL line . RCURL
    (44) if -> IF LPAREN condicion RPAREN LCURL line . RCURL else

    RCURL           shift and go to state 124


state 123

    (13) for -> FOR LPAREN ID IN ID RPAREN LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion
    (4) line -> . asignacion SEMICOLON
    (5) line -> . for
    (6) line -> . if
    (7) line -> . stack
    (8) line -> . stack_actuar
    (9) line -> . instance_arraylist
    (10) line -> . def_estruct_tipoDato
    (11) impresion -> . PRINT LPAREN term RPAREN
    (12) impresion -> . PRINTLN LPAREN term RPAREN
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (16) asignacion -> . keywordVariables asignacionSimple
    (17) asignacion -> . asignacionSimple
    (13) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (43) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (44) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (63) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (66) stack_actuar -> . ID DOT stack_funciones
    (65) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (64) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (14) keywordVariables -> . VAR
    (15) keywordVariables -> . VAL
    (18) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> . ID EQUAL valor
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    PRINT           shift and go to state 11
    PRINTLN         shift and go to state 14
    FOR             shift and go to state 17
    IF              shift and go to state 19
    ID              shift and go to state 18
    ARRAYLIST       shift and go to state 20
    STACK           shift and go to state 21
    LPAREN          shift and go to state 12
    VAR             shift and go to state 23
    VAL             shift and go to state 24
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    STRING_1        shift and go to state 30

    line                           shift and go to state 125
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    stack                          shift and go to state 7
    stack_actuar                   shift and go to state 8
    instance_arraylist             shift and go to state 9
    def_estruct_tipoDato           shift and go to state 10
    term                           shift and go to state 13
    keywordVariables               shift and go to state 15
    asignacionSimple               shift and go to state 16
    factor                         shift and go to state 22

state 124

    (43) if -> IF LPAREN condicion RPAREN LCURL line RCURL .
    (44) if -> IF LPAREN condicion RPAREN LCURL line RCURL . else
    (45) else -> . ELSE LCURL line RCURL

    $end            reduce using rule 43 (if -> IF LPAREN condicion RPAREN LCURL line RCURL .)
    RCURL           reduce using rule 43 (if -> IF LPAREN condicion RPAREN LCURL line RCURL .)
    ELSE            shift and go to state 127

    else                           shift and go to state 126

state 125

    (13) for -> FOR LPAREN ID IN ID RPAREN LCURL line . RCURL

    RCURL           shift and go to state 128


state 126

    (44) if -> IF LPAREN condicion RPAREN LCURL line RCURL else .

    $end            reduce using rule 44 (if -> IF LPAREN condicion RPAREN LCURL line RCURL else .)
    RCURL           reduce using rule 44 (if -> IF LPAREN condicion RPAREN LCURL line RCURL else .)


state 127

    (45) else -> ELSE . LCURL line RCURL

    LCURL           shift and go to state 129


state 128

    (13) for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .

    $end            reduce using rule 13 (for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .)
    RCURL           reduce using rule 13 (for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .)


state 129

    (45) else -> ELSE LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion
    (4) line -> . asignacion SEMICOLON
    (5) line -> . for
    (6) line -> . if
    (7) line -> . stack
    (8) line -> . stack_actuar
    (9) line -> . instance_arraylist
    (10) line -> . def_estruct_tipoDato
    (11) impresion -> . PRINT LPAREN term RPAREN
    (12) impresion -> . PRINTLN LPAREN term RPAREN
    (28) expression -> . expression PLUS term
    (29) expression -> . expression MINUS term
    (30) expression -> . expression TIMES term
    (31) expression -> . expression DIVIDE term
    (32) expression -> . expression MOD term
    (33) expression -> . term
    (16) asignacion -> . keywordVariables asignacionSimple
    (17) asignacion -> . asignacionSimple
    (13) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (43) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (44) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (63) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (66) stack_actuar -> . ID DOT stack_funciones
    (65) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (64) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (34) term -> . factor
    (35) term -> . LPAREN expression RPAREN
    (14) keywordVariables -> . VAR
    (15) keywordVariables -> . VAL
    (18) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (19) asignacionSimple -> . ID EQUAL valor
    (36) factor -> . INT
    (37) factor -> . FLOAT
    (38) factor -> . LONG
    (39) factor -> . CHAR
    (40) factor -> . BOOLEAN
    (41) factor -> . ID
    (42) factor -> . STRING_1

    PRINT           shift and go to state 11
    PRINTLN         shift and go to state 14
    FOR             shift and go to state 17
    IF              shift and go to state 19
    ID              shift and go to state 18
    ARRAYLIST       shift and go to state 20
    STACK           shift and go to state 21
    LPAREN          shift and go to state 12
    VAR             shift and go to state 23
    VAL             shift and go to state 24
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    LONG            shift and go to state 27
    CHAR            shift and go to state 28
    BOOLEAN         shift and go to state 29
    STRING_1        shift and go to state 30

    line                           shift and go to state 130
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    stack                          shift and go to state 7
    stack_actuar                   shift and go to state 8
    instance_arraylist             shift and go to state 9
    def_estruct_tipoDato           shift and go to state 10
    term                           shift and go to state 13
    keywordVariables               shift and go to state 15
    asignacionSimple               shift and go to state 16
    factor                         shift and go to state 22

state 130

    (45) else -> ELSE LCURL line . RCURL

    RCURL           shift and go to state 131


state 131

    (45) else -> ELSE LCURL line RCURL .

    $end            reduce using rule 45 (else -> ELSE LCURL line RCURL .)
    RCURL           reduce using rule 45 (else -> ELSE LCURL line RCURL .)

