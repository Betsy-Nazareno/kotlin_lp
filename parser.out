Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ACTUAL
    ANNOTATION
    APPEND
    ARRAYOF
    ARROW
    AS
    AT_NO_WS
    BREAK
    BY
    CATCH
    CLASS
    COLONCOLON
    COMMA
    COMMENT
    COMPANION
    CONST
    CONSTRUCTOR
    CONTINUE
    CROSSINLINE
    DATA
    DECR
    DECREMENTIN
    DECREMENTONE
    DIVIDEIN
    DO
    DOUBLE_ARROW
    DOUBLE_SEMICOLON
    DYNAMIC
    ENUM
    EXCL_NO_WS
    EXPECT
    EXTERNAL
    FIELD
    FILE
    FINAL
    FINALLY
    FUN
    GET
    HASH
    IMPORT
    INCR
    INCREMENTIN
    INCREMENTONE
    INCREMENTTIMES
    INFIX
    INIT
    INLINE
    INNER
    INTERFACE
    INTERNAL
    IS
    LATEINIT
    LINEBREAK
    LISTOF
    LSQUARE
    MARK_1
    MARK_2
    MODIN
    NOINLINE
    OPEN
    OPERATOR
    OUT
    OVERRIDE
    PACKAGE
    PARAM
    PRIVATE
    PROPERTY
    PROTECTED
    PUBLIC
    QUEST_WS
    RANGE
    RECEIVER
    REIFIED
    REMOVEI
    REMOVEN
    RETURN
    RSQUARE
    SEALED
    SET
    SETPARAM
    SINGLE_QUOTE
    SUM
    SUPER
    SUSPEND
    TAILREC
    TEMPLATE
    THIS
    THROW
    TRY
    TYPEOF
    TYPE_ALIAS
    VALUE
    VAL_TIPO_1
    VARARG
    VAR_TIPO_1
    WHEN
    WHERE

Grammar

Rule 0     S' -> line
Rule 1     line -> impresion SEMICOLON
Rule 2     line -> asignacion SEMICOLON
Rule 3     line -> expression
Rule 4     line -> estructurasControl
Rule 5     line -> estructurasDatos SEMICOLON
Rule 6     line -> condicion
Rule 7     estructurasDatos -> queue
Rule 8     estructurasDatos -> queue_operations
Rule 9     estructurasDatos -> stack
Rule 10    estructurasDatos -> stack_actuar
Rule 11    estructurasDatos -> instance_arraylist
Rule 12    estructurasDatos -> def_estruct_tipoDato
Rule 13    estructurasDatos -> lista
Rule 14    estructurasDatos -> lsimplem
Rule 15    estructurasDatos -> <empty>
Rule 16    estructurasControl -> for
Rule 17    estructurasControl -> if
Rule 18    estructurasControl -> while
Rule 19    queue_operations -> queue_add
Rule 20    queue_operations -> queue_peek
Rule 21    queue_operations -> queue_remove
Rule 22    queue_operations -> queue_poll
Rule 23    queue_add -> ID DOT ADD LPAREN factor RPAREN
Rule 24    queue_peek -> ID DOT PEEK LPAREN RPAREN
Rule 25    queue_poll -> ID DOT POLL LPAREN RPAREN
Rule 26    queue_remove -> ID DOT REMOVE LPAREN RPAREN
Rule 27    impresion -> PRINT LPAREN expression RPAREN
Rule 28    impresion -> PRINTLN LPAREN expression RPAREN
Rule 29    queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
Rule 30    for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
Rule 31    morelines -> line
Rule 32    morelines -> line morelines
Rule 33    asignacion -> keywordVariables asignacionSimple
Rule 34    asignacion -> asignacionSimple
Rule 35    keywordVariables -> VAR
Rule 36    keywordVariables -> VAL
Rule 37    asignacionSimple -> ID DOTS tipoDato EQUAL valor
Rule 38    asignacionSimple -> ID EQUAL valor
Rule 39    tipoDato -> TINT
Rule 40    tipoDato -> TLONG
Rule 41    tipoDato -> TFLOAT
Rule 42    tipoDato -> TDOUBLE
Rule 43    tipoDato -> TBOOLEAN
Rule 44    tipoDato -> TCHAR
Rule 45    tipoDato -> TSTRING
Rule 46    valor -> expression
Rule 47    expression -> expression PLUS term
Rule 48    expression -> expression MINUS term
Rule 49    expression -> expression TIMES term
Rule 50    expression -> expression DIVIDE term
Rule 51    expression -> expression MOD term
Rule 52    expression -> term
Rule 53    term -> factor
Rule 54    term -> LPAREN expression RPAREN
Rule 55    factor -> INT
Rule 56    factor -> FLOAT
Rule 57    factor -> LONG
Rule 58    factor -> CHAR
Rule 59    factor -> BOOLEAN
Rule 60    factor -> ID
Rule 61    factor -> STRING_1
Rule 62    if -> IF LPAREN condicion RPAREN LCURL morelines RCURL
Rule 63    if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else
Rule 64    else -> ELSE LCURL line RCURL
Rule 65    condicion -> condicionL
Rule 66    condicion -> condicionR
Rule 67    condicion -> condicionN
Rule 68    condicionL -> term opL term
Rule 69    condicionR -> term opR term
Rule 70    condicionN -> EXCL_WS term
Rule 71    opL -> CONJ
Rule 72    opL -> DISJ
Rule 73    opR -> LANGLE
Rule 74    opR -> RANGLE
Rule 75    opR -> LE
Rule 76    opR -> GE
Rule 77    opR -> EXCL_EQ
Rule 78    opR -> EXCL_EQEQ
Rule 79    opR -> AS_SAFE
Rule 80    opR -> EQEQ
Rule 81    opR -> EQEQEQ
Rule 82    stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
Rule 83    def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE
Rule 84    instance_arraylist -> ARRAYLIST LPAREN RPAREN
Rule 85    stack_actuar -> ID DOT stack_funciones
Rule 86    stack_funciones -> stack_isEmpty
Rule 87    stack_funciones -> stack_push
Rule 88    stack_funciones -> stack_pop
Rule 89    stack_funciones -> stack_peek
Rule 90    stack_funciones -> stack_size
Rule 91    stack_isEmpty -> ISEMPTY LPAREN RPAREN
Rule 92    stack_pop -> POP LPAREN RPAREN
Rule 93    stack_push -> PUSH LPAREN ID RPAREN
Rule 94    stack_peek -> PEEK LPAREN RPAREN
Rule 95    stack_size -> SIZE LPAREN RPAREN
Rule 96    Lmetod -> FIRST LPAREN RPAREN
Rule 97    Lmetod -> LAST LPAREN RPAREN
Rule 98    Lmetod -> REMOVEL LPAREN RPAREN
Rule 99    while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
Rule 100   lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
Rule 101   lsimplem -> ID DOT Lmetod

Terminals, with rules where they appear

ABSTRACT             : 
ACTUAL               : 
ADD                  : 23
ANNOTATION           : 
APPEND               : 
ARRAYLIST            : 84
ARRAYOF              : 
ARROW                : 
AS                   : 
AS_SAFE              : 79
AT_NO_WS             : 
BOOLEAN              : 59
BREAK                : 
BY                   : 
CATCH                : 
CHAR                 : 58
CLASS                : 
COLONCOLON           : 
COMMA                : 
COMMENT              : 
COMPANION            : 
CONJ                 : 71
CONST                : 
CONSTRUCTOR          : 
CONTINUE             : 
CROSSINLINE          : 
DATA                 : 
DECR                 : 
DECREMENTIN          : 
DECREMENTONE         : 
DISJ                 : 72
DIVIDE               : 50
DIVIDEIN             : 
DO                   : 
DOT                  : 23 24 25 26 85 101
DOTS                 : 29 37 82 99 100
DOUBLE_ARROW         : 
DOUBLE_SEMICOLON     : 
DYNAMIC              : 
ELSE                 : 64
ENUM                 : 
EQEQ                 : 80
EQEQEQ               : 81
EQUAL                : 29 37 38 82 100
EXCL_EQ              : 77
EXCL_EQEQ            : 78
EXCL_NO_WS           : 
EXCL_WS              : 70
EXPECT               : 
EXTERNAL             : 
FIELD                : 
FILE                 : 
FINAL                : 
FINALLY              : 
FIRST                : 96
FLOAT                : 56
FOR                  : 30
FUN                  : 
GE                   : 76
GET                  : 
HASH                 : 
ID                   : 23 24 25 26 29 30 30 37 38 60 82 85 93 99 100 101
IF                   : 62 63
IMPORT               : 
IN                   : 30
INCR                 : 
INCREMENTIN          : 
INCREMENTONE         : 
INCREMENTTIMES       : 
INFIX                : 
INIT                 : 
INLINE               : 
INNER                : 
INT                  : 55
INTERFACE            : 
INTERNAL             : 
IS                   : 
ISEMPTY              : 91
LANGLE               : 29 29 73 83 100 100
LAST                 : 97
LATEINIT             : 
LCURL                : 30 62 63 64 99
LE                   : 75
LINEBREAK            : 
LINKEDL              : 29 100 100
LISTOF               : 
LONG                 : 57
LPAREN               : 23 24 25 26 27 28 29 30 54 62 63 84 91 92 93 94 95 96 97 98 99 100
LSQUARE              : 
MARK_1               : 
MARK_2               : 
MINUS                : 48
MOD                  : 51
MODIN                : 
NOINLINE             : 
OBJECT               : 100 100
OPEN                 : 
OPERATOR             : 
OUT                  : 
OVERRIDE             : 
PACKAGE              : 
PARAM                : 
PEEK                 : 24 94
PLUS                 : 47
POLL                 : 25
POP                  : 92
PRINT                : 27
PRINTLN              : 28
PRIVATE              : 
PROPERTY             : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 93
QUEST_WS             : 
QUEUE                : 29
RANGE                : 
RANGLE               : 29 29 74 83 100 100
RCURL                : 30 62 63 64 99
RECEIVER             : 
REIFIED              : 
REMOVE               : 26
REMOVEI              : 
REMOVEL              : 98
REMOVEN              : 
RETURN               : 
RPAREN               : 23 24 25 26 27 28 29 30 54 62 63 84 91 92 93 94 95 96 97 98 99 100
RSQUARE              : 
SEALED               : 
SEMICOLON            : 1 2 5
SET                  : 
SETPARAM             : 
SINGLE_QUOTE         : 
SIZE                 : 95
STACK                : 83
STRING_1             : 61
SUM                  : 
SUPER                : 
SUSPEND              : 
TAILREC              : 
TBOOLEAN             : 43
TCHAR                : 44
TDOUBLE              : 42
TEMPLATE             : 
TFLOAT               : 41
THIS                 : 
THROW                : 
TIMES                : 49
TINT                 : 39 99
TLONG                : 40
TRY                  : 
TSTRING              : 45
TYPEOF               : 
TYPE_ALIAS           : 
VAL                  : 29 36
VALUE                : 
VAL_TIPO_1           : 
VAR                  : 35
VARARG               : 
VAR_TIPO_1           : 
WHEN                 : 
WHERE                : 
WHILE                : 99
error                : 

Nonterminals, with rules where they appear

Lmetod               : 101
asignacion           : 2
asignacionSimple     : 33 34
condicion            : 6 62 63
condicionL           : 65
condicionN           : 67
condicionR           : 66
def_estruct_tipoDato : 12 82
else                 : 63
estructurasControl   : 4
estructurasDatos     : 5
expression           : 3 27 28 46 47 48 49 50 51 54
factor               : 23 53
for                  : 16
if                   : 17
impresion            : 1
instance_arraylist   : 11 82
keywordVariables     : 33 82 100
line                 : 31 32 64 0
lista                : 13
lsimplem             : 14
morelines            : 30 32 62 63 99
opL                  : 68
opR                  : 69 99
queue                : 7
queue_add            : 19
queue_operations     : 8
queue_peek           : 20
queue_poll           : 22
queue_remove         : 21
stack                : 9
stack_actuar         : 10
stack_funciones      : 85
stack_isEmpty        : 86
stack_peek           : 89
stack_pop            : 88
stack_push           : 87
stack_size           : 90
term                 : 47 48 49 50 51 52 68 68 69 69 70
tipoDato             : 29 29 37 83
valor                : 37 38
while                : 18

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    line                           shift and go to state 1
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    condicion                      shift and go to state 7
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 1

    (0) S' -> line .



state 2

    (1) line -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 48


state 3

    (2) line -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 49


state 4

    (3) line -> expression .
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term
    (49) expression -> expression . TIMES term
    (50) expression -> expression . DIVIDE term
    (51) expression -> expression . MOD term

    $end            reduce using rule 3 (line -> expression .)
    PRINT           reduce using rule 3 (line -> expression .)
    PRINTLN         reduce using rule 3 (line -> expression .)
    VAR             reduce using rule 3 (line -> expression .)
    VAL             reduce using rule 3 (line -> expression .)
    ID              reduce using rule 3 (line -> expression .)
    LPAREN          reduce using rule 3 (line -> expression .)
    FOR             reduce using rule 3 (line -> expression .)
    IF              reduce using rule 3 (line -> expression .)
    WHILE           reduce using rule 3 (line -> expression .)
    ARRAYLIST       reduce using rule 3 (line -> expression .)
    STACK           reduce using rule 3 (line -> expression .)
    EXCL_WS         reduce using rule 3 (line -> expression .)
    INT             reduce using rule 3 (line -> expression .)
    FLOAT           reduce using rule 3 (line -> expression .)
    LONG            reduce using rule 3 (line -> expression .)
    CHAR            reduce using rule 3 (line -> expression .)
    BOOLEAN         reduce using rule 3 (line -> expression .)
    STRING_1        reduce using rule 3 (line -> expression .)
    SEMICOLON       reduce using rule 3 (line -> expression .)
    RCURL           reduce using rule 3 (line -> expression .)
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MOD             shift and go to state 54


state 5

    (4) line -> estructurasControl .

    $end            reduce using rule 4 (line -> estructurasControl .)
    PRINT           reduce using rule 4 (line -> estructurasControl .)
    PRINTLN         reduce using rule 4 (line -> estructurasControl .)
    VAR             reduce using rule 4 (line -> estructurasControl .)
    VAL             reduce using rule 4 (line -> estructurasControl .)
    ID              reduce using rule 4 (line -> estructurasControl .)
    LPAREN          reduce using rule 4 (line -> estructurasControl .)
    FOR             reduce using rule 4 (line -> estructurasControl .)
    IF              reduce using rule 4 (line -> estructurasControl .)
    WHILE           reduce using rule 4 (line -> estructurasControl .)
    ARRAYLIST       reduce using rule 4 (line -> estructurasControl .)
    STACK           reduce using rule 4 (line -> estructurasControl .)
    EXCL_WS         reduce using rule 4 (line -> estructurasControl .)
    INT             reduce using rule 4 (line -> estructurasControl .)
    FLOAT           reduce using rule 4 (line -> estructurasControl .)
    LONG            reduce using rule 4 (line -> estructurasControl .)
    CHAR            reduce using rule 4 (line -> estructurasControl .)
    BOOLEAN         reduce using rule 4 (line -> estructurasControl .)
    STRING_1        reduce using rule 4 (line -> estructurasControl .)
    SEMICOLON       reduce using rule 4 (line -> estructurasControl .)
    RCURL           reduce using rule 4 (line -> estructurasControl .)


state 6

    (5) line -> estructurasDatos . SEMICOLON

    SEMICOLON       shift and go to state 55


state 7

    (6) line -> condicion .

    $end            reduce using rule 6 (line -> condicion .)
    PRINT           reduce using rule 6 (line -> condicion .)
    PRINTLN         reduce using rule 6 (line -> condicion .)
    VAR             reduce using rule 6 (line -> condicion .)
    VAL             reduce using rule 6 (line -> condicion .)
    ID              reduce using rule 6 (line -> condicion .)
    LPAREN          reduce using rule 6 (line -> condicion .)
    FOR             reduce using rule 6 (line -> condicion .)
    IF              reduce using rule 6 (line -> condicion .)
    WHILE           reduce using rule 6 (line -> condicion .)
    ARRAYLIST       reduce using rule 6 (line -> condicion .)
    STACK           reduce using rule 6 (line -> condicion .)
    EXCL_WS         reduce using rule 6 (line -> condicion .)
    INT             reduce using rule 6 (line -> condicion .)
    FLOAT           reduce using rule 6 (line -> condicion .)
    LONG            reduce using rule 6 (line -> condicion .)
    CHAR            reduce using rule 6 (line -> condicion .)
    BOOLEAN         reduce using rule 6 (line -> condicion .)
    STRING_1        reduce using rule 6 (line -> condicion .)
    SEMICOLON       reduce using rule 6 (line -> condicion .)
    RCURL           reduce using rule 6 (line -> condicion .)


state 8

    (27) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 56


state 9

    (54) term -> LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    expression                     shift and go to state 57
    term                           shift and go to state 58
    factor                         shift and go to state 31

state 10

    (28) impresion -> PRINTLN . LPAREN expression RPAREN

    LPAREN          shift and go to state 60


state 11

    (33) asignacion -> keywordVariables . asignacionSimple
    (82) stack -> keywordVariables . ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (100) lista -> keywordVariables . ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor

    ID              shift and go to state 62

    asignacionSimple               shift and go to state 61

state 12

    (34) asignacion -> asignacionSimple .

    SEMICOLON       reduce using rule 34 (asignacion -> asignacionSimple .)


state 13

    (52) expression -> term .
    (68) condicionL -> term . opL term
    (69) condicionR -> term . opR term
    (71) opL -> . CONJ
    (72) opL -> . DISJ
    (73) opR -> . LANGLE
    (74) opR -> . RANGLE
    (75) opR -> . LE
    (76) opR -> . GE
    (77) opR -> . EXCL_EQ
    (78) opR -> . EXCL_EQEQ
    (79) opR -> . AS_SAFE
    (80) opR -> . EQEQ
    (81) opR -> . EQEQEQ

    PLUS            reduce using rule 52 (expression -> term .)
    MINUS           reduce using rule 52 (expression -> term .)
    TIMES           reduce using rule 52 (expression -> term .)
    DIVIDE          reduce using rule 52 (expression -> term .)
    MOD             reduce using rule 52 (expression -> term .)
    $end            reduce using rule 52 (expression -> term .)
    PRINT           reduce using rule 52 (expression -> term .)
    PRINTLN         reduce using rule 52 (expression -> term .)
    VAR             reduce using rule 52 (expression -> term .)
    VAL             reduce using rule 52 (expression -> term .)
    ID              reduce using rule 52 (expression -> term .)
    LPAREN          reduce using rule 52 (expression -> term .)
    FOR             reduce using rule 52 (expression -> term .)
    IF              reduce using rule 52 (expression -> term .)
    WHILE           reduce using rule 52 (expression -> term .)
    ARRAYLIST       reduce using rule 52 (expression -> term .)
    STACK           reduce using rule 52 (expression -> term .)
    EXCL_WS         reduce using rule 52 (expression -> term .)
    INT             reduce using rule 52 (expression -> term .)
    FLOAT           reduce using rule 52 (expression -> term .)
    LONG            reduce using rule 52 (expression -> term .)
    CHAR            reduce using rule 52 (expression -> term .)
    BOOLEAN         reduce using rule 52 (expression -> term .)
    STRING_1        reduce using rule 52 (expression -> term .)
    SEMICOLON       reduce using rule 52 (expression -> term .)
    RCURL           reduce using rule 52 (expression -> term .)
    CONJ            shift and go to state 65
    DISJ            shift and go to state 66
    LANGLE          shift and go to state 67
    RANGLE          shift and go to state 68
    LE              shift and go to state 69
    GE              shift and go to state 70
    EXCL_EQ         shift and go to state 71
    EXCL_EQEQ       shift and go to state 72
    AS_SAFE         shift and go to state 73
    EQEQ            shift and go to state 74
    EQEQEQ          shift and go to state 75

    opL                            shift and go to state 63
    opR                            shift and go to state 64

state 14

    (16) estructurasControl -> for .

    $end            reduce using rule 16 (estructurasControl -> for .)
    PRINT           reduce using rule 16 (estructurasControl -> for .)
    PRINTLN         reduce using rule 16 (estructurasControl -> for .)
    VAR             reduce using rule 16 (estructurasControl -> for .)
    VAL             reduce using rule 16 (estructurasControl -> for .)
    ID              reduce using rule 16 (estructurasControl -> for .)
    LPAREN          reduce using rule 16 (estructurasControl -> for .)
    FOR             reduce using rule 16 (estructurasControl -> for .)
    IF              reduce using rule 16 (estructurasControl -> for .)
    WHILE           reduce using rule 16 (estructurasControl -> for .)
    ARRAYLIST       reduce using rule 16 (estructurasControl -> for .)
    STACK           reduce using rule 16 (estructurasControl -> for .)
    EXCL_WS         reduce using rule 16 (estructurasControl -> for .)
    INT             reduce using rule 16 (estructurasControl -> for .)
    FLOAT           reduce using rule 16 (estructurasControl -> for .)
    LONG            reduce using rule 16 (estructurasControl -> for .)
    CHAR            reduce using rule 16 (estructurasControl -> for .)
    BOOLEAN         reduce using rule 16 (estructurasControl -> for .)
    STRING_1        reduce using rule 16 (estructurasControl -> for .)
    SEMICOLON       reduce using rule 16 (estructurasControl -> for .)
    RCURL           reduce using rule 16 (estructurasControl -> for .)


state 15

    (17) estructurasControl -> if .

    $end            reduce using rule 17 (estructurasControl -> if .)
    PRINT           reduce using rule 17 (estructurasControl -> if .)
    PRINTLN         reduce using rule 17 (estructurasControl -> if .)
    VAR             reduce using rule 17 (estructurasControl -> if .)
    VAL             reduce using rule 17 (estructurasControl -> if .)
    ID              reduce using rule 17 (estructurasControl -> if .)
    LPAREN          reduce using rule 17 (estructurasControl -> if .)
    FOR             reduce using rule 17 (estructurasControl -> if .)
    IF              reduce using rule 17 (estructurasControl -> if .)
    WHILE           reduce using rule 17 (estructurasControl -> if .)
    ARRAYLIST       reduce using rule 17 (estructurasControl -> if .)
    STACK           reduce using rule 17 (estructurasControl -> if .)
    EXCL_WS         reduce using rule 17 (estructurasControl -> if .)
    INT             reduce using rule 17 (estructurasControl -> if .)
    FLOAT           reduce using rule 17 (estructurasControl -> if .)
    LONG            reduce using rule 17 (estructurasControl -> if .)
    CHAR            reduce using rule 17 (estructurasControl -> if .)
    BOOLEAN         reduce using rule 17 (estructurasControl -> if .)
    STRING_1        reduce using rule 17 (estructurasControl -> if .)
    SEMICOLON       reduce using rule 17 (estructurasControl -> if .)
    RCURL           reduce using rule 17 (estructurasControl -> if .)


state 16

    (18) estructurasControl -> while .

    $end            reduce using rule 18 (estructurasControl -> while .)
    PRINT           reduce using rule 18 (estructurasControl -> while .)
    PRINTLN         reduce using rule 18 (estructurasControl -> while .)
    VAR             reduce using rule 18 (estructurasControl -> while .)
    VAL             reduce using rule 18 (estructurasControl -> while .)
    ID              reduce using rule 18 (estructurasControl -> while .)
    LPAREN          reduce using rule 18 (estructurasControl -> while .)
    FOR             reduce using rule 18 (estructurasControl -> while .)
    IF              reduce using rule 18 (estructurasControl -> while .)
    WHILE           reduce using rule 18 (estructurasControl -> while .)
    ARRAYLIST       reduce using rule 18 (estructurasControl -> while .)
    STACK           reduce using rule 18 (estructurasControl -> while .)
    EXCL_WS         reduce using rule 18 (estructurasControl -> while .)
    INT             reduce using rule 18 (estructurasControl -> while .)
    FLOAT           reduce using rule 18 (estructurasControl -> while .)
    LONG            reduce using rule 18 (estructurasControl -> while .)
    CHAR            reduce using rule 18 (estructurasControl -> while .)
    BOOLEAN         reduce using rule 18 (estructurasControl -> while .)
    STRING_1        reduce using rule 18 (estructurasControl -> while .)
    SEMICOLON       reduce using rule 18 (estructurasControl -> while .)
    RCURL           reduce using rule 18 (estructurasControl -> while .)


state 17

    (7) estructurasDatos -> queue .

    SEMICOLON       reduce using rule 7 (estructurasDatos -> queue .)


state 18

    (8) estructurasDatos -> queue_operations .

    SEMICOLON       reduce using rule 8 (estructurasDatos -> queue_operations .)


state 19

    (9) estructurasDatos -> stack .

    SEMICOLON       reduce using rule 9 (estructurasDatos -> stack .)


state 20

    (10) estructurasDatos -> stack_actuar .

    SEMICOLON       reduce using rule 10 (estructurasDatos -> stack_actuar .)


state 21

    (11) estructurasDatos -> instance_arraylist .

    SEMICOLON       reduce using rule 11 (estructurasDatos -> instance_arraylist .)


state 22

    (12) estructurasDatos -> def_estruct_tipoDato .

    SEMICOLON       reduce using rule 12 (estructurasDatos -> def_estruct_tipoDato .)


state 23

    (13) estructurasDatos -> lista .

    SEMICOLON       reduce using rule 13 (estructurasDatos -> lista .)


state 24

    (14) estructurasDatos -> lsimplem .

    SEMICOLON       reduce using rule 14 (estructurasDatos -> lsimplem .)


state 25

    (65) condicion -> condicionL .

    $end            reduce using rule 65 (condicion -> condicionL .)
    RPAREN          reduce using rule 65 (condicion -> condicionL .)
    PRINT           reduce using rule 65 (condicion -> condicionL .)
    PRINTLN         reduce using rule 65 (condicion -> condicionL .)
    VAR             reduce using rule 65 (condicion -> condicionL .)
    VAL             reduce using rule 65 (condicion -> condicionL .)
    ID              reduce using rule 65 (condicion -> condicionL .)
    LPAREN          reduce using rule 65 (condicion -> condicionL .)
    FOR             reduce using rule 65 (condicion -> condicionL .)
    IF              reduce using rule 65 (condicion -> condicionL .)
    WHILE           reduce using rule 65 (condicion -> condicionL .)
    ARRAYLIST       reduce using rule 65 (condicion -> condicionL .)
    STACK           reduce using rule 65 (condicion -> condicionL .)
    EXCL_WS         reduce using rule 65 (condicion -> condicionL .)
    INT             reduce using rule 65 (condicion -> condicionL .)
    FLOAT           reduce using rule 65 (condicion -> condicionL .)
    LONG            reduce using rule 65 (condicion -> condicionL .)
    CHAR            reduce using rule 65 (condicion -> condicionL .)
    BOOLEAN         reduce using rule 65 (condicion -> condicionL .)
    STRING_1        reduce using rule 65 (condicion -> condicionL .)
    SEMICOLON       reduce using rule 65 (condicion -> condicionL .)
    RCURL           reduce using rule 65 (condicion -> condicionL .)


state 26

    (66) condicion -> condicionR .

    $end            reduce using rule 66 (condicion -> condicionR .)
    RPAREN          reduce using rule 66 (condicion -> condicionR .)
    PRINT           reduce using rule 66 (condicion -> condicionR .)
    PRINTLN         reduce using rule 66 (condicion -> condicionR .)
    VAR             reduce using rule 66 (condicion -> condicionR .)
    VAL             reduce using rule 66 (condicion -> condicionR .)
    ID              reduce using rule 66 (condicion -> condicionR .)
    LPAREN          reduce using rule 66 (condicion -> condicionR .)
    FOR             reduce using rule 66 (condicion -> condicionR .)
    IF              reduce using rule 66 (condicion -> condicionR .)
    WHILE           reduce using rule 66 (condicion -> condicionR .)
    ARRAYLIST       reduce using rule 66 (condicion -> condicionR .)
    STACK           reduce using rule 66 (condicion -> condicionR .)
    EXCL_WS         reduce using rule 66 (condicion -> condicionR .)
    INT             reduce using rule 66 (condicion -> condicionR .)
    FLOAT           reduce using rule 66 (condicion -> condicionR .)
    LONG            reduce using rule 66 (condicion -> condicionR .)
    CHAR            reduce using rule 66 (condicion -> condicionR .)
    BOOLEAN         reduce using rule 66 (condicion -> condicionR .)
    STRING_1        reduce using rule 66 (condicion -> condicionR .)
    SEMICOLON       reduce using rule 66 (condicion -> condicionR .)
    RCURL           reduce using rule 66 (condicion -> condicionR .)


state 27

    (67) condicion -> condicionN .

    $end            reduce using rule 67 (condicion -> condicionN .)
    RPAREN          reduce using rule 67 (condicion -> condicionN .)
    PRINT           reduce using rule 67 (condicion -> condicionN .)
    PRINTLN         reduce using rule 67 (condicion -> condicionN .)
    VAR             reduce using rule 67 (condicion -> condicionN .)
    VAL             reduce using rule 67 (condicion -> condicionN .)
    ID              reduce using rule 67 (condicion -> condicionN .)
    LPAREN          reduce using rule 67 (condicion -> condicionN .)
    FOR             reduce using rule 67 (condicion -> condicionN .)
    IF              reduce using rule 67 (condicion -> condicionN .)
    WHILE           reduce using rule 67 (condicion -> condicionN .)
    ARRAYLIST       reduce using rule 67 (condicion -> condicionN .)
    STACK           reduce using rule 67 (condicion -> condicionN .)
    EXCL_WS         reduce using rule 67 (condicion -> condicionN .)
    INT             reduce using rule 67 (condicion -> condicionN .)
    FLOAT           reduce using rule 67 (condicion -> condicionN .)
    LONG            reduce using rule 67 (condicion -> condicionN .)
    CHAR            reduce using rule 67 (condicion -> condicionN .)
    BOOLEAN         reduce using rule 67 (condicion -> condicionN .)
    STRING_1        reduce using rule 67 (condicion -> condicionN .)
    SEMICOLON       reduce using rule 67 (condicion -> condicionN .)
    RCURL           reduce using rule 67 (condicion -> condicionN .)


state 28

    (35) keywordVariables -> VAR .

    ID              reduce using rule 35 (keywordVariables -> VAR .)


state 29

    (36) keywordVariables -> VAL .
    (29) queue -> VAL . ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 76

  ! ID              [ reduce using rule 36 (keywordVariables -> VAL .) ]


state 30

    (37) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> ID . EQUAL valor
    (85) stack_actuar -> ID . DOT stack_funciones
    (101) lsimplem -> ID . DOT Lmetod
    (60) factor -> ID .
    (23) queue_add -> ID . DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> ID . DOT PEEK LPAREN RPAREN
    (26) queue_remove -> ID . DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> ID . DOT POLL LPAREN RPAREN

    DOTS            shift and go to state 77
    EQUAL           shift and go to state 78
    DOT             shift and go to state 79
    CONJ            reduce using rule 60 (factor -> ID .)
    DISJ            reduce using rule 60 (factor -> ID .)
    LANGLE          reduce using rule 60 (factor -> ID .)
    RANGLE          reduce using rule 60 (factor -> ID .)
    LE              reduce using rule 60 (factor -> ID .)
    GE              reduce using rule 60 (factor -> ID .)
    EXCL_EQ         reduce using rule 60 (factor -> ID .)
    EXCL_EQEQ       reduce using rule 60 (factor -> ID .)
    AS_SAFE         reduce using rule 60 (factor -> ID .)
    EQEQ            reduce using rule 60 (factor -> ID .)
    EQEQEQ          reduce using rule 60 (factor -> ID .)
    PLUS            reduce using rule 60 (factor -> ID .)
    MINUS           reduce using rule 60 (factor -> ID .)
    TIMES           reduce using rule 60 (factor -> ID .)
    DIVIDE          reduce using rule 60 (factor -> ID .)
    MOD             reduce using rule 60 (factor -> ID .)
    $end            reduce using rule 60 (factor -> ID .)
    PRINT           reduce using rule 60 (factor -> ID .)
    PRINTLN         reduce using rule 60 (factor -> ID .)
    VAR             reduce using rule 60 (factor -> ID .)
    VAL             reduce using rule 60 (factor -> ID .)
    ID              reduce using rule 60 (factor -> ID .)
    LPAREN          reduce using rule 60 (factor -> ID .)
    FOR             reduce using rule 60 (factor -> ID .)
    IF              reduce using rule 60 (factor -> ID .)
    WHILE           reduce using rule 60 (factor -> ID .)
    ARRAYLIST       reduce using rule 60 (factor -> ID .)
    STACK           reduce using rule 60 (factor -> ID .)
    EXCL_WS         reduce using rule 60 (factor -> ID .)
    INT             reduce using rule 60 (factor -> ID .)
    FLOAT           reduce using rule 60 (factor -> ID .)
    LONG            reduce using rule 60 (factor -> ID .)
    CHAR            reduce using rule 60 (factor -> ID .)
    BOOLEAN         reduce using rule 60 (factor -> ID .)
    STRING_1        reduce using rule 60 (factor -> ID .)
    SEMICOLON       reduce using rule 60 (factor -> ID .)
    RCURL           reduce using rule 60 (factor -> ID .)


state 31

    (53) term -> factor .

    CONJ            reduce using rule 53 (term -> factor .)
    DISJ            reduce using rule 53 (term -> factor .)
    LANGLE          reduce using rule 53 (term -> factor .)
    RANGLE          reduce using rule 53 (term -> factor .)
    LE              reduce using rule 53 (term -> factor .)
    GE              reduce using rule 53 (term -> factor .)
    EXCL_EQ         reduce using rule 53 (term -> factor .)
    EXCL_EQEQ       reduce using rule 53 (term -> factor .)
    AS_SAFE         reduce using rule 53 (term -> factor .)
    EQEQ            reduce using rule 53 (term -> factor .)
    EQEQEQ          reduce using rule 53 (term -> factor .)
    PLUS            reduce using rule 53 (term -> factor .)
    MINUS           reduce using rule 53 (term -> factor .)
    TIMES           reduce using rule 53 (term -> factor .)
    DIVIDE          reduce using rule 53 (term -> factor .)
    MOD             reduce using rule 53 (term -> factor .)
    $end            reduce using rule 53 (term -> factor .)
    RPAREN          reduce using rule 53 (term -> factor .)
    PRINT           reduce using rule 53 (term -> factor .)
    PRINTLN         reduce using rule 53 (term -> factor .)
    VAR             reduce using rule 53 (term -> factor .)
    VAL             reduce using rule 53 (term -> factor .)
    ID              reduce using rule 53 (term -> factor .)
    LPAREN          reduce using rule 53 (term -> factor .)
    FOR             reduce using rule 53 (term -> factor .)
    IF              reduce using rule 53 (term -> factor .)
    WHILE           reduce using rule 53 (term -> factor .)
    ARRAYLIST       reduce using rule 53 (term -> factor .)
    STACK           reduce using rule 53 (term -> factor .)
    EXCL_WS         reduce using rule 53 (term -> factor .)
    INT             reduce using rule 53 (term -> factor .)
    FLOAT           reduce using rule 53 (term -> factor .)
    LONG            reduce using rule 53 (term -> factor .)
    CHAR            reduce using rule 53 (term -> factor .)
    BOOLEAN         reduce using rule 53 (term -> factor .)
    STRING_1        reduce using rule 53 (term -> factor .)
    SEMICOLON       reduce using rule 53 (term -> factor .)
    RCURL           reduce using rule 53 (term -> factor .)


state 32

    (30) for -> FOR . LPAREN ID IN ID RPAREN LCURL morelines RCURL

    LPAREN          shift and go to state 80


state 33

    (62) if -> IF . LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> IF . LPAREN condicion RPAREN LCURL morelines RCURL else

    LPAREN          shift and go to state 81


state 34

    (99) while -> WHILE . DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL

    DOTS            shift and go to state 82


state 35

    (19) queue_operations -> queue_add .

    SEMICOLON       reduce using rule 19 (queue_operations -> queue_add .)


state 36

    (20) queue_operations -> queue_peek .

    SEMICOLON       reduce using rule 20 (queue_operations -> queue_peek .)


state 37

    (21) queue_operations -> queue_remove .

    SEMICOLON       reduce using rule 21 (queue_operations -> queue_remove .)


state 38

    (22) queue_operations -> queue_poll .

    SEMICOLON       reduce using rule 22 (queue_operations -> queue_poll .)


state 39

    (84) instance_arraylist -> ARRAYLIST . LPAREN RPAREN

    LPAREN          shift and go to state 83


state 40

    (83) def_estruct_tipoDato -> STACK . LANGLE tipoDato RANGLE

    LANGLE          shift and go to state 84


state 41

    (70) condicionN -> EXCL_WS . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 85
    factor                         shift and go to state 31

state 42

    (55) factor -> INT .

    CONJ            reduce using rule 55 (factor -> INT .)
    DISJ            reduce using rule 55 (factor -> INT .)
    LANGLE          reduce using rule 55 (factor -> INT .)
    RANGLE          reduce using rule 55 (factor -> INT .)
    LE              reduce using rule 55 (factor -> INT .)
    GE              reduce using rule 55 (factor -> INT .)
    EXCL_EQ         reduce using rule 55 (factor -> INT .)
    EXCL_EQEQ       reduce using rule 55 (factor -> INT .)
    AS_SAFE         reduce using rule 55 (factor -> INT .)
    EQEQ            reduce using rule 55 (factor -> INT .)
    EQEQEQ          reduce using rule 55 (factor -> INT .)
    PLUS            reduce using rule 55 (factor -> INT .)
    MINUS           reduce using rule 55 (factor -> INT .)
    TIMES           reduce using rule 55 (factor -> INT .)
    DIVIDE          reduce using rule 55 (factor -> INT .)
    MOD             reduce using rule 55 (factor -> INT .)
    $end            reduce using rule 55 (factor -> INT .)
    RPAREN          reduce using rule 55 (factor -> INT .)
    PRINT           reduce using rule 55 (factor -> INT .)
    PRINTLN         reduce using rule 55 (factor -> INT .)
    VAR             reduce using rule 55 (factor -> INT .)
    VAL             reduce using rule 55 (factor -> INT .)
    ID              reduce using rule 55 (factor -> INT .)
    LPAREN          reduce using rule 55 (factor -> INT .)
    FOR             reduce using rule 55 (factor -> INT .)
    IF              reduce using rule 55 (factor -> INT .)
    WHILE           reduce using rule 55 (factor -> INT .)
    ARRAYLIST       reduce using rule 55 (factor -> INT .)
    STACK           reduce using rule 55 (factor -> INT .)
    EXCL_WS         reduce using rule 55 (factor -> INT .)
    INT             reduce using rule 55 (factor -> INT .)
    FLOAT           reduce using rule 55 (factor -> INT .)
    LONG            reduce using rule 55 (factor -> INT .)
    CHAR            reduce using rule 55 (factor -> INT .)
    BOOLEAN         reduce using rule 55 (factor -> INT .)
    STRING_1        reduce using rule 55 (factor -> INT .)
    SEMICOLON       reduce using rule 55 (factor -> INT .)
    RCURL           reduce using rule 55 (factor -> INT .)


state 43

    (56) factor -> FLOAT .

    CONJ            reduce using rule 56 (factor -> FLOAT .)
    DISJ            reduce using rule 56 (factor -> FLOAT .)
    LANGLE          reduce using rule 56 (factor -> FLOAT .)
    RANGLE          reduce using rule 56 (factor -> FLOAT .)
    LE              reduce using rule 56 (factor -> FLOAT .)
    GE              reduce using rule 56 (factor -> FLOAT .)
    EXCL_EQ         reduce using rule 56 (factor -> FLOAT .)
    EXCL_EQEQ       reduce using rule 56 (factor -> FLOAT .)
    AS_SAFE         reduce using rule 56 (factor -> FLOAT .)
    EQEQ            reduce using rule 56 (factor -> FLOAT .)
    EQEQEQ          reduce using rule 56 (factor -> FLOAT .)
    PLUS            reduce using rule 56 (factor -> FLOAT .)
    MINUS           reduce using rule 56 (factor -> FLOAT .)
    TIMES           reduce using rule 56 (factor -> FLOAT .)
    DIVIDE          reduce using rule 56 (factor -> FLOAT .)
    MOD             reduce using rule 56 (factor -> FLOAT .)
    $end            reduce using rule 56 (factor -> FLOAT .)
    RPAREN          reduce using rule 56 (factor -> FLOAT .)
    PRINT           reduce using rule 56 (factor -> FLOAT .)
    PRINTLN         reduce using rule 56 (factor -> FLOAT .)
    VAR             reduce using rule 56 (factor -> FLOAT .)
    VAL             reduce using rule 56 (factor -> FLOAT .)
    ID              reduce using rule 56 (factor -> FLOAT .)
    LPAREN          reduce using rule 56 (factor -> FLOAT .)
    FOR             reduce using rule 56 (factor -> FLOAT .)
    IF              reduce using rule 56 (factor -> FLOAT .)
    WHILE           reduce using rule 56 (factor -> FLOAT .)
    ARRAYLIST       reduce using rule 56 (factor -> FLOAT .)
    STACK           reduce using rule 56 (factor -> FLOAT .)
    EXCL_WS         reduce using rule 56 (factor -> FLOAT .)
    INT             reduce using rule 56 (factor -> FLOAT .)
    FLOAT           reduce using rule 56 (factor -> FLOAT .)
    LONG            reduce using rule 56 (factor -> FLOAT .)
    CHAR            reduce using rule 56 (factor -> FLOAT .)
    BOOLEAN         reduce using rule 56 (factor -> FLOAT .)
    STRING_1        reduce using rule 56 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 56 (factor -> FLOAT .)
    RCURL           reduce using rule 56 (factor -> FLOAT .)


state 44

    (57) factor -> LONG .

    CONJ            reduce using rule 57 (factor -> LONG .)
    DISJ            reduce using rule 57 (factor -> LONG .)
    LANGLE          reduce using rule 57 (factor -> LONG .)
    RANGLE          reduce using rule 57 (factor -> LONG .)
    LE              reduce using rule 57 (factor -> LONG .)
    GE              reduce using rule 57 (factor -> LONG .)
    EXCL_EQ         reduce using rule 57 (factor -> LONG .)
    EXCL_EQEQ       reduce using rule 57 (factor -> LONG .)
    AS_SAFE         reduce using rule 57 (factor -> LONG .)
    EQEQ            reduce using rule 57 (factor -> LONG .)
    EQEQEQ          reduce using rule 57 (factor -> LONG .)
    PLUS            reduce using rule 57 (factor -> LONG .)
    MINUS           reduce using rule 57 (factor -> LONG .)
    TIMES           reduce using rule 57 (factor -> LONG .)
    DIVIDE          reduce using rule 57 (factor -> LONG .)
    MOD             reduce using rule 57 (factor -> LONG .)
    $end            reduce using rule 57 (factor -> LONG .)
    RPAREN          reduce using rule 57 (factor -> LONG .)
    PRINT           reduce using rule 57 (factor -> LONG .)
    PRINTLN         reduce using rule 57 (factor -> LONG .)
    VAR             reduce using rule 57 (factor -> LONG .)
    VAL             reduce using rule 57 (factor -> LONG .)
    ID              reduce using rule 57 (factor -> LONG .)
    LPAREN          reduce using rule 57 (factor -> LONG .)
    FOR             reduce using rule 57 (factor -> LONG .)
    IF              reduce using rule 57 (factor -> LONG .)
    WHILE           reduce using rule 57 (factor -> LONG .)
    ARRAYLIST       reduce using rule 57 (factor -> LONG .)
    STACK           reduce using rule 57 (factor -> LONG .)
    EXCL_WS         reduce using rule 57 (factor -> LONG .)
    INT             reduce using rule 57 (factor -> LONG .)
    FLOAT           reduce using rule 57 (factor -> LONG .)
    LONG            reduce using rule 57 (factor -> LONG .)
    CHAR            reduce using rule 57 (factor -> LONG .)
    BOOLEAN         reduce using rule 57 (factor -> LONG .)
    STRING_1        reduce using rule 57 (factor -> LONG .)
    SEMICOLON       reduce using rule 57 (factor -> LONG .)
    RCURL           reduce using rule 57 (factor -> LONG .)


state 45

    (58) factor -> CHAR .

    CONJ            reduce using rule 58 (factor -> CHAR .)
    DISJ            reduce using rule 58 (factor -> CHAR .)
    LANGLE          reduce using rule 58 (factor -> CHAR .)
    RANGLE          reduce using rule 58 (factor -> CHAR .)
    LE              reduce using rule 58 (factor -> CHAR .)
    GE              reduce using rule 58 (factor -> CHAR .)
    EXCL_EQ         reduce using rule 58 (factor -> CHAR .)
    EXCL_EQEQ       reduce using rule 58 (factor -> CHAR .)
    AS_SAFE         reduce using rule 58 (factor -> CHAR .)
    EQEQ            reduce using rule 58 (factor -> CHAR .)
    EQEQEQ          reduce using rule 58 (factor -> CHAR .)
    PLUS            reduce using rule 58 (factor -> CHAR .)
    MINUS           reduce using rule 58 (factor -> CHAR .)
    TIMES           reduce using rule 58 (factor -> CHAR .)
    DIVIDE          reduce using rule 58 (factor -> CHAR .)
    MOD             reduce using rule 58 (factor -> CHAR .)
    $end            reduce using rule 58 (factor -> CHAR .)
    RPAREN          reduce using rule 58 (factor -> CHAR .)
    PRINT           reduce using rule 58 (factor -> CHAR .)
    PRINTLN         reduce using rule 58 (factor -> CHAR .)
    VAR             reduce using rule 58 (factor -> CHAR .)
    VAL             reduce using rule 58 (factor -> CHAR .)
    ID              reduce using rule 58 (factor -> CHAR .)
    LPAREN          reduce using rule 58 (factor -> CHAR .)
    FOR             reduce using rule 58 (factor -> CHAR .)
    IF              reduce using rule 58 (factor -> CHAR .)
    WHILE           reduce using rule 58 (factor -> CHAR .)
    ARRAYLIST       reduce using rule 58 (factor -> CHAR .)
    STACK           reduce using rule 58 (factor -> CHAR .)
    EXCL_WS         reduce using rule 58 (factor -> CHAR .)
    INT             reduce using rule 58 (factor -> CHAR .)
    FLOAT           reduce using rule 58 (factor -> CHAR .)
    LONG            reduce using rule 58 (factor -> CHAR .)
    CHAR            reduce using rule 58 (factor -> CHAR .)
    BOOLEAN         reduce using rule 58 (factor -> CHAR .)
    STRING_1        reduce using rule 58 (factor -> CHAR .)
    SEMICOLON       reduce using rule 58 (factor -> CHAR .)
    RCURL           reduce using rule 58 (factor -> CHAR .)


state 46

    (59) factor -> BOOLEAN .

    CONJ            reduce using rule 59 (factor -> BOOLEAN .)
    DISJ            reduce using rule 59 (factor -> BOOLEAN .)
    LANGLE          reduce using rule 59 (factor -> BOOLEAN .)
    RANGLE          reduce using rule 59 (factor -> BOOLEAN .)
    LE              reduce using rule 59 (factor -> BOOLEAN .)
    GE              reduce using rule 59 (factor -> BOOLEAN .)
    EXCL_EQ         reduce using rule 59 (factor -> BOOLEAN .)
    EXCL_EQEQ       reduce using rule 59 (factor -> BOOLEAN .)
    AS_SAFE         reduce using rule 59 (factor -> BOOLEAN .)
    EQEQ            reduce using rule 59 (factor -> BOOLEAN .)
    EQEQEQ          reduce using rule 59 (factor -> BOOLEAN .)
    PLUS            reduce using rule 59 (factor -> BOOLEAN .)
    MINUS           reduce using rule 59 (factor -> BOOLEAN .)
    TIMES           reduce using rule 59 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 59 (factor -> BOOLEAN .)
    MOD             reduce using rule 59 (factor -> BOOLEAN .)
    $end            reduce using rule 59 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 59 (factor -> BOOLEAN .)
    PRINT           reduce using rule 59 (factor -> BOOLEAN .)
    PRINTLN         reduce using rule 59 (factor -> BOOLEAN .)
    VAR             reduce using rule 59 (factor -> BOOLEAN .)
    VAL             reduce using rule 59 (factor -> BOOLEAN .)
    ID              reduce using rule 59 (factor -> BOOLEAN .)
    LPAREN          reduce using rule 59 (factor -> BOOLEAN .)
    FOR             reduce using rule 59 (factor -> BOOLEAN .)
    IF              reduce using rule 59 (factor -> BOOLEAN .)
    WHILE           reduce using rule 59 (factor -> BOOLEAN .)
    ARRAYLIST       reduce using rule 59 (factor -> BOOLEAN .)
    STACK           reduce using rule 59 (factor -> BOOLEAN .)
    EXCL_WS         reduce using rule 59 (factor -> BOOLEAN .)
    INT             reduce using rule 59 (factor -> BOOLEAN .)
    FLOAT           reduce using rule 59 (factor -> BOOLEAN .)
    LONG            reduce using rule 59 (factor -> BOOLEAN .)
    CHAR            reduce using rule 59 (factor -> BOOLEAN .)
    BOOLEAN         reduce using rule 59 (factor -> BOOLEAN .)
    STRING_1        reduce using rule 59 (factor -> BOOLEAN .)
    SEMICOLON       reduce using rule 59 (factor -> BOOLEAN .)
    RCURL           reduce using rule 59 (factor -> BOOLEAN .)


state 47

    (61) factor -> STRING_1 .

    CONJ            reduce using rule 61 (factor -> STRING_1 .)
    DISJ            reduce using rule 61 (factor -> STRING_1 .)
    LANGLE          reduce using rule 61 (factor -> STRING_1 .)
    RANGLE          reduce using rule 61 (factor -> STRING_1 .)
    LE              reduce using rule 61 (factor -> STRING_1 .)
    GE              reduce using rule 61 (factor -> STRING_1 .)
    EXCL_EQ         reduce using rule 61 (factor -> STRING_1 .)
    EXCL_EQEQ       reduce using rule 61 (factor -> STRING_1 .)
    AS_SAFE         reduce using rule 61 (factor -> STRING_1 .)
    EQEQ            reduce using rule 61 (factor -> STRING_1 .)
    EQEQEQ          reduce using rule 61 (factor -> STRING_1 .)
    PLUS            reduce using rule 61 (factor -> STRING_1 .)
    MINUS           reduce using rule 61 (factor -> STRING_1 .)
    TIMES           reduce using rule 61 (factor -> STRING_1 .)
    DIVIDE          reduce using rule 61 (factor -> STRING_1 .)
    MOD             reduce using rule 61 (factor -> STRING_1 .)
    $end            reduce using rule 61 (factor -> STRING_1 .)
    RPAREN          reduce using rule 61 (factor -> STRING_1 .)
    PRINT           reduce using rule 61 (factor -> STRING_1 .)
    PRINTLN         reduce using rule 61 (factor -> STRING_1 .)
    VAR             reduce using rule 61 (factor -> STRING_1 .)
    VAL             reduce using rule 61 (factor -> STRING_1 .)
    ID              reduce using rule 61 (factor -> STRING_1 .)
    LPAREN          reduce using rule 61 (factor -> STRING_1 .)
    FOR             reduce using rule 61 (factor -> STRING_1 .)
    IF              reduce using rule 61 (factor -> STRING_1 .)
    WHILE           reduce using rule 61 (factor -> STRING_1 .)
    ARRAYLIST       reduce using rule 61 (factor -> STRING_1 .)
    STACK           reduce using rule 61 (factor -> STRING_1 .)
    EXCL_WS         reduce using rule 61 (factor -> STRING_1 .)
    INT             reduce using rule 61 (factor -> STRING_1 .)
    FLOAT           reduce using rule 61 (factor -> STRING_1 .)
    LONG            reduce using rule 61 (factor -> STRING_1 .)
    CHAR            reduce using rule 61 (factor -> STRING_1 .)
    BOOLEAN         reduce using rule 61 (factor -> STRING_1 .)
    STRING_1        reduce using rule 61 (factor -> STRING_1 .)
    SEMICOLON       reduce using rule 61 (factor -> STRING_1 .)
    RCURL           reduce using rule 61 (factor -> STRING_1 .)


state 48

    (1) line -> impresion SEMICOLON .

    $end            reduce using rule 1 (line -> impresion SEMICOLON .)
    PRINT           reduce using rule 1 (line -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 1 (line -> impresion SEMICOLON .)
    VAR             reduce using rule 1 (line -> impresion SEMICOLON .)
    VAL             reduce using rule 1 (line -> impresion SEMICOLON .)
    ID              reduce using rule 1 (line -> impresion SEMICOLON .)
    LPAREN          reduce using rule 1 (line -> impresion SEMICOLON .)
    FOR             reduce using rule 1 (line -> impresion SEMICOLON .)
    IF              reduce using rule 1 (line -> impresion SEMICOLON .)
    WHILE           reduce using rule 1 (line -> impresion SEMICOLON .)
    ARRAYLIST       reduce using rule 1 (line -> impresion SEMICOLON .)
    STACK           reduce using rule 1 (line -> impresion SEMICOLON .)
    EXCL_WS         reduce using rule 1 (line -> impresion SEMICOLON .)
    INT             reduce using rule 1 (line -> impresion SEMICOLON .)
    FLOAT           reduce using rule 1 (line -> impresion SEMICOLON .)
    LONG            reduce using rule 1 (line -> impresion SEMICOLON .)
    CHAR            reduce using rule 1 (line -> impresion SEMICOLON .)
    BOOLEAN         reduce using rule 1 (line -> impresion SEMICOLON .)
    STRING_1        reduce using rule 1 (line -> impresion SEMICOLON .)
    SEMICOLON       reduce using rule 1 (line -> impresion SEMICOLON .)
    RCURL           reduce using rule 1 (line -> impresion SEMICOLON .)


state 49

    (2) line -> asignacion SEMICOLON .

    $end            reduce using rule 2 (line -> asignacion SEMICOLON .)
    PRINT           reduce using rule 2 (line -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 2 (line -> asignacion SEMICOLON .)
    VAR             reduce using rule 2 (line -> asignacion SEMICOLON .)
    VAL             reduce using rule 2 (line -> asignacion SEMICOLON .)
    ID              reduce using rule 2 (line -> asignacion SEMICOLON .)
    LPAREN          reduce using rule 2 (line -> asignacion SEMICOLON .)
    FOR             reduce using rule 2 (line -> asignacion SEMICOLON .)
    IF              reduce using rule 2 (line -> asignacion SEMICOLON .)
    WHILE           reduce using rule 2 (line -> asignacion SEMICOLON .)
    ARRAYLIST       reduce using rule 2 (line -> asignacion SEMICOLON .)
    STACK           reduce using rule 2 (line -> asignacion SEMICOLON .)
    EXCL_WS         reduce using rule 2 (line -> asignacion SEMICOLON .)
    INT             reduce using rule 2 (line -> asignacion SEMICOLON .)
    FLOAT           reduce using rule 2 (line -> asignacion SEMICOLON .)
    LONG            reduce using rule 2 (line -> asignacion SEMICOLON .)
    CHAR            reduce using rule 2 (line -> asignacion SEMICOLON .)
    BOOLEAN         reduce using rule 2 (line -> asignacion SEMICOLON .)
    STRING_1        reduce using rule 2 (line -> asignacion SEMICOLON .)
    SEMICOLON       reduce using rule 2 (line -> asignacion SEMICOLON .)
    RCURL           reduce using rule 2 (line -> asignacion SEMICOLON .)


state 50

    (47) expression -> expression PLUS . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 86
    factor                         shift and go to state 31

state 51

    (48) expression -> expression MINUS . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 87
    factor                         shift and go to state 31

state 52

    (49) expression -> expression TIMES . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 88
    factor                         shift and go to state 31

state 53

    (50) expression -> expression DIVIDE . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 89
    factor                         shift and go to state 31

state 54

    (51) expression -> expression MOD . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 90
    factor                         shift and go to state 31

state 55

    (5) line -> estructurasDatos SEMICOLON .

    $end            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    PRINT           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    PRINTLN         reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    VAR             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    VAL             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    ID              reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    LPAREN          reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    FOR             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    IF              reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    WHILE           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    ARRAYLIST       reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    STACK           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    EXCL_WS         reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    INT             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    FLOAT           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    LONG            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    CHAR            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    BOOLEAN         reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    STRING_1        reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    SEMICOLON       reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    RCURL           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)


state 56

    (27) impresion -> PRINT LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    expression                     shift and go to state 91
    term                           shift and go to state 58
    factor                         shift and go to state 31

state 57

    (54) term -> LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term
    (49) expression -> expression . TIMES term
    (50) expression -> expression . DIVIDE term
    (51) expression -> expression . MOD term

    RPAREN          shift and go to state 92
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MOD             shift and go to state 54


state 58

    (52) expression -> term .

    RPAREN          reduce using rule 52 (expression -> term .)
    PLUS            reduce using rule 52 (expression -> term .)
    MINUS           reduce using rule 52 (expression -> term .)
    TIMES           reduce using rule 52 (expression -> term .)
    DIVIDE          reduce using rule 52 (expression -> term .)
    MOD             reduce using rule 52 (expression -> term .)
    SEMICOLON       reduce using rule 52 (expression -> term .)


state 59

    (60) factor -> ID .

    RPAREN          reduce using rule 60 (factor -> ID .)
    PLUS            reduce using rule 60 (factor -> ID .)
    MINUS           reduce using rule 60 (factor -> ID .)
    TIMES           reduce using rule 60 (factor -> ID .)
    DIVIDE          reduce using rule 60 (factor -> ID .)
    MOD             reduce using rule 60 (factor -> ID .)
    $end            reduce using rule 60 (factor -> ID .)
    PRINT           reduce using rule 60 (factor -> ID .)
    PRINTLN         reduce using rule 60 (factor -> ID .)
    VAR             reduce using rule 60 (factor -> ID .)
    VAL             reduce using rule 60 (factor -> ID .)
    ID              reduce using rule 60 (factor -> ID .)
    LPAREN          reduce using rule 60 (factor -> ID .)
    FOR             reduce using rule 60 (factor -> ID .)
    IF              reduce using rule 60 (factor -> ID .)
    WHILE           reduce using rule 60 (factor -> ID .)
    ARRAYLIST       reduce using rule 60 (factor -> ID .)
    STACK           reduce using rule 60 (factor -> ID .)
    EXCL_WS         reduce using rule 60 (factor -> ID .)
    INT             reduce using rule 60 (factor -> ID .)
    FLOAT           reduce using rule 60 (factor -> ID .)
    LONG            reduce using rule 60 (factor -> ID .)
    CHAR            reduce using rule 60 (factor -> ID .)
    BOOLEAN         reduce using rule 60 (factor -> ID .)
    STRING_1        reduce using rule 60 (factor -> ID .)
    SEMICOLON       reduce using rule 60 (factor -> ID .)
    RCURL           reduce using rule 60 (factor -> ID .)
    CONJ            reduce using rule 60 (factor -> ID .)
    DISJ            reduce using rule 60 (factor -> ID .)
    LANGLE          reduce using rule 60 (factor -> ID .)
    RANGLE          reduce using rule 60 (factor -> ID .)
    LE              reduce using rule 60 (factor -> ID .)
    GE              reduce using rule 60 (factor -> ID .)
    EXCL_EQ         reduce using rule 60 (factor -> ID .)
    EXCL_EQEQ       reduce using rule 60 (factor -> ID .)
    AS_SAFE         reduce using rule 60 (factor -> ID .)
    EQEQ            reduce using rule 60 (factor -> ID .)
    EQEQEQ          reduce using rule 60 (factor -> ID .)


state 60

    (28) impresion -> PRINTLN LPAREN . expression RPAREN
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    expression                     shift and go to state 93
    term                           shift and go to state 58
    factor                         shift and go to state 31

state 61

    (33) asignacion -> keywordVariables asignacionSimple .

    SEMICOLON       reduce using rule 33 (asignacion -> keywordVariables asignacionSimple .)


state 62

    (82) stack -> keywordVariables ID . DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (100) lista -> keywordVariables ID . DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (37) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> ID . EQUAL valor

    DOTS            shift and go to state 94
    EQUAL           shift and go to state 78


state 63

    (68) condicionL -> term opL . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 95
    factor                         shift and go to state 31

state 64

    (69) condicionR -> term opR . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    term                           shift and go to state 96
    factor                         shift and go to state 31

state 65

    (71) opL -> CONJ .

    LPAREN          reduce using rule 71 (opL -> CONJ .)
    INT             reduce using rule 71 (opL -> CONJ .)
    FLOAT           reduce using rule 71 (opL -> CONJ .)
    LONG            reduce using rule 71 (opL -> CONJ .)
    CHAR            reduce using rule 71 (opL -> CONJ .)
    BOOLEAN         reduce using rule 71 (opL -> CONJ .)
    ID              reduce using rule 71 (opL -> CONJ .)
    STRING_1        reduce using rule 71 (opL -> CONJ .)


state 66

    (72) opL -> DISJ .

    LPAREN          reduce using rule 72 (opL -> DISJ .)
    INT             reduce using rule 72 (opL -> DISJ .)
    FLOAT           reduce using rule 72 (opL -> DISJ .)
    LONG            reduce using rule 72 (opL -> DISJ .)
    CHAR            reduce using rule 72 (opL -> DISJ .)
    BOOLEAN         reduce using rule 72 (opL -> DISJ .)
    ID              reduce using rule 72 (opL -> DISJ .)
    STRING_1        reduce using rule 72 (opL -> DISJ .)


state 67

    (73) opR -> LANGLE .

    LPAREN          reduce using rule 73 (opR -> LANGLE .)
    INT             reduce using rule 73 (opR -> LANGLE .)
    FLOAT           reduce using rule 73 (opR -> LANGLE .)
    LONG            reduce using rule 73 (opR -> LANGLE .)
    CHAR            reduce using rule 73 (opR -> LANGLE .)
    BOOLEAN         reduce using rule 73 (opR -> LANGLE .)
    ID              reduce using rule 73 (opR -> LANGLE .)
    STRING_1        reduce using rule 73 (opR -> LANGLE .)
    TINT            reduce using rule 73 (opR -> LANGLE .)


state 68

    (74) opR -> RANGLE .

    LPAREN          reduce using rule 74 (opR -> RANGLE .)
    INT             reduce using rule 74 (opR -> RANGLE .)
    FLOAT           reduce using rule 74 (opR -> RANGLE .)
    LONG            reduce using rule 74 (opR -> RANGLE .)
    CHAR            reduce using rule 74 (opR -> RANGLE .)
    BOOLEAN         reduce using rule 74 (opR -> RANGLE .)
    ID              reduce using rule 74 (opR -> RANGLE .)
    STRING_1        reduce using rule 74 (opR -> RANGLE .)
    TINT            reduce using rule 74 (opR -> RANGLE .)


state 69

    (75) opR -> LE .

    LPAREN          reduce using rule 75 (opR -> LE .)
    INT             reduce using rule 75 (opR -> LE .)
    FLOAT           reduce using rule 75 (opR -> LE .)
    LONG            reduce using rule 75 (opR -> LE .)
    CHAR            reduce using rule 75 (opR -> LE .)
    BOOLEAN         reduce using rule 75 (opR -> LE .)
    ID              reduce using rule 75 (opR -> LE .)
    STRING_1        reduce using rule 75 (opR -> LE .)
    TINT            reduce using rule 75 (opR -> LE .)


state 70

    (76) opR -> GE .

    LPAREN          reduce using rule 76 (opR -> GE .)
    INT             reduce using rule 76 (opR -> GE .)
    FLOAT           reduce using rule 76 (opR -> GE .)
    LONG            reduce using rule 76 (opR -> GE .)
    CHAR            reduce using rule 76 (opR -> GE .)
    BOOLEAN         reduce using rule 76 (opR -> GE .)
    ID              reduce using rule 76 (opR -> GE .)
    STRING_1        reduce using rule 76 (opR -> GE .)
    TINT            reduce using rule 76 (opR -> GE .)


state 71

    (77) opR -> EXCL_EQ .

    LPAREN          reduce using rule 77 (opR -> EXCL_EQ .)
    INT             reduce using rule 77 (opR -> EXCL_EQ .)
    FLOAT           reduce using rule 77 (opR -> EXCL_EQ .)
    LONG            reduce using rule 77 (opR -> EXCL_EQ .)
    CHAR            reduce using rule 77 (opR -> EXCL_EQ .)
    BOOLEAN         reduce using rule 77 (opR -> EXCL_EQ .)
    ID              reduce using rule 77 (opR -> EXCL_EQ .)
    STRING_1        reduce using rule 77 (opR -> EXCL_EQ .)
    TINT            reduce using rule 77 (opR -> EXCL_EQ .)


state 72

    (78) opR -> EXCL_EQEQ .

    LPAREN          reduce using rule 78 (opR -> EXCL_EQEQ .)
    INT             reduce using rule 78 (opR -> EXCL_EQEQ .)
    FLOAT           reduce using rule 78 (opR -> EXCL_EQEQ .)
    LONG            reduce using rule 78 (opR -> EXCL_EQEQ .)
    CHAR            reduce using rule 78 (opR -> EXCL_EQEQ .)
    BOOLEAN         reduce using rule 78 (opR -> EXCL_EQEQ .)
    ID              reduce using rule 78 (opR -> EXCL_EQEQ .)
    STRING_1        reduce using rule 78 (opR -> EXCL_EQEQ .)
    TINT            reduce using rule 78 (opR -> EXCL_EQEQ .)


state 73

    (79) opR -> AS_SAFE .

    LPAREN          reduce using rule 79 (opR -> AS_SAFE .)
    INT             reduce using rule 79 (opR -> AS_SAFE .)
    FLOAT           reduce using rule 79 (opR -> AS_SAFE .)
    LONG            reduce using rule 79 (opR -> AS_SAFE .)
    CHAR            reduce using rule 79 (opR -> AS_SAFE .)
    BOOLEAN         reduce using rule 79 (opR -> AS_SAFE .)
    ID              reduce using rule 79 (opR -> AS_SAFE .)
    STRING_1        reduce using rule 79 (opR -> AS_SAFE .)
    TINT            reduce using rule 79 (opR -> AS_SAFE .)


state 74

    (80) opR -> EQEQ .

    LPAREN          reduce using rule 80 (opR -> EQEQ .)
    INT             reduce using rule 80 (opR -> EQEQ .)
    FLOAT           reduce using rule 80 (opR -> EQEQ .)
    LONG            reduce using rule 80 (opR -> EQEQ .)
    CHAR            reduce using rule 80 (opR -> EQEQ .)
    BOOLEAN         reduce using rule 80 (opR -> EQEQ .)
    ID              reduce using rule 80 (opR -> EQEQ .)
    STRING_1        reduce using rule 80 (opR -> EQEQ .)
    TINT            reduce using rule 80 (opR -> EQEQ .)


state 75

    (81) opR -> EQEQEQ .

    LPAREN          reduce using rule 81 (opR -> EQEQEQ .)
    INT             reduce using rule 81 (opR -> EQEQEQ .)
    FLOAT           reduce using rule 81 (opR -> EQEQEQ .)
    LONG            reduce using rule 81 (opR -> EQEQEQ .)
    CHAR            reduce using rule 81 (opR -> EQEQEQ .)
    BOOLEAN         reduce using rule 81 (opR -> EQEQEQ .)
    ID              reduce using rule 81 (opR -> EQEQEQ .)
    STRING_1        reduce using rule 81 (opR -> EQEQEQ .)
    TINT            reduce using rule 81 (opR -> EQEQEQ .)


state 76

    (29) queue -> VAL ID . DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    DOTS            shift and go to state 97


state 77

    (37) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (39) tipoDato -> . TINT
    (40) tipoDato -> . TLONG
    (41) tipoDato -> . TFLOAT
    (42) tipoDato -> . TDOUBLE
    (43) tipoDato -> . TBOOLEAN
    (44) tipoDato -> . TCHAR
    (45) tipoDato -> . TSTRING

    TINT            shift and go to state 99
    TLONG           shift and go to state 100
    TFLOAT          shift and go to state 101
    TDOUBLE         shift and go to state 102
    TBOOLEAN        shift and go to state 103
    TCHAR           shift and go to state 104
    TSTRING         shift and go to state 105

    tipoDato                       shift and go to state 98

state 78

    (38) asignacionSimple -> ID EQUAL . valor
    (46) valor -> . expression
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    valor                          shift and go to state 106
    expression                     shift and go to state 107
    term                           shift and go to state 58
    factor                         shift and go to state 31

state 79

    (85) stack_actuar -> ID DOT . stack_funciones
    (101) lsimplem -> ID DOT . Lmetod
    (23) queue_add -> ID DOT . ADD LPAREN factor RPAREN
    (24) queue_peek -> ID DOT . PEEK LPAREN RPAREN
    (26) queue_remove -> ID DOT . REMOVE LPAREN RPAREN
    (25) queue_poll -> ID DOT . POLL LPAREN RPAREN
    (86) stack_funciones -> . stack_isEmpty
    (87) stack_funciones -> . stack_push
    (88) stack_funciones -> . stack_pop
    (89) stack_funciones -> . stack_peek
    (90) stack_funciones -> . stack_size
    (96) Lmetod -> . FIRST LPAREN RPAREN
    (97) Lmetod -> . LAST LPAREN RPAREN
    (98) Lmetod -> . REMOVEL LPAREN RPAREN
    (91) stack_isEmpty -> . ISEMPTY LPAREN RPAREN
    (93) stack_push -> . PUSH LPAREN ID RPAREN
    (92) stack_pop -> . POP LPAREN RPAREN
    (94) stack_peek -> . PEEK LPAREN RPAREN
    (95) stack_size -> . SIZE LPAREN RPAREN

    ADD             shift and go to state 110
    PEEK            shift and go to state 111
    REMOVE          shift and go to state 112
    POLL            shift and go to state 113
    FIRST           shift and go to state 119
    LAST            shift and go to state 120
    REMOVEL         shift and go to state 121
    ISEMPTY         shift and go to state 122
    PUSH            shift and go to state 123
    POP             shift and go to state 124
    SIZE            shift and go to state 125

    stack_funciones                shift and go to state 108
    Lmetod                         shift and go to state 109
    stack_isEmpty                  shift and go to state 114
    stack_push                     shift and go to state 115
    stack_pop                      shift and go to state 116
    stack_peek                     shift and go to state 117
    stack_size                     shift and go to state 118

state 80

    (30) for -> FOR LPAREN . ID IN ID RPAREN LCURL morelines RCURL

    ID              shift and go to state 126


state 81

    (62) if -> IF LPAREN . condicion RPAREN LCURL morelines RCURL
    (63) if -> IF LPAREN . condicion RPAREN LCURL morelines RCURL else
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    EXCL_WS         shift and go to state 41
    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    condicion                      shift and go to state 127
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    term                           shift and go to state 128
    factor                         shift and go to state 31

state 82

    (99) while -> WHILE DOTS . LPAREN ID opR TINT RPAREN LCURL morelines RCURL

    LPAREN          shift and go to state 129


state 83

    (84) instance_arraylist -> ARRAYLIST LPAREN . RPAREN

    RPAREN          shift and go to state 130


state 84

    (83) def_estruct_tipoDato -> STACK LANGLE . tipoDato RANGLE
    (39) tipoDato -> . TINT
    (40) tipoDato -> . TLONG
    (41) tipoDato -> . TFLOAT
    (42) tipoDato -> . TDOUBLE
    (43) tipoDato -> . TBOOLEAN
    (44) tipoDato -> . TCHAR
    (45) tipoDato -> . TSTRING

    TINT            shift and go to state 99
    TLONG           shift and go to state 100
    TFLOAT          shift and go to state 101
    TDOUBLE         shift and go to state 102
    TBOOLEAN        shift and go to state 103
    TCHAR           shift and go to state 104
    TSTRING         shift and go to state 105

    tipoDato                       shift and go to state 131

state 85

    (70) condicionN -> EXCL_WS term .

    $end            reduce using rule 70 (condicionN -> EXCL_WS term .)
    RPAREN          reduce using rule 70 (condicionN -> EXCL_WS term .)
    PRINT           reduce using rule 70 (condicionN -> EXCL_WS term .)
    PRINTLN         reduce using rule 70 (condicionN -> EXCL_WS term .)
    VAR             reduce using rule 70 (condicionN -> EXCL_WS term .)
    VAL             reduce using rule 70 (condicionN -> EXCL_WS term .)
    ID              reduce using rule 70 (condicionN -> EXCL_WS term .)
    LPAREN          reduce using rule 70 (condicionN -> EXCL_WS term .)
    FOR             reduce using rule 70 (condicionN -> EXCL_WS term .)
    IF              reduce using rule 70 (condicionN -> EXCL_WS term .)
    WHILE           reduce using rule 70 (condicionN -> EXCL_WS term .)
    ARRAYLIST       reduce using rule 70 (condicionN -> EXCL_WS term .)
    STACK           reduce using rule 70 (condicionN -> EXCL_WS term .)
    EXCL_WS         reduce using rule 70 (condicionN -> EXCL_WS term .)
    INT             reduce using rule 70 (condicionN -> EXCL_WS term .)
    FLOAT           reduce using rule 70 (condicionN -> EXCL_WS term .)
    LONG            reduce using rule 70 (condicionN -> EXCL_WS term .)
    CHAR            reduce using rule 70 (condicionN -> EXCL_WS term .)
    BOOLEAN         reduce using rule 70 (condicionN -> EXCL_WS term .)
    STRING_1        reduce using rule 70 (condicionN -> EXCL_WS term .)
    SEMICOLON       reduce using rule 70 (condicionN -> EXCL_WS term .)
    RCURL           reduce using rule 70 (condicionN -> EXCL_WS term .)


state 86

    (47) expression -> expression PLUS term .

    PLUS            reduce using rule 47 (expression -> expression PLUS term .)
    MINUS           reduce using rule 47 (expression -> expression PLUS term .)
    TIMES           reduce using rule 47 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 47 (expression -> expression PLUS term .)
    MOD             reduce using rule 47 (expression -> expression PLUS term .)
    $end            reduce using rule 47 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 47 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 47 (expression -> expression PLUS term .)
    PRINT           reduce using rule 47 (expression -> expression PLUS term .)
    PRINTLN         reduce using rule 47 (expression -> expression PLUS term .)
    VAR             reduce using rule 47 (expression -> expression PLUS term .)
    VAL             reduce using rule 47 (expression -> expression PLUS term .)
    ID              reduce using rule 47 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 47 (expression -> expression PLUS term .)
    FOR             reduce using rule 47 (expression -> expression PLUS term .)
    IF              reduce using rule 47 (expression -> expression PLUS term .)
    WHILE           reduce using rule 47 (expression -> expression PLUS term .)
    ARRAYLIST       reduce using rule 47 (expression -> expression PLUS term .)
    STACK           reduce using rule 47 (expression -> expression PLUS term .)
    EXCL_WS         reduce using rule 47 (expression -> expression PLUS term .)
    INT             reduce using rule 47 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 47 (expression -> expression PLUS term .)
    LONG            reduce using rule 47 (expression -> expression PLUS term .)
    CHAR            reduce using rule 47 (expression -> expression PLUS term .)
    BOOLEAN         reduce using rule 47 (expression -> expression PLUS term .)
    STRING_1        reduce using rule 47 (expression -> expression PLUS term .)
    RCURL           reduce using rule 47 (expression -> expression PLUS term .)


state 87

    (48) expression -> expression MINUS term .

    PLUS            reduce using rule 48 (expression -> expression MINUS term .)
    MINUS           reduce using rule 48 (expression -> expression MINUS term .)
    TIMES           reduce using rule 48 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 48 (expression -> expression MINUS term .)
    MOD             reduce using rule 48 (expression -> expression MINUS term .)
    $end            reduce using rule 48 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 48 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 48 (expression -> expression MINUS term .)
    PRINT           reduce using rule 48 (expression -> expression MINUS term .)
    PRINTLN         reduce using rule 48 (expression -> expression MINUS term .)
    VAR             reduce using rule 48 (expression -> expression MINUS term .)
    VAL             reduce using rule 48 (expression -> expression MINUS term .)
    ID              reduce using rule 48 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 48 (expression -> expression MINUS term .)
    FOR             reduce using rule 48 (expression -> expression MINUS term .)
    IF              reduce using rule 48 (expression -> expression MINUS term .)
    WHILE           reduce using rule 48 (expression -> expression MINUS term .)
    ARRAYLIST       reduce using rule 48 (expression -> expression MINUS term .)
    STACK           reduce using rule 48 (expression -> expression MINUS term .)
    EXCL_WS         reduce using rule 48 (expression -> expression MINUS term .)
    INT             reduce using rule 48 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 48 (expression -> expression MINUS term .)
    LONG            reduce using rule 48 (expression -> expression MINUS term .)
    CHAR            reduce using rule 48 (expression -> expression MINUS term .)
    BOOLEAN         reduce using rule 48 (expression -> expression MINUS term .)
    STRING_1        reduce using rule 48 (expression -> expression MINUS term .)
    RCURL           reduce using rule 48 (expression -> expression MINUS term .)


state 88

    (49) expression -> expression TIMES term .

    PLUS            reduce using rule 49 (expression -> expression TIMES term .)
    MINUS           reduce using rule 49 (expression -> expression TIMES term .)
    TIMES           reduce using rule 49 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 49 (expression -> expression TIMES term .)
    MOD             reduce using rule 49 (expression -> expression TIMES term .)
    $end            reduce using rule 49 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 49 (expression -> expression TIMES term .)
    SEMICOLON       reduce using rule 49 (expression -> expression TIMES term .)
    PRINT           reduce using rule 49 (expression -> expression TIMES term .)
    PRINTLN         reduce using rule 49 (expression -> expression TIMES term .)
    VAR             reduce using rule 49 (expression -> expression TIMES term .)
    VAL             reduce using rule 49 (expression -> expression TIMES term .)
    ID              reduce using rule 49 (expression -> expression TIMES term .)
    LPAREN          reduce using rule 49 (expression -> expression TIMES term .)
    FOR             reduce using rule 49 (expression -> expression TIMES term .)
    IF              reduce using rule 49 (expression -> expression TIMES term .)
    WHILE           reduce using rule 49 (expression -> expression TIMES term .)
    ARRAYLIST       reduce using rule 49 (expression -> expression TIMES term .)
    STACK           reduce using rule 49 (expression -> expression TIMES term .)
    EXCL_WS         reduce using rule 49 (expression -> expression TIMES term .)
    INT             reduce using rule 49 (expression -> expression TIMES term .)
    FLOAT           reduce using rule 49 (expression -> expression TIMES term .)
    LONG            reduce using rule 49 (expression -> expression TIMES term .)
    CHAR            reduce using rule 49 (expression -> expression TIMES term .)
    BOOLEAN         reduce using rule 49 (expression -> expression TIMES term .)
    STRING_1        reduce using rule 49 (expression -> expression TIMES term .)
    RCURL           reduce using rule 49 (expression -> expression TIMES term .)


state 89

    (50) expression -> expression DIVIDE term .

    PLUS            reduce using rule 50 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 50 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 50 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 50 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 50 (expression -> expression DIVIDE term .)
    $end            reduce using rule 50 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 50 (expression -> expression DIVIDE term .)
    SEMICOLON       reduce using rule 50 (expression -> expression DIVIDE term .)
    PRINT           reduce using rule 50 (expression -> expression DIVIDE term .)
    PRINTLN         reduce using rule 50 (expression -> expression DIVIDE term .)
    VAR             reduce using rule 50 (expression -> expression DIVIDE term .)
    VAL             reduce using rule 50 (expression -> expression DIVIDE term .)
    ID              reduce using rule 50 (expression -> expression DIVIDE term .)
    LPAREN          reduce using rule 50 (expression -> expression DIVIDE term .)
    FOR             reduce using rule 50 (expression -> expression DIVIDE term .)
    IF              reduce using rule 50 (expression -> expression DIVIDE term .)
    WHILE           reduce using rule 50 (expression -> expression DIVIDE term .)
    ARRAYLIST       reduce using rule 50 (expression -> expression DIVIDE term .)
    STACK           reduce using rule 50 (expression -> expression DIVIDE term .)
    EXCL_WS         reduce using rule 50 (expression -> expression DIVIDE term .)
    INT             reduce using rule 50 (expression -> expression DIVIDE term .)
    FLOAT           reduce using rule 50 (expression -> expression DIVIDE term .)
    LONG            reduce using rule 50 (expression -> expression DIVIDE term .)
    CHAR            reduce using rule 50 (expression -> expression DIVIDE term .)
    BOOLEAN         reduce using rule 50 (expression -> expression DIVIDE term .)
    STRING_1        reduce using rule 50 (expression -> expression DIVIDE term .)
    RCURL           reduce using rule 50 (expression -> expression DIVIDE term .)


state 90

    (51) expression -> expression MOD term .

    PLUS            reduce using rule 51 (expression -> expression MOD term .)
    MINUS           reduce using rule 51 (expression -> expression MOD term .)
    TIMES           reduce using rule 51 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 51 (expression -> expression MOD term .)
    MOD             reduce using rule 51 (expression -> expression MOD term .)
    $end            reduce using rule 51 (expression -> expression MOD term .)
    RPAREN          reduce using rule 51 (expression -> expression MOD term .)
    SEMICOLON       reduce using rule 51 (expression -> expression MOD term .)
    PRINT           reduce using rule 51 (expression -> expression MOD term .)
    PRINTLN         reduce using rule 51 (expression -> expression MOD term .)
    VAR             reduce using rule 51 (expression -> expression MOD term .)
    VAL             reduce using rule 51 (expression -> expression MOD term .)
    ID              reduce using rule 51 (expression -> expression MOD term .)
    LPAREN          reduce using rule 51 (expression -> expression MOD term .)
    FOR             reduce using rule 51 (expression -> expression MOD term .)
    IF              reduce using rule 51 (expression -> expression MOD term .)
    WHILE           reduce using rule 51 (expression -> expression MOD term .)
    ARRAYLIST       reduce using rule 51 (expression -> expression MOD term .)
    STACK           reduce using rule 51 (expression -> expression MOD term .)
    EXCL_WS         reduce using rule 51 (expression -> expression MOD term .)
    INT             reduce using rule 51 (expression -> expression MOD term .)
    FLOAT           reduce using rule 51 (expression -> expression MOD term .)
    LONG            reduce using rule 51 (expression -> expression MOD term .)
    CHAR            reduce using rule 51 (expression -> expression MOD term .)
    BOOLEAN         reduce using rule 51 (expression -> expression MOD term .)
    STRING_1        reduce using rule 51 (expression -> expression MOD term .)
    RCURL           reduce using rule 51 (expression -> expression MOD term .)


state 91

    (27) impresion -> PRINT LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term
    (49) expression -> expression . TIMES term
    (50) expression -> expression . DIVIDE term
    (51) expression -> expression . MOD term

    RPAREN          shift and go to state 132
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MOD             shift and go to state 54


state 92

    (54) term -> LPAREN expression RPAREN .

    CONJ            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    DISJ            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LANGLE          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    RANGLE          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EXCL_EQ         reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EXCL_EQEQ       reduce using rule 54 (term -> LPAREN expression RPAREN .)
    AS_SAFE         reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EQEQEQ          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    PRINTLN         reduce using rule 54 (term -> LPAREN expression RPAREN .)
    VAR             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    VAL             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    ID              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 54 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 54 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    ARRAYLIST       reduce using rule 54 (term -> LPAREN expression RPAREN .)
    STACK           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    EXCL_WS         reduce using rule 54 (term -> LPAREN expression RPAREN .)
    INT             reduce using rule 54 (term -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 54 (term -> LPAREN expression RPAREN .)
    LONG            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    CHAR            reduce using rule 54 (term -> LPAREN expression RPAREN .)
    BOOLEAN         reduce using rule 54 (term -> LPAREN expression RPAREN .)
    STRING_1        reduce using rule 54 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 54 (term -> LPAREN expression RPAREN .)
    RCURL           reduce using rule 54 (term -> LPAREN expression RPAREN .)


state 93

    (28) impresion -> PRINTLN LPAREN expression . RPAREN
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term
    (49) expression -> expression . TIMES term
    (50) expression -> expression . DIVIDE term
    (51) expression -> expression . MOD term

    RPAREN          shift and go to state 133
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MOD             shift and go to state 54


state 94

    (82) stack -> keywordVariables ID DOTS . def_estruct_tipoDato EQUAL instance_arraylist
    (100) lista -> keywordVariables ID DOTS . LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (37) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (39) tipoDato -> . TINT
    (40) tipoDato -> . TLONG
    (41) tipoDato -> . TFLOAT
    (42) tipoDato -> . TDOUBLE
    (43) tipoDato -> . TBOOLEAN
    (44) tipoDato -> . TCHAR
    (45) tipoDato -> . TSTRING

    LINKEDL         shift and go to state 135
    STACK           shift and go to state 40
    TINT            shift and go to state 99
    TLONG           shift and go to state 100
    TFLOAT          shift and go to state 101
    TDOUBLE         shift and go to state 102
    TBOOLEAN        shift and go to state 103
    TCHAR           shift and go to state 104
    TSTRING         shift and go to state 105

    def_estruct_tipoDato           shift and go to state 134
    tipoDato                       shift and go to state 98

state 95

    (68) condicionL -> term opL term .

    $end            reduce using rule 68 (condicionL -> term opL term .)
    RPAREN          reduce using rule 68 (condicionL -> term opL term .)
    PRINT           reduce using rule 68 (condicionL -> term opL term .)
    PRINTLN         reduce using rule 68 (condicionL -> term opL term .)
    VAR             reduce using rule 68 (condicionL -> term opL term .)
    VAL             reduce using rule 68 (condicionL -> term opL term .)
    ID              reduce using rule 68 (condicionL -> term opL term .)
    LPAREN          reduce using rule 68 (condicionL -> term opL term .)
    FOR             reduce using rule 68 (condicionL -> term opL term .)
    IF              reduce using rule 68 (condicionL -> term opL term .)
    WHILE           reduce using rule 68 (condicionL -> term opL term .)
    ARRAYLIST       reduce using rule 68 (condicionL -> term opL term .)
    STACK           reduce using rule 68 (condicionL -> term opL term .)
    EXCL_WS         reduce using rule 68 (condicionL -> term opL term .)
    INT             reduce using rule 68 (condicionL -> term opL term .)
    FLOAT           reduce using rule 68 (condicionL -> term opL term .)
    LONG            reduce using rule 68 (condicionL -> term opL term .)
    CHAR            reduce using rule 68 (condicionL -> term opL term .)
    BOOLEAN         reduce using rule 68 (condicionL -> term opL term .)
    STRING_1        reduce using rule 68 (condicionL -> term opL term .)
    SEMICOLON       reduce using rule 68 (condicionL -> term opL term .)
    RCURL           reduce using rule 68 (condicionL -> term opL term .)


state 96

    (69) condicionR -> term opR term .

    $end            reduce using rule 69 (condicionR -> term opR term .)
    RPAREN          reduce using rule 69 (condicionR -> term opR term .)
    PRINT           reduce using rule 69 (condicionR -> term opR term .)
    PRINTLN         reduce using rule 69 (condicionR -> term opR term .)
    VAR             reduce using rule 69 (condicionR -> term opR term .)
    VAL             reduce using rule 69 (condicionR -> term opR term .)
    ID              reduce using rule 69 (condicionR -> term opR term .)
    LPAREN          reduce using rule 69 (condicionR -> term opR term .)
    FOR             reduce using rule 69 (condicionR -> term opR term .)
    IF              reduce using rule 69 (condicionR -> term opR term .)
    WHILE           reduce using rule 69 (condicionR -> term opR term .)
    ARRAYLIST       reduce using rule 69 (condicionR -> term opR term .)
    STACK           reduce using rule 69 (condicionR -> term opR term .)
    EXCL_WS         reduce using rule 69 (condicionR -> term opR term .)
    INT             reduce using rule 69 (condicionR -> term opR term .)
    FLOAT           reduce using rule 69 (condicionR -> term opR term .)
    LONG            reduce using rule 69 (condicionR -> term opR term .)
    CHAR            reduce using rule 69 (condicionR -> term opR term .)
    BOOLEAN         reduce using rule 69 (condicionR -> term opR term .)
    STRING_1        reduce using rule 69 (condicionR -> term opR term .)
    SEMICOLON       reduce using rule 69 (condicionR -> term opR term .)
    RCURL           reduce using rule 69 (condicionR -> term opR term .)


state 97

    (29) queue -> VAL ID DOTS . QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    QUEUE           shift and go to state 136


state 98

    (37) asignacionSimple -> ID DOTS tipoDato . EQUAL valor

    EQUAL           shift and go to state 137


state 99

    (39) tipoDato -> TINT .

    EQUAL           reduce using rule 39 (tipoDato -> TINT .)
    RANGLE          reduce using rule 39 (tipoDato -> TINT .)


state 100

    (40) tipoDato -> TLONG .

    EQUAL           reduce using rule 40 (tipoDato -> TLONG .)
    RANGLE          reduce using rule 40 (tipoDato -> TLONG .)


state 101

    (41) tipoDato -> TFLOAT .

    EQUAL           reduce using rule 41 (tipoDato -> TFLOAT .)
    RANGLE          reduce using rule 41 (tipoDato -> TFLOAT .)


state 102

    (42) tipoDato -> TDOUBLE .

    EQUAL           reduce using rule 42 (tipoDato -> TDOUBLE .)
    RANGLE          reduce using rule 42 (tipoDato -> TDOUBLE .)


state 103

    (43) tipoDato -> TBOOLEAN .

    EQUAL           reduce using rule 43 (tipoDato -> TBOOLEAN .)
    RANGLE          reduce using rule 43 (tipoDato -> TBOOLEAN .)


state 104

    (44) tipoDato -> TCHAR .

    EQUAL           reduce using rule 44 (tipoDato -> TCHAR .)
    RANGLE          reduce using rule 44 (tipoDato -> TCHAR .)


state 105

    (45) tipoDato -> TSTRING .

    EQUAL           reduce using rule 45 (tipoDato -> TSTRING .)
    RANGLE          reduce using rule 45 (tipoDato -> TSTRING .)


state 106

    (38) asignacionSimple -> ID EQUAL valor .

    SEMICOLON       reduce using rule 38 (asignacionSimple -> ID EQUAL valor .)


state 107

    (46) valor -> expression .
    (47) expression -> expression . PLUS term
    (48) expression -> expression . MINUS term
    (49) expression -> expression . TIMES term
    (50) expression -> expression . DIVIDE term
    (51) expression -> expression . MOD term

    SEMICOLON       reduce using rule 46 (valor -> expression .)
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MOD             shift and go to state 54


state 108

    (85) stack_actuar -> ID DOT stack_funciones .

    SEMICOLON       reduce using rule 85 (stack_actuar -> ID DOT stack_funciones .)


state 109

    (101) lsimplem -> ID DOT Lmetod .

    SEMICOLON       reduce using rule 101 (lsimplem -> ID DOT Lmetod .)


state 110

    (23) queue_add -> ID DOT ADD . LPAREN factor RPAREN

    LPAREN          shift and go to state 138


state 111

    (24) queue_peek -> ID DOT PEEK . LPAREN RPAREN
    (94) stack_peek -> PEEK . LPAREN RPAREN

    LPAREN          shift and go to state 139


state 112

    (26) queue_remove -> ID DOT REMOVE . LPAREN RPAREN

    LPAREN          shift and go to state 140


state 113

    (25) queue_poll -> ID DOT POLL . LPAREN RPAREN

    LPAREN          shift and go to state 141


state 114

    (86) stack_funciones -> stack_isEmpty .

    SEMICOLON       reduce using rule 86 (stack_funciones -> stack_isEmpty .)


state 115

    (87) stack_funciones -> stack_push .

    SEMICOLON       reduce using rule 87 (stack_funciones -> stack_push .)


state 116

    (88) stack_funciones -> stack_pop .

    SEMICOLON       reduce using rule 88 (stack_funciones -> stack_pop .)


state 117

    (89) stack_funciones -> stack_peek .

    SEMICOLON       reduce using rule 89 (stack_funciones -> stack_peek .)


state 118

    (90) stack_funciones -> stack_size .

    SEMICOLON       reduce using rule 90 (stack_funciones -> stack_size .)


state 119

    (96) Lmetod -> FIRST . LPAREN RPAREN

    LPAREN          shift and go to state 142


state 120

    (97) Lmetod -> LAST . LPAREN RPAREN

    LPAREN          shift and go to state 143


state 121

    (98) Lmetod -> REMOVEL . LPAREN RPAREN

    LPAREN          shift and go to state 144


state 122

    (91) stack_isEmpty -> ISEMPTY . LPAREN RPAREN

    LPAREN          shift and go to state 145


state 123

    (93) stack_push -> PUSH . LPAREN ID RPAREN

    LPAREN          shift and go to state 146


state 124

    (92) stack_pop -> POP . LPAREN RPAREN

    LPAREN          shift and go to state 147


state 125

    (95) stack_size -> SIZE . LPAREN RPAREN

    LPAREN          shift and go to state 148


state 126

    (30) for -> FOR LPAREN ID . IN ID RPAREN LCURL morelines RCURL

    IN              shift and go to state 149


state 127

    (62) if -> IF LPAREN condicion . RPAREN LCURL morelines RCURL
    (63) if -> IF LPAREN condicion . RPAREN LCURL morelines RCURL else

    RPAREN          shift and go to state 150


state 128

    (68) condicionL -> term . opL term
    (69) condicionR -> term . opR term
    (71) opL -> . CONJ
    (72) opL -> . DISJ
    (73) opR -> . LANGLE
    (74) opR -> . RANGLE
    (75) opR -> . LE
    (76) opR -> . GE
    (77) opR -> . EXCL_EQ
    (78) opR -> . EXCL_EQEQ
    (79) opR -> . AS_SAFE
    (80) opR -> . EQEQ
    (81) opR -> . EQEQEQ

    CONJ            shift and go to state 65
    DISJ            shift and go to state 66
    LANGLE          shift and go to state 67
    RANGLE          shift and go to state 68
    LE              shift and go to state 69
    GE              shift and go to state 70
    EXCL_EQ         shift and go to state 71
    EXCL_EQEQ       shift and go to state 72
    AS_SAFE         shift and go to state 73
    EQEQ            shift and go to state 74
    EQEQEQ          shift and go to state 75

    opL                            shift and go to state 63
    opR                            shift and go to state 64

state 129

    (99) while -> WHILE DOTS LPAREN . ID opR TINT RPAREN LCURL morelines RCURL

    ID              shift and go to state 151


state 130

    (84) instance_arraylist -> ARRAYLIST LPAREN RPAREN .

    SEMICOLON       reduce using rule 84 (instance_arraylist -> ARRAYLIST LPAREN RPAREN .)


state 131

    (83) def_estruct_tipoDato -> STACK LANGLE tipoDato . RANGLE

    RANGLE          shift and go to state 152


state 132

    (27) impresion -> PRINT LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 27 (impresion -> PRINT LPAREN expression RPAREN .)


state 133

    (28) impresion -> PRINTLN LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 28 (impresion -> PRINTLN LPAREN expression RPAREN .)


state 134

    (82) stack -> keywordVariables ID DOTS def_estruct_tipoDato . EQUAL instance_arraylist

    EQUAL           shift and go to state 153


state 135

    (100) lista -> keywordVariables ID DOTS LINKEDL . LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 154


state 136

    (29) queue -> VAL ID DOTS QUEUE . LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 155


state 137

    (37) asignacionSimple -> ID DOTS tipoDato EQUAL . valor
    (46) valor -> . expression
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    LPAREN          shift and go to state 9
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    valor                          shift and go to state 156
    expression                     shift and go to state 107
    term                           shift and go to state 58
    factor                         shift and go to state 31

state 138

    (23) queue_add -> ID DOT ADD LPAREN . factor RPAREN
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1

    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    ID              shift and go to state 59
    STRING_1        shift and go to state 47

    factor                         shift and go to state 157

state 139

    (24) queue_peek -> ID DOT PEEK LPAREN . RPAREN
    (94) stack_peek -> PEEK LPAREN . RPAREN

    RPAREN          shift and go to state 158


state 140

    (26) queue_remove -> ID DOT REMOVE LPAREN . RPAREN

    RPAREN          shift and go to state 159


state 141

    (25) queue_poll -> ID DOT POLL LPAREN . RPAREN

    RPAREN          shift and go to state 160


state 142

    (96) Lmetod -> FIRST LPAREN . RPAREN

    RPAREN          shift and go to state 161


state 143

    (97) Lmetod -> LAST LPAREN . RPAREN

    RPAREN          shift and go to state 162


state 144

    (98) Lmetod -> REMOVEL LPAREN . RPAREN

    RPAREN          shift and go to state 163


state 145

    (91) stack_isEmpty -> ISEMPTY LPAREN . RPAREN

    RPAREN          shift and go to state 164


state 146

    (93) stack_push -> PUSH LPAREN . ID RPAREN

    ID              shift and go to state 165


state 147

    (92) stack_pop -> POP LPAREN . RPAREN

    RPAREN          shift and go to state 166


state 148

    (95) stack_size -> SIZE LPAREN . RPAREN

    RPAREN          shift and go to state 167


state 149

    (30) for -> FOR LPAREN ID IN . ID RPAREN LCURL morelines RCURL

    ID              shift and go to state 168


state 150

    (62) if -> IF LPAREN condicion RPAREN . LCURL morelines RCURL
    (63) if -> IF LPAREN condicion RPAREN . LCURL morelines RCURL else

    LCURL           shift and go to state 169


state 151

    (99) while -> WHILE DOTS LPAREN ID . opR TINT RPAREN LCURL morelines RCURL
    (73) opR -> . LANGLE
    (74) opR -> . RANGLE
    (75) opR -> . LE
    (76) opR -> . GE
    (77) opR -> . EXCL_EQ
    (78) opR -> . EXCL_EQEQ
    (79) opR -> . AS_SAFE
    (80) opR -> . EQEQ
    (81) opR -> . EQEQEQ

    LANGLE          shift and go to state 67
    RANGLE          shift and go to state 68
    LE              shift and go to state 69
    GE              shift and go to state 70
    EXCL_EQ         shift and go to state 71
    EXCL_EQEQ       shift and go to state 72
    AS_SAFE         shift and go to state 73
    EQEQ            shift and go to state 74
    EQEQEQ          shift and go to state 75

    opR                            shift and go to state 170

state 152

    (83) def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .

    SEMICOLON       reduce using rule 83 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)
    EQUAL           reduce using rule 83 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)


state 153

    (82) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL . instance_arraylist
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN

    ARRAYLIST       shift and go to state 39

    instance_arraylist             shift and go to state 171

state 154

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE . OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    OBJECT          shift and go to state 172


state 155

    (29) queue -> VAL ID DOTS QUEUE LANGLE . tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (39) tipoDato -> . TINT
    (40) tipoDato -> . TLONG
    (41) tipoDato -> . TFLOAT
    (42) tipoDato -> . TDOUBLE
    (43) tipoDato -> . TBOOLEAN
    (44) tipoDato -> . TCHAR
    (45) tipoDato -> . TSTRING

    TINT            shift and go to state 99
    TLONG           shift and go to state 100
    TFLOAT          shift and go to state 101
    TDOUBLE         shift and go to state 102
    TBOOLEAN        shift and go to state 103
    TCHAR           shift and go to state 104
    TSTRING         shift and go to state 105

    tipoDato                       shift and go to state 173

state 156

    (37) asignacionSimple -> ID DOTS tipoDato EQUAL valor .

    SEMICOLON       reduce using rule 37 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)


state 157

    (23) queue_add -> ID DOT ADD LPAREN factor . RPAREN

    RPAREN          shift and go to state 174


state 158

    (24) queue_peek -> ID DOT PEEK LPAREN RPAREN .
    (94) stack_peek -> PEEK LPAREN RPAREN .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (queue_peek -> ID DOT PEEK LPAREN RPAREN .)
    SEMICOLON       reduce using rule 24 (queue_peek -> ID DOT PEEK LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 94 (stack_peek -> PEEK LPAREN RPAREN .) ]


state 159

    (26) queue_remove -> ID DOT REMOVE LPAREN RPAREN .

    SEMICOLON       reduce using rule 26 (queue_remove -> ID DOT REMOVE LPAREN RPAREN .)


state 160

    (25) queue_poll -> ID DOT POLL LPAREN RPAREN .

    SEMICOLON       reduce using rule 25 (queue_poll -> ID DOT POLL LPAREN RPAREN .)


state 161

    (96) Lmetod -> FIRST LPAREN RPAREN .

    SEMICOLON       reduce using rule 96 (Lmetod -> FIRST LPAREN RPAREN .)


state 162

    (97) Lmetod -> LAST LPAREN RPAREN .

    SEMICOLON       reduce using rule 97 (Lmetod -> LAST LPAREN RPAREN .)


state 163

    (98) Lmetod -> REMOVEL LPAREN RPAREN .

    SEMICOLON       reduce using rule 98 (Lmetod -> REMOVEL LPAREN RPAREN .)


state 164

    (91) stack_isEmpty -> ISEMPTY LPAREN RPAREN .

    SEMICOLON       reduce using rule 91 (stack_isEmpty -> ISEMPTY LPAREN RPAREN .)


state 165

    (93) stack_push -> PUSH LPAREN ID . RPAREN

    RPAREN          shift and go to state 175


state 166

    (92) stack_pop -> POP LPAREN RPAREN .

    SEMICOLON       reduce using rule 92 (stack_pop -> POP LPAREN RPAREN .)


state 167

    (95) stack_size -> SIZE LPAREN RPAREN .

    SEMICOLON       reduce using rule 95 (stack_size -> SIZE LPAREN RPAREN .)


state 168

    (30) for -> FOR LPAREN ID IN ID . RPAREN LCURL morelines RCURL

    RPAREN          shift and go to state 176


state 169

    (62) if -> IF LPAREN condicion RPAREN LCURL . morelines RCURL
    (63) if -> IF LPAREN condicion RPAREN LCURL . morelines RCURL else
    (31) morelines -> . line
    (32) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    condicion                      shift and go to state 7
    morelines                      shift and go to state 177
    line                           shift and go to state 178
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 170

    (99) while -> WHILE DOTS LPAREN ID opR . TINT RPAREN LCURL morelines RCURL

    TINT            shift and go to state 179


state 171

    (82) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .

    SEMICOLON       reduce using rule 82 (stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .)


state 172

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT . RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 180


state 173

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato . RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 181


state 174

    (23) queue_add -> ID DOT ADD LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 23 (queue_add -> ID DOT ADD LPAREN factor RPAREN .)


state 175

    (93) stack_push -> PUSH LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 93 (stack_push -> PUSH LPAREN ID RPAREN .)


state 176

    (30) for -> FOR LPAREN ID IN ID RPAREN . LCURL morelines RCURL

    LCURL           shift and go to state 182


state 177

    (62) if -> IF LPAREN condicion RPAREN LCURL morelines . RCURL
    (63) if -> IF LPAREN condicion RPAREN LCURL morelines . RCURL else

    RCURL           shift and go to state 183


state 178

    (31) morelines -> line .
    (32) morelines -> line . morelines
    (31) morelines -> . line
    (32) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    RCURL           reduce using rule 31 (morelines -> line .)
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    line                           shift and go to state 178
    morelines                      shift and go to state 184
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    condicion                      shift and go to state 7
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 179

    (99) while -> WHILE DOTS LPAREN ID opR TINT . RPAREN LCURL morelines RCURL

    RPAREN          shift and go to state 185


state 180

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE . EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    EQUAL           shift and go to state 186


state 181

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE . EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    EQUAL           shift and go to state 187


state 182

    (30) for -> FOR LPAREN ID IN ID RPAREN LCURL . morelines RCURL
    (31) morelines -> . line
    (32) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    morelines                      shift and go to state 188
    line                           shift and go to state 178
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    condicion                      shift and go to state 7
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 183

    (62) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .
    (63) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL . else
    (64) else -> . ELSE LCURL line RCURL

    $end            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    EXCL_WS         reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ELSE            shift and go to state 190

    else                           shift and go to state 189

state 184

    (32) morelines -> line morelines .

    RCURL           reduce using rule 32 (morelines -> line morelines .)


state 185

    (99) while -> WHILE DOTS LPAREN ID opR TINT RPAREN . LCURL morelines RCURL

    LCURL           shift and go to state 191


state 186

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL . LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    LINKEDL         shift and go to state 192


state 187

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL . LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    LINKEDL         shift and go to state 193


state 188

    (30) for -> FOR LPAREN ID IN ID RPAREN LCURL morelines . RCURL

    RCURL           shift and go to state 194


state 189

    (63) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .

    $end            reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    PRINT           reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    PRINTLN         reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    VAR             reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    VAL             reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    ID              reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    LPAREN          reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    FOR             reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    IF              reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    WHILE           reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    ARRAYLIST       reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    STACK           reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    EXCL_WS         reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    INT             reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    FLOAT           reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    LONG            reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    CHAR            reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    BOOLEAN         reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    STRING_1        reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    SEMICOLON       reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    RCURL           reduce using rule 63 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)


state 190

    (64) else -> ELSE . LCURL line RCURL

    LCURL           shift and go to state 195


state 191

    (99) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL . morelines RCURL
    (31) morelines -> . line
    (32) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    morelines                      shift and go to state 196
    line                           shift and go to state 178
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    condicion                      shift and go to state 7
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 192

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL . LANGLE OBJECT RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 197


state 193

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL . LANGLE tipoDato RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 198


state 194

    (30) for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .

    $end            reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    EXCL_WS         reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 30 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)


state 195

    (64) else -> ELSE LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (6) line -> . condicion
    (27) impresion -> . PRINT LPAREN expression RPAREN
    (28) impresion -> . PRINTLN LPAREN expression RPAREN
    (33) asignacion -> . keywordVariables asignacionSimple
    (34) asignacion -> . asignacionSimple
    (47) expression -> . expression PLUS term
    (48) expression -> . expression MINUS term
    (49) expression -> . expression TIMES term
    (50) expression -> . expression DIVIDE term
    (51) expression -> . expression MOD term
    (52) expression -> . term
    (16) estructurasControl -> . for
    (17) estructurasControl -> . if
    (18) estructurasControl -> . while
    (7) estructurasDatos -> . queue
    (8) estructurasDatos -> . queue_operations
    (9) estructurasDatos -> . stack
    (10) estructurasDatos -> . stack_actuar
    (11) estructurasDatos -> . instance_arraylist
    (12) estructurasDatos -> . def_estruct_tipoDato
    (13) estructurasDatos -> . lista
    (14) estructurasDatos -> . lsimplem
    (15) estructurasDatos -> .
    (65) condicion -> . condicionL
    (66) condicion -> . condicionR
    (67) condicion -> . condicionN
    (35) keywordVariables -> . VAR
    (36) keywordVariables -> . VAL
    (37) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (38) asignacionSimple -> . ID EQUAL valor
    (53) term -> . factor
    (54) term -> . LPAREN expression RPAREN
    (30) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (63) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (99) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (29) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (19) queue_operations -> . queue_add
    (20) queue_operations -> . queue_peek
    (21) queue_operations -> . queue_remove
    (22) queue_operations -> . queue_poll
    (82) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (85) stack_actuar -> . ID DOT stack_funciones
    (84) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (83) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (100) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (101) lsimplem -> . ID DOT Lmetod
    (68) condicionL -> . term opL term
    (69) condicionR -> . term opR term
    (70) condicionN -> . EXCL_WS term
    (55) factor -> . INT
    (56) factor -> . FLOAT
    (57) factor -> . LONG
    (58) factor -> . CHAR
    (59) factor -> . BOOLEAN
    (60) factor -> . ID
    (61) factor -> . STRING_1
    (23) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (24) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (26) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (25) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 10
    SEMICOLON       reduce using rule 15 (estructurasDatos -> .)
    VAR             shift and go to state 28
    VAL             shift and go to state 29
    ID              shift and go to state 30
    LPAREN          shift and go to state 9
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    ARRAYLIST       shift and go to state 39
    STACK           shift and go to state 40
    EXCL_WS         shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43
    LONG            shift and go to state 44
    CHAR            shift and go to state 45
    BOOLEAN         shift and go to state 46
    STRING_1        shift and go to state 47

    line                           shift and go to state 199
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    condicion                      shift and go to state 7
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    term                           shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    queue                          shift and go to state 17
    queue_operations               shift and go to state 18
    stack                          shift and go to state 19
    stack_actuar                   shift and go to state 20
    instance_arraylist             shift and go to state 21
    def_estruct_tipoDato           shift and go to state 22
    lista                          shift and go to state 23
    lsimplem                       shift and go to state 24
    condicionL                     shift and go to state 25
    condicionR                     shift and go to state 26
    condicionN                     shift and go to state 27
    factor                         shift and go to state 31
    queue_add                      shift and go to state 35
    queue_peek                     shift and go to state 36
    queue_remove                   shift and go to state 37
    queue_poll                     shift and go to state 38

state 196

    (99) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines . RCURL

    RCURL           shift and go to state 200


state 197

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE . OBJECT RANGLE LPAREN RPAREN

    OBJECT          shift and go to state 201


state 198

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE . tipoDato RANGLE LPAREN RPAREN
    (39) tipoDato -> . TINT
    (40) tipoDato -> . TLONG
    (41) tipoDato -> . TFLOAT
    (42) tipoDato -> . TDOUBLE
    (43) tipoDato -> . TBOOLEAN
    (44) tipoDato -> . TCHAR
    (45) tipoDato -> . TSTRING

    TINT            shift and go to state 99
    TLONG           shift and go to state 100
    TFLOAT          shift and go to state 101
    TDOUBLE         shift and go to state 102
    TBOOLEAN        shift and go to state 103
    TCHAR           shift and go to state 104
    TSTRING         shift and go to state 105

    tipoDato                       shift and go to state 202

state 199

    (64) else -> ELSE LCURL line . RCURL

    RCURL           shift and go to state 203


state 200

    (99) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .

    $end            reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    EXCL_WS         reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 99 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)


state 201

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT . RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 204


state 202

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato . RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 205


state 203

    (64) else -> ELSE LCURL line RCURL .

    $end            reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    PRINT           reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    PRINTLN         reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    VAR             reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    VAL             reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    ID              reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    LPAREN          reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    FOR             reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    IF              reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    WHILE           reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    ARRAYLIST       reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    STACK           reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    EXCL_WS         reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    INT             reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    FLOAT           reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    LONG            reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    CHAR            reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    BOOLEAN         reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    STRING_1        reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    SEMICOLON       reduce using rule 64 (else -> ELSE LCURL line RCURL .)
    RCURL           reduce using rule 64 (else -> ELSE LCURL line RCURL .)


state 204

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE . LPAREN RPAREN

    LPAREN          shift and go to state 206


state 205

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE . LPAREN RPAREN

    LPAREN          shift and go to state 207


state 206

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN . RPAREN

    RPAREN          shift and go to state 208


state 207

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN . RPAREN

    RPAREN          shift and go to state 209


state 208

    (100) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN .

    SEMICOLON       reduce using rule 100 (lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN .)


state 209

    (29) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN .

    SEMICOLON       reduce using rule 29 (queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: reduce/reduce conflict in state 158 resolved using rule (queue_peek -> ID DOT PEEK LPAREN RPAREN)
WARNING: rejected rule (stack_peek -> PEEK LPAREN RPAREN) in state 158
WARNING: Rule (stack_peek -> PEEK LPAREN RPAREN) is never reduced
