Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ACTUAL
    ANNOTATION
    ARRAYOF
    ARROW
    AS
    AT_NO_WS
    BREAK
    BY
    CATCH
    CLASS
    COLONCOLON
    COMMA
    COMMENT
    COMPANION
    CONST
    CONSTRUCTOR
    CONTINUE
    CROSSINLINE
    DATA
    DECR
    DECREMENTIN
    DECREMENTONE
    DIVIDEIN
    DO
    DOUBLE_ARROW
    DOUBLE_SEMICOLON
    DYNAMIC
    ENUM
    EXCL_NO_WS
    EXPECT
    EXTERNAL
    FIELD
    FILE
    FINAL
    FINALLY
    FUN
    GET
    HASH
    IMPORT
    INCR
    INCREMENTIN
    INCREMENTONE
    INCREMENTTIMES
    INFIX
    INIT
    INLINE
    INNER
    INTERFACE
    INTERNAL
    IS
    LATEINIT
    LINEBREAK
    LISTOF
    LSQUARE
    MARK_1
    MARK_2
    MODIN
    NOINLINE
    OPEN
    OPERATOR
    OUT
    OVERRIDE
    PACKAGE
    PARAM
    PRIVATE
    PROPERTY
    PROTECTED
    PUBLIC
    QUEST_WS
    RANGE
    RECEIVER
    REIFIED
    RETURN
    RSQUARE
    SEALED
    SET
    SETPARAM
    SINGLE_QUOTE
    SUM
    SUPER
    SUSPEND
    TAILREC
    TEMPLATE
    THIS
    THROW
    TRY
    TYPEOF
    TYPE_ALIAS
    VALUE
    VAL_TIPO_1
    VARARG
    VAR_TIPO_1
    WHEN
    WHERE

Grammar

Rule 0     S' -> line
Rule 1     line -> impresion SEMICOLON
Rule 2     line -> asignacion SEMICOLON
Rule 3     line -> expression
Rule 4     line -> estructurasControl
Rule 5     line -> estructurasDatos SEMICOLON
Rule 6     estructurasDatos -> queue
Rule 7     estructurasDatos -> queue_operations
Rule 8     estructurasDatos -> stack
Rule 9     estructurasDatos -> stack_actuar
Rule 10    estructurasDatos -> instance_arraylist
Rule 11    estructurasDatos -> def_estruct_tipoDato
Rule 12    estructurasDatos -> lista
Rule 13    estructurasDatos -> lsimplem
Rule 14    estructurasDatos -> <empty>
Rule 15    estructurasControl -> for
Rule 16    estructurasControl -> if
Rule 17    estructurasControl -> while
Rule 18    queue_operations -> queue_add
Rule 19    queue_operations -> queue_peek
Rule 20    queue_operations -> queue_remove
Rule 21    queue_operations -> queue_poll
Rule 22    queue_add -> ID DOT ADD LPAREN factor RPAREN
Rule 23    queue_peek -> ID DOT PEEK LPAREN RPAREN
Rule 24    queue_poll -> ID DOT POLL LPAREN RPAREN
Rule 25    queue_remove -> ID DOT REMOVE LPAREN RPAREN
Rule 26    impresion -> PRINT LPAREN expression RPAREN
Rule 27    impresion -> PRINTLN LPAREN expression RPAREN
Rule 28    queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
Rule 29    for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
Rule 30    morelines -> line
Rule 31    morelines -> line morelines
Rule 32    asignacion -> keywordVariables asignacionSimple
Rule 33    asignacion -> asignacionSimple
Rule 34    keywordVariables -> VAR
Rule 35    keywordVariables -> VAL
Rule 36    asignacionSimple -> ID DOTS tipoDato EQUAL valor
Rule 37    asignacionSimple -> ID EQUAL valor
Rule 38    tipoDato -> TINT
Rule 39    tipoDato -> TLONG
Rule 40    tipoDato -> TFLOAT
Rule 41    tipoDato -> TDOUBLE
Rule 42    tipoDato -> TBOOLEAN
Rule 43    tipoDato -> TCHAR
Rule 44    tipoDato -> TSTRING
Rule 45    valor -> expression
Rule 46    expression -> expression PLUS term
Rule 47    expression -> expression MINUS term
Rule 48    expression -> expression TIMES term
Rule 49    expression -> expression DIVIDE term
Rule 50    expression -> expression MOD term
Rule 51    expression -> term
Rule 52    term -> factor
Rule 53    term -> LPAREN expression RPAREN
Rule 54    factor -> INT
Rule 55    factor -> FLOAT
Rule 56    factor -> LONG
Rule 57    factor -> CHAR
Rule 58    factor -> BOOLEAN
Rule 59    factor -> ID
Rule 60    factor -> STRING_1
Rule 61    if -> IF LPAREN condicion RPAREN LCURL morelines RCURL
Rule 62    if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else
Rule 63    else -> ELSE LCURL line RCURL
Rule 64    condicion -> condicionL
Rule 65    condicion -> condicionR
Rule 66    condicion -> condicionN
Rule 67    condicionL -> term opL term
Rule 68    condicionR -> term opR term
Rule 69    condicionN -> EXCL_WS term
Rule 70    opL -> CONJ
Rule 71    opL -> DISJ
Rule 72    opR -> LANGLE
Rule 73    opR -> RANGLE
Rule 74    opR -> LE
Rule 75    opR -> GE
Rule 76    opR -> EXCL_EQ
Rule 77    opR -> EXCL_EQEQ
Rule 78    opR -> AS_SAFE
Rule 79    opR -> EQEQ
Rule 80    opR -> EQEQEQ
Rule 81    stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
Rule 82    def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE
Rule 83    instance_arraylist -> ARRAYLIST LPAREN RPAREN
Rule 84    stack_actuar -> ID DOT stack_funciones
Rule 85    stack_funciones -> stack_isEmpty
Rule 86    stack_funciones -> stack_push
Rule 87    stack_funciones -> stack_pop
Rule 88    stack_funciones -> stack_peek
Rule 89    stack_funciones -> stack_size
Rule 90    stack_isEmpty -> ISEMPTY LPAREN RPAREN
Rule 91    stack_pop -> POP LPAREN RPAREN
Rule 92    stack_push -> PUSH LPAREN ID RPAREN
Rule 93    stack_peek -> PEEK LPAREN RPAREN
Rule 94    stack_size -> SIZE LPAREN RPAREN
Rule 95    Lmetod -> FIRST LPAREN RPAREN
Rule 96    Lmetod -> LAST LPAREN RPAREN
Rule 97    Lmetod -> REMOVEL LPAREN RPAREN
Rule 98    while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
Rule 99    lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
Rule 100   lsimplem -> ID DOT Lmetod

Terminals, with rules where they appear

ABSTRACT             : 
ACTUAL               : 
ADD                  : 22
ANNOTATION           : 
ARRAYLIST            : 83
ARRAYOF              : 
ARROW                : 
AS                   : 
AS_SAFE              : 78
AT_NO_WS             : 
BOOLEAN              : 58
BREAK                : 
BY                   : 
CATCH                : 
CHAR                 : 57
CLASS                : 
COLONCOLON           : 
COMMA                : 
COMMENT              : 
COMPANION            : 
CONJ                 : 70
CONST                : 
CONSTRUCTOR          : 
CONTINUE             : 
CROSSINLINE          : 
DATA                 : 
DECR                 : 
DECREMENTIN          : 
DECREMENTONE         : 
DISJ                 : 71
DIVIDE               : 49
DIVIDEIN             : 
DO                   : 
DOT                  : 22 23 24 25 84 100
DOTS                 : 28 36 81 98 99
DOUBLE_ARROW         : 
DOUBLE_SEMICOLON     : 
DYNAMIC              : 
ELSE                 : 63
ENUM                 : 
EQEQ                 : 79
EQEQEQ               : 80
EQUAL                : 28 36 37 81 99
EXCL_EQ              : 76
EXCL_EQEQ            : 77
EXCL_NO_WS           : 
EXCL_WS              : 69
EXPECT               : 
EXTERNAL             : 
FIELD                : 
FILE                 : 
FINAL                : 
FINALLY              : 
FIRST                : 95
FLOAT                : 55
FOR                  : 29
FUN                  : 
GE                   : 75
GET                  : 
HASH                 : 
ID                   : 22 23 24 25 28 29 29 36 37 59 81 84 92 98 99 100
IF                   : 61 62
IMPORT               : 
IN                   : 29
INCR                 : 
INCREMENTIN          : 
INCREMENTONE         : 
INCREMENTTIMES       : 
INFIX                : 
INIT                 : 
INLINE               : 
INNER                : 
INT                  : 54
INTERFACE            : 
INTERNAL             : 
IS                   : 
ISEMPTY              : 90
LANGLE               : 28 28 72 82 99 99
LAST                 : 96
LATEINIT             : 
LCURL                : 29 61 62 63 98
LE                   : 74
LINEBREAK            : 
LINKEDL              : 28 99 99
LISTOF               : 
LONG                 : 56
LPAREN               : 22 23 24 25 26 27 28 29 53 61 62 83 90 91 92 93 94 95 96 97 98 99
LSQUARE              : 
MARK_1               : 
MARK_2               : 
MINUS                : 47
MOD                  : 50
MODIN                : 
NOINLINE             : 
OBJECT               : 99 99
OPEN                 : 
OPERATOR             : 
OUT                  : 
OVERRIDE             : 
PACKAGE              : 
PARAM                : 
PEEK                 : 23 93
PLUS                 : 46
POLL                 : 24
POP                  : 91
PRINT                : 26
PRINTLN              : 27
PRIVATE              : 
PROPERTY             : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 92
QUEST_WS             : 
QUEUE                : 28
RANGE                : 
RANGLE               : 28 28 73 82 99 99
RCURL                : 29 61 62 63 98
RECEIVER             : 
REIFIED              : 
REMOVE               : 25
REMOVEL              : 97
RETURN               : 
RPAREN               : 22 23 24 25 26 27 28 29 53 61 62 83 90 91 92 93 94 95 96 97 98 99
RSQUARE              : 
SEALED               : 
SEMICOLON            : 1 2 5
SET                  : 
SETPARAM             : 
SINGLE_QUOTE         : 
SIZE                 : 94
STACK                : 82
STRING_1             : 60
SUM                  : 
SUPER                : 
SUSPEND              : 
TAILREC              : 
TBOOLEAN             : 42
TCHAR                : 43
TDOUBLE              : 41
TEMPLATE             : 
TFLOAT               : 40
THIS                 : 
THROW                : 
TIMES                : 48
TINT                 : 38 98
TLONG                : 39
TRY                  : 
TSTRING              : 44
TYPEOF               : 
TYPE_ALIAS           : 
VAL                  : 28 35
VALUE                : 
VAL_TIPO_1           : 
VAR                  : 34
VARARG               : 
VAR_TIPO_1           : 
WHEN                 : 
WHERE                : 
WHILE                : 98
error                : 

Nonterminals, with rules where they appear

Lmetod               : 100
asignacion           : 2
asignacionSimple     : 32 33
condicion            : 61 62
condicionL           : 64
condicionN           : 66
condicionR           : 65
def_estruct_tipoDato : 11 81
else                 : 62
estructurasControl   : 4
estructurasDatos     : 5
expression           : 3 26 27 45 46 47 48 49 50 53
factor               : 22 52
for                  : 15
if                   : 16
impresion            : 1
instance_arraylist   : 10 81
keywordVariables     : 32 81 99
line                 : 30 31 63 0
lista                : 12
lsimplem             : 13
morelines            : 29 31 61 62 98
opL                  : 67
opR                  : 68 98
queue                : 6
queue_add            : 18
queue_operations     : 7
queue_peek           : 19
queue_poll           : 21
queue_remove         : 20
stack                : 8
stack_actuar         : 9
stack_funciones      : 84
stack_isEmpty        : 85
stack_peek           : 88
stack_pop            : 87
stack_push           : 86
stack_size           : 89
term                 : 46 47 48 49 50 51 67 67 68 68 69
tipoDato             : 28 28 36 82
valor                : 36 37
while                : 17

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    line                           shift and go to state 1
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 1

    (0) S' -> line .



state 2

    (1) line -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 43


state 3

    (2) line -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 44


state 4

    (3) line -> expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term
    (48) expression -> expression . TIMES term
    (49) expression -> expression . DIVIDE term
    (50) expression -> expression . MOD term

    $end            reduce using rule 3 (line -> expression .)
    PRINT           reduce using rule 3 (line -> expression .)
    PRINTLN         reduce using rule 3 (line -> expression .)
    VAR             reduce using rule 3 (line -> expression .)
    VAL             reduce using rule 3 (line -> expression .)
    ID              reduce using rule 3 (line -> expression .)
    LPAREN          reduce using rule 3 (line -> expression .)
    FOR             reduce using rule 3 (line -> expression .)
    IF              reduce using rule 3 (line -> expression .)
    WHILE           reduce using rule 3 (line -> expression .)
    ARRAYLIST       reduce using rule 3 (line -> expression .)
    STACK           reduce using rule 3 (line -> expression .)
    INT             reduce using rule 3 (line -> expression .)
    FLOAT           reduce using rule 3 (line -> expression .)
    LONG            reduce using rule 3 (line -> expression .)
    CHAR            reduce using rule 3 (line -> expression .)
    BOOLEAN         reduce using rule 3 (line -> expression .)
    STRING_1        reduce using rule 3 (line -> expression .)
    SEMICOLON       reduce using rule 3 (line -> expression .)
    RCURL           reduce using rule 3 (line -> expression .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 5

    (4) line -> estructurasControl .

    $end            reduce using rule 4 (line -> estructurasControl .)
    PRINT           reduce using rule 4 (line -> estructurasControl .)
    PRINTLN         reduce using rule 4 (line -> estructurasControl .)
    VAR             reduce using rule 4 (line -> estructurasControl .)
    VAL             reduce using rule 4 (line -> estructurasControl .)
    ID              reduce using rule 4 (line -> estructurasControl .)
    LPAREN          reduce using rule 4 (line -> estructurasControl .)
    FOR             reduce using rule 4 (line -> estructurasControl .)
    IF              reduce using rule 4 (line -> estructurasControl .)
    WHILE           reduce using rule 4 (line -> estructurasControl .)
    ARRAYLIST       reduce using rule 4 (line -> estructurasControl .)
    STACK           reduce using rule 4 (line -> estructurasControl .)
    INT             reduce using rule 4 (line -> estructurasControl .)
    FLOAT           reduce using rule 4 (line -> estructurasControl .)
    LONG            reduce using rule 4 (line -> estructurasControl .)
    CHAR            reduce using rule 4 (line -> estructurasControl .)
    BOOLEAN         reduce using rule 4 (line -> estructurasControl .)
    STRING_1        reduce using rule 4 (line -> estructurasControl .)
    SEMICOLON       reduce using rule 4 (line -> estructurasControl .)
    RCURL           reduce using rule 4 (line -> estructurasControl .)


state 6

    (5) line -> estructurasDatos . SEMICOLON

    SEMICOLON       shift and go to state 50


state 7

    (26) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 51


state 8

    (53) term -> LPAREN . expression RPAREN
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    expression                     shift and go to state 52
    term                           shift and go to state 12
    factor                         shift and go to state 27

state 9

    (27) impresion -> PRINTLN . LPAREN expression RPAREN

    LPAREN          shift and go to state 54


state 10

    (32) asignacion -> keywordVariables . asignacionSimple
    (81) stack -> keywordVariables . ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (99) lista -> keywordVariables . ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor

    ID              shift and go to state 56

    asignacionSimple               shift and go to state 55

state 11

    (33) asignacion -> asignacionSimple .

    SEMICOLON       reduce using rule 33 (asignacion -> asignacionSimple .)


state 12

    (51) expression -> term .

    PLUS            reduce using rule 51 (expression -> term .)
    MINUS           reduce using rule 51 (expression -> term .)
    TIMES           reduce using rule 51 (expression -> term .)
    DIVIDE          reduce using rule 51 (expression -> term .)
    MOD             reduce using rule 51 (expression -> term .)
    $end            reduce using rule 51 (expression -> term .)
    RPAREN          reduce using rule 51 (expression -> term .)
    SEMICOLON       reduce using rule 51 (expression -> term .)
    PRINT           reduce using rule 51 (expression -> term .)
    PRINTLN         reduce using rule 51 (expression -> term .)
    VAR             reduce using rule 51 (expression -> term .)
    VAL             reduce using rule 51 (expression -> term .)
    ID              reduce using rule 51 (expression -> term .)
    LPAREN          reduce using rule 51 (expression -> term .)
    FOR             reduce using rule 51 (expression -> term .)
    IF              reduce using rule 51 (expression -> term .)
    WHILE           reduce using rule 51 (expression -> term .)
    ARRAYLIST       reduce using rule 51 (expression -> term .)
    STACK           reduce using rule 51 (expression -> term .)
    INT             reduce using rule 51 (expression -> term .)
    FLOAT           reduce using rule 51 (expression -> term .)
    LONG            reduce using rule 51 (expression -> term .)
    CHAR            reduce using rule 51 (expression -> term .)
    BOOLEAN         reduce using rule 51 (expression -> term .)
    STRING_1        reduce using rule 51 (expression -> term .)
    RCURL           reduce using rule 51 (expression -> term .)


state 13

    (15) estructurasControl -> for .

    $end            reduce using rule 15 (estructurasControl -> for .)
    PRINT           reduce using rule 15 (estructurasControl -> for .)
    PRINTLN         reduce using rule 15 (estructurasControl -> for .)
    VAR             reduce using rule 15 (estructurasControl -> for .)
    VAL             reduce using rule 15 (estructurasControl -> for .)
    ID              reduce using rule 15 (estructurasControl -> for .)
    LPAREN          reduce using rule 15 (estructurasControl -> for .)
    FOR             reduce using rule 15 (estructurasControl -> for .)
    IF              reduce using rule 15 (estructurasControl -> for .)
    WHILE           reduce using rule 15 (estructurasControl -> for .)
    ARRAYLIST       reduce using rule 15 (estructurasControl -> for .)
    STACK           reduce using rule 15 (estructurasControl -> for .)
    INT             reduce using rule 15 (estructurasControl -> for .)
    FLOAT           reduce using rule 15 (estructurasControl -> for .)
    LONG            reduce using rule 15 (estructurasControl -> for .)
    CHAR            reduce using rule 15 (estructurasControl -> for .)
    BOOLEAN         reduce using rule 15 (estructurasControl -> for .)
    STRING_1        reduce using rule 15 (estructurasControl -> for .)
    SEMICOLON       reduce using rule 15 (estructurasControl -> for .)
    RCURL           reduce using rule 15 (estructurasControl -> for .)


state 14

    (16) estructurasControl -> if .

    $end            reduce using rule 16 (estructurasControl -> if .)
    PRINT           reduce using rule 16 (estructurasControl -> if .)
    PRINTLN         reduce using rule 16 (estructurasControl -> if .)
    VAR             reduce using rule 16 (estructurasControl -> if .)
    VAL             reduce using rule 16 (estructurasControl -> if .)
    ID              reduce using rule 16 (estructurasControl -> if .)
    LPAREN          reduce using rule 16 (estructurasControl -> if .)
    FOR             reduce using rule 16 (estructurasControl -> if .)
    IF              reduce using rule 16 (estructurasControl -> if .)
    WHILE           reduce using rule 16 (estructurasControl -> if .)
    ARRAYLIST       reduce using rule 16 (estructurasControl -> if .)
    STACK           reduce using rule 16 (estructurasControl -> if .)
    INT             reduce using rule 16 (estructurasControl -> if .)
    FLOAT           reduce using rule 16 (estructurasControl -> if .)
    LONG            reduce using rule 16 (estructurasControl -> if .)
    CHAR            reduce using rule 16 (estructurasControl -> if .)
    BOOLEAN         reduce using rule 16 (estructurasControl -> if .)
    STRING_1        reduce using rule 16 (estructurasControl -> if .)
    SEMICOLON       reduce using rule 16 (estructurasControl -> if .)
    RCURL           reduce using rule 16 (estructurasControl -> if .)


state 15

    (17) estructurasControl -> while .

    $end            reduce using rule 17 (estructurasControl -> while .)
    PRINT           reduce using rule 17 (estructurasControl -> while .)
    PRINTLN         reduce using rule 17 (estructurasControl -> while .)
    VAR             reduce using rule 17 (estructurasControl -> while .)
    VAL             reduce using rule 17 (estructurasControl -> while .)
    ID              reduce using rule 17 (estructurasControl -> while .)
    LPAREN          reduce using rule 17 (estructurasControl -> while .)
    FOR             reduce using rule 17 (estructurasControl -> while .)
    IF              reduce using rule 17 (estructurasControl -> while .)
    WHILE           reduce using rule 17 (estructurasControl -> while .)
    ARRAYLIST       reduce using rule 17 (estructurasControl -> while .)
    STACK           reduce using rule 17 (estructurasControl -> while .)
    INT             reduce using rule 17 (estructurasControl -> while .)
    FLOAT           reduce using rule 17 (estructurasControl -> while .)
    LONG            reduce using rule 17 (estructurasControl -> while .)
    CHAR            reduce using rule 17 (estructurasControl -> while .)
    BOOLEAN         reduce using rule 17 (estructurasControl -> while .)
    STRING_1        reduce using rule 17 (estructurasControl -> while .)
    SEMICOLON       reduce using rule 17 (estructurasControl -> while .)
    RCURL           reduce using rule 17 (estructurasControl -> while .)


state 16

    (6) estructurasDatos -> queue .

    SEMICOLON       reduce using rule 6 (estructurasDatos -> queue .)


state 17

    (7) estructurasDatos -> queue_operations .

    SEMICOLON       reduce using rule 7 (estructurasDatos -> queue_operations .)


state 18

    (8) estructurasDatos -> stack .

    SEMICOLON       reduce using rule 8 (estructurasDatos -> stack .)


state 19

    (9) estructurasDatos -> stack_actuar .

    SEMICOLON       reduce using rule 9 (estructurasDatos -> stack_actuar .)


state 20

    (10) estructurasDatos -> instance_arraylist .

    SEMICOLON       reduce using rule 10 (estructurasDatos -> instance_arraylist .)


state 21

    (11) estructurasDatos -> def_estruct_tipoDato .

    SEMICOLON       reduce using rule 11 (estructurasDatos -> def_estruct_tipoDato .)


state 22

    (12) estructurasDatos -> lista .

    SEMICOLON       reduce using rule 12 (estructurasDatos -> lista .)


state 23

    (13) estructurasDatos -> lsimplem .

    SEMICOLON       reduce using rule 13 (estructurasDatos -> lsimplem .)


state 24

    (34) keywordVariables -> VAR .

    ID              reduce using rule 34 (keywordVariables -> VAR .)


state 25

    (35) keywordVariables -> VAL .
    (28) queue -> VAL . ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 57

  ! ID              [ reduce using rule 35 (keywordVariables -> VAL .) ]


state 26

    (36) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> ID . EQUAL valor
    (84) stack_actuar -> ID . DOT stack_funciones
    (100) lsimplem -> ID . DOT Lmetod
    (59) factor -> ID .
    (22) queue_add -> ID . DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> ID . DOT PEEK LPAREN RPAREN
    (25) queue_remove -> ID . DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> ID . DOT POLL LPAREN RPAREN

    DOTS            shift and go to state 58
    EQUAL           shift and go to state 59
    DOT             shift and go to state 60
    PLUS            reduce using rule 59 (factor -> ID .)
    MINUS           reduce using rule 59 (factor -> ID .)
    TIMES           reduce using rule 59 (factor -> ID .)
    DIVIDE          reduce using rule 59 (factor -> ID .)
    MOD             reduce using rule 59 (factor -> ID .)
    $end            reduce using rule 59 (factor -> ID .)
    PRINT           reduce using rule 59 (factor -> ID .)
    PRINTLN         reduce using rule 59 (factor -> ID .)
    VAR             reduce using rule 59 (factor -> ID .)
    VAL             reduce using rule 59 (factor -> ID .)
    ID              reduce using rule 59 (factor -> ID .)
    LPAREN          reduce using rule 59 (factor -> ID .)
    FOR             reduce using rule 59 (factor -> ID .)
    IF              reduce using rule 59 (factor -> ID .)
    WHILE           reduce using rule 59 (factor -> ID .)
    ARRAYLIST       reduce using rule 59 (factor -> ID .)
    STACK           reduce using rule 59 (factor -> ID .)
    INT             reduce using rule 59 (factor -> ID .)
    FLOAT           reduce using rule 59 (factor -> ID .)
    LONG            reduce using rule 59 (factor -> ID .)
    CHAR            reduce using rule 59 (factor -> ID .)
    BOOLEAN         reduce using rule 59 (factor -> ID .)
    STRING_1        reduce using rule 59 (factor -> ID .)
    SEMICOLON       reduce using rule 59 (factor -> ID .)
    RCURL           reduce using rule 59 (factor -> ID .)


state 27

    (52) term -> factor .

    PLUS            reduce using rule 52 (term -> factor .)
    MINUS           reduce using rule 52 (term -> factor .)
    TIMES           reduce using rule 52 (term -> factor .)
    DIVIDE          reduce using rule 52 (term -> factor .)
    MOD             reduce using rule 52 (term -> factor .)
    $end            reduce using rule 52 (term -> factor .)
    RPAREN          reduce using rule 52 (term -> factor .)
    SEMICOLON       reduce using rule 52 (term -> factor .)
    PRINT           reduce using rule 52 (term -> factor .)
    PRINTLN         reduce using rule 52 (term -> factor .)
    VAR             reduce using rule 52 (term -> factor .)
    VAL             reduce using rule 52 (term -> factor .)
    ID              reduce using rule 52 (term -> factor .)
    LPAREN          reduce using rule 52 (term -> factor .)
    FOR             reduce using rule 52 (term -> factor .)
    IF              reduce using rule 52 (term -> factor .)
    WHILE           reduce using rule 52 (term -> factor .)
    ARRAYLIST       reduce using rule 52 (term -> factor .)
    STACK           reduce using rule 52 (term -> factor .)
    INT             reduce using rule 52 (term -> factor .)
    FLOAT           reduce using rule 52 (term -> factor .)
    LONG            reduce using rule 52 (term -> factor .)
    CHAR            reduce using rule 52 (term -> factor .)
    BOOLEAN         reduce using rule 52 (term -> factor .)
    STRING_1        reduce using rule 52 (term -> factor .)
    RCURL           reduce using rule 52 (term -> factor .)
    CONJ            reduce using rule 52 (term -> factor .)
    DISJ            reduce using rule 52 (term -> factor .)
    LANGLE          reduce using rule 52 (term -> factor .)
    RANGLE          reduce using rule 52 (term -> factor .)
    LE              reduce using rule 52 (term -> factor .)
    GE              reduce using rule 52 (term -> factor .)
    EXCL_EQ         reduce using rule 52 (term -> factor .)
    EXCL_EQEQ       reduce using rule 52 (term -> factor .)
    AS_SAFE         reduce using rule 52 (term -> factor .)
    EQEQ            reduce using rule 52 (term -> factor .)
    EQEQEQ          reduce using rule 52 (term -> factor .)


state 28

    (29) for -> FOR . LPAREN ID IN ID RPAREN LCURL morelines RCURL

    LPAREN          shift and go to state 61


state 29

    (61) if -> IF . LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> IF . LPAREN condicion RPAREN LCURL morelines RCURL else

    LPAREN          shift and go to state 62


state 30

    (98) while -> WHILE . DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL

    DOTS            shift and go to state 63


state 31

    (18) queue_operations -> queue_add .

    SEMICOLON       reduce using rule 18 (queue_operations -> queue_add .)


state 32

    (19) queue_operations -> queue_peek .

    SEMICOLON       reduce using rule 19 (queue_operations -> queue_peek .)


state 33

    (20) queue_operations -> queue_remove .

    SEMICOLON       reduce using rule 20 (queue_operations -> queue_remove .)


state 34

    (21) queue_operations -> queue_poll .

    SEMICOLON       reduce using rule 21 (queue_operations -> queue_poll .)


state 35

    (83) instance_arraylist -> ARRAYLIST . LPAREN RPAREN

    LPAREN          shift and go to state 64


state 36

    (82) def_estruct_tipoDato -> STACK . LANGLE tipoDato RANGLE

    LANGLE          shift and go to state 65


state 37

    (54) factor -> INT .

    PLUS            reduce using rule 54 (factor -> INT .)
    MINUS           reduce using rule 54 (factor -> INT .)
    TIMES           reduce using rule 54 (factor -> INT .)
    DIVIDE          reduce using rule 54 (factor -> INT .)
    MOD             reduce using rule 54 (factor -> INT .)
    $end            reduce using rule 54 (factor -> INT .)
    RPAREN          reduce using rule 54 (factor -> INT .)
    SEMICOLON       reduce using rule 54 (factor -> INT .)
    PRINT           reduce using rule 54 (factor -> INT .)
    PRINTLN         reduce using rule 54 (factor -> INT .)
    VAR             reduce using rule 54 (factor -> INT .)
    VAL             reduce using rule 54 (factor -> INT .)
    ID              reduce using rule 54 (factor -> INT .)
    LPAREN          reduce using rule 54 (factor -> INT .)
    FOR             reduce using rule 54 (factor -> INT .)
    IF              reduce using rule 54 (factor -> INT .)
    WHILE           reduce using rule 54 (factor -> INT .)
    ARRAYLIST       reduce using rule 54 (factor -> INT .)
    STACK           reduce using rule 54 (factor -> INT .)
    INT             reduce using rule 54 (factor -> INT .)
    FLOAT           reduce using rule 54 (factor -> INT .)
    LONG            reduce using rule 54 (factor -> INT .)
    CHAR            reduce using rule 54 (factor -> INT .)
    BOOLEAN         reduce using rule 54 (factor -> INT .)
    STRING_1        reduce using rule 54 (factor -> INT .)
    RCURL           reduce using rule 54 (factor -> INT .)
    CONJ            reduce using rule 54 (factor -> INT .)
    DISJ            reduce using rule 54 (factor -> INT .)
    LANGLE          reduce using rule 54 (factor -> INT .)
    RANGLE          reduce using rule 54 (factor -> INT .)
    LE              reduce using rule 54 (factor -> INT .)
    GE              reduce using rule 54 (factor -> INT .)
    EXCL_EQ         reduce using rule 54 (factor -> INT .)
    EXCL_EQEQ       reduce using rule 54 (factor -> INT .)
    AS_SAFE         reduce using rule 54 (factor -> INT .)
    EQEQ            reduce using rule 54 (factor -> INT .)
    EQEQEQ          reduce using rule 54 (factor -> INT .)


state 38

    (55) factor -> FLOAT .

    PLUS            reduce using rule 55 (factor -> FLOAT .)
    MINUS           reduce using rule 55 (factor -> FLOAT .)
    TIMES           reduce using rule 55 (factor -> FLOAT .)
    DIVIDE          reduce using rule 55 (factor -> FLOAT .)
    MOD             reduce using rule 55 (factor -> FLOAT .)
    $end            reduce using rule 55 (factor -> FLOAT .)
    RPAREN          reduce using rule 55 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 55 (factor -> FLOAT .)
    PRINT           reduce using rule 55 (factor -> FLOAT .)
    PRINTLN         reduce using rule 55 (factor -> FLOAT .)
    VAR             reduce using rule 55 (factor -> FLOAT .)
    VAL             reduce using rule 55 (factor -> FLOAT .)
    ID              reduce using rule 55 (factor -> FLOAT .)
    LPAREN          reduce using rule 55 (factor -> FLOAT .)
    FOR             reduce using rule 55 (factor -> FLOAT .)
    IF              reduce using rule 55 (factor -> FLOAT .)
    WHILE           reduce using rule 55 (factor -> FLOAT .)
    ARRAYLIST       reduce using rule 55 (factor -> FLOAT .)
    STACK           reduce using rule 55 (factor -> FLOAT .)
    INT             reduce using rule 55 (factor -> FLOAT .)
    FLOAT           reduce using rule 55 (factor -> FLOAT .)
    LONG            reduce using rule 55 (factor -> FLOAT .)
    CHAR            reduce using rule 55 (factor -> FLOAT .)
    BOOLEAN         reduce using rule 55 (factor -> FLOAT .)
    STRING_1        reduce using rule 55 (factor -> FLOAT .)
    RCURL           reduce using rule 55 (factor -> FLOAT .)
    CONJ            reduce using rule 55 (factor -> FLOAT .)
    DISJ            reduce using rule 55 (factor -> FLOAT .)
    LANGLE          reduce using rule 55 (factor -> FLOAT .)
    RANGLE          reduce using rule 55 (factor -> FLOAT .)
    LE              reduce using rule 55 (factor -> FLOAT .)
    GE              reduce using rule 55 (factor -> FLOAT .)
    EXCL_EQ         reduce using rule 55 (factor -> FLOAT .)
    EXCL_EQEQ       reduce using rule 55 (factor -> FLOAT .)
    AS_SAFE         reduce using rule 55 (factor -> FLOAT .)
    EQEQ            reduce using rule 55 (factor -> FLOAT .)
    EQEQEQ          reduce using rule 55 (factor -> FLOAT .)


state 39

    (56) factor -> LONG .

    PLUS            reduce using rule 56 (factor -> LONG .)
    MINUS           reduce using rule 56 (factor -> LONG .)
    TIMES           reduce using rule 56 (factor -> LONG .)
    DIVIDE          reduce using rule 56 (factor -> LONG .)
    MOD             reduce using rule 56 (factor -> LONG .)
    $end            reduce using rule 56 (factor -> LONG .)
    RPAREN          reduce using rule 56 (factor -> LONG .)
    SEMICOLON       reduce using rule 56 (factor -> LONG .)
    PRINT           reduce using rule 56 (factor -> LONG .)
    PRINTLN         reduce using rule 56 (factor -> LONG .)
    VAR             reduce using rule 56 (factor -> LONG .)
    VAL             reduce using rule 56 (factor -> LONG .)
    ID              reduce using rule 56 (factor -> LONG .)
    LPAREN          reduce using rule 56 (factor -> LONG .)
    FOR             reduce using rule 56 (factor -> LONG .)
    IF              reduce using rule 56 (factor -> LONG .)
    WHILE           reduce using rule 56 (factor -> LONG .)
    ARRAYLIST       reduce using rule 56 (factor -> LONG .)
    STACK           reduce using rule 56 (factor -> LONG .)
    INT             reduce using rule 56 (factor -> LONG .)
    FLOAT           reduce using rule 56 (factor -> LONG .)
    LONG            reduce using rule 56 (factor -> LONG .)
    CHAR            reduce using rule 56 (factor -> LONG .)
    BOOLEAN         reduce using rule 56 (factor -> LONG .)
    STRING_1        reduce using rule 56 (factor -> LONG .)
    RCURL           reduce using rule 56 (factor -> LONG .)
    CONJ            reduce using rule 56 (factor -> LONG .)
    DISJ            reduce using rule 56 (factor -> LONG .)
    LANGLE          reduce using rule 56 (factor -> LONG .)
    RANGLE          reduce using rule 56 (factor -> LONG .)
    LE              reduce using rule 56 (factor -> LONG .)
    GE              reduce using rule 56 (factor -> LONG .)
    EXCL_EQ         reduce using rule 56 (factor -> LONG .)
    EXCL_EQEQ       reduce using rule 56 (factor -> LONG .)
    AS_SAFE         reduce using rule 56 (factor -> LONG .)
    EQEQ            reduce using rule 56 (factor -> LONG .)
    EQEQEQ          reduce using rule 56 (factor -> LONG .)


state 40

    (57) factor -> CHAR .

    PLUS            reduce using rule 57 (factor -> CHAR .)
    MINUS           reduce using rule 57 (factor -> CHAR .)
    TIMES           reduce using rule 57 (factor -> CHAR .)
    DIVIDE          reduce using rule 57 (factor -> CHAR .)
    MOD             reduce using rule 57 (factor -> CHAR .)
    $end            reduce using rule 57 (factor -> CHAR .)
    RPAREN          reduce using rule 57 (factor -> CHAR .)
    SEMICOLON       reduce using rule 57 (factor -> CHAR .)
    PRINT           reduce using rule 57 (factor -> CHAR .)
    PRINTLN         reduce using rule 57 (factor -> CHAR .)
    VAR             reduce using rule 57 (factor -> CHAR .)
    VAL             reduce using rule 57 (factor -> CHAR .)
    ID              reduce using rule 57 (factor -> CHAR .)
    LPAREN          reduce using rule 57 (factor -> CHAR .)
    FOR             reduce using rule 57 (factor -> CHAR .)
    IF              reduce using rule 57 (factor -> CHAR .)
    WHILE           reduce using rule 57 (factor -> CHAR .)
    ARRAYLIST       reduce using rule 57 (factor -> CHAR .)
    STACK           reduce using rule 57 (factor -> CHAR .)
    INT             reduce using rule 57 (factor -> CHAR .)
    FLOAT           reduce using rule 57 (factor -> CHAR .)
    LONG            reduce using rule 57 (factor -> CHAR .)
    CHAR            reduce using rule 57 (factor -> CHAR .)
    BOOLEAN         reduce using rule 57 (factor -> CHAR .)
    STRING_1        reduce using rule 57 (factor -> CHAR .)
    RCURL           reduce using rule 57 (factor -> CHAR .)
    CONJ            reduce using rule 57 (factor -> CHAR .)
    DISJ            reduce using rule 57 (factor -> CHAR .)
    LANGLE          reduce using rule 57 (factor -> CHAR .)
    RANGLE          reduce using rule 57 (factor -> CHAR .)
    LE              reduce using rule 57 (factor -> CHAR .)
    GE              reduce using rule 57 (factor -> CHAR .)
    EXCL_EQ         reduce using rule 57 (factor -> CHAR .)
    EXCL_EQEQ       reduce using rule 57 (factor -> CHAR .)
    AS_SAFE         reduce using rule 57 (factor -> CHAR .)
    EQEQ            reduce using rule 57 (factor -> CHAR .)
    EQEQEQ          reduce using rule 57 (factor -> CHAR .)


state 41

    (58) factor -> BOOLEAN .

    PLUS            reduce using rule 58 (factor -> BOOLEAN .)
    MINUS           reduce using rule 58 (factor -> BOOLEAN .)
    TIMES           reduce using rule 58 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 58 (factor -> BOOLEAN .)
    MOD             reduce using rule 58 (factor -> BOOLEAN .)
    $end            reduce using rule 58 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 58 (factor -> BOOLEAN .)
    SEMICOLON       reduce using rule 58 (factor -> BOOLEAN .)
    PRINT           reduce using rule 58 (factor -> BOOLEAN .)
    PRINTLN         reduce using rule 58 (factor -> BOOLEAN .)
    VAR             reduce using rule 58 (factor -> BOOLEAN .)
    VAL             reduce using rule 58 (factor -> BOOLEAN .)
    ID              reduce using rule 58 (factor -> BOOLEAN .)
    LPAREN          reduce using rule 58 (factor -> BOOLEAN .)
    FOR             reduce using rule 58 (factor -> BOOLEAN .)
    IF              reduce using rule 58 (factor -> BOOLEAN .)
    WHILE           reduce using rule 58 (factor -> BOOLEAN .)
    ARRAYLIST       reduce using rule 58 (factor -> BOOLEAN .)
    STACK           reduce using rule 58 (factor -> BOOLEAN .)
    INT             reduce using rule 58 (factor -> BOOLEAN .)
    FLOAT           reduce using rule 58 (factor -> BOOLEAN .)
    LONG            reduce using rule 58 (factor -> BOOLEAN .)
    CHAR            reduce using rule 58 (factor -> BOOLEAN .)
    BOOLEAN         reduce using rule 58 (factor -> BOOLEAN .)
    STRING_1        reduce using rule 58 (factor -> BOOLEAN .)
    RCURL           reduce using rule 58 (factor -> BOOLEAN .)
    CONJ            reduce using rule 58 (factor -> BOOLEAN .)
    DISJ            reduce using rule 58 (factor -> BOOLEAN .)
    LANGLE          reduce using rule 58 (factor -> BOOLEAN .)
    RANGLE          reduce using rule 58 (factor -> BOOLEAN .)
    LE              reduce using rule 58 (factor -> BOOLEAN .)
    GE              reduce using rule 58 (factor -> BOOLEAN .)
    EXCL_EQ         reduce using rule 58 (factor -> BOOLEAN .)
    EXCL_EQEQ       reduce using rule 58 (factor -> BOOLEAN .)
    AS_SAFE         reduce using rule 58 (factor -> BOOLEAN .)
    EQEQ            reduce using rule 58 (factor -> BOOLEAN .)
    EQEQEQ          reduce using rule 58 (factor -> BOOLEAN .)


state 42

    (60) factor -> STRING_1 .

    PLUS            reduce using rule 60 (factor -> STRING_1 .)
    MINUS           reduce using rule 60 (factor -> STRING_1 .)
    TIMES           reduce using rule 60 (factor -> STRING_1 .)
    DIVIDE          reduce using rule 60 (factor -> STRING_1 .)
    MOD             reduce using rule 60 (factor -> STRING_1 .)
    $end            reduce using rule 60 (factor -> STRING_1 .)
    RPAREN          reduce using rule 60 (factor -> STRING_1 .)
    SEMICOLON       reduce using rule 60 (factor -> STRING_1 .)
    PRINT           reduce using rule 60 (factor -> STRING_1 .)
    PRINTLN         reduce using rule 60 (factor -> STRING_1 .)
    VAR             reduce using rule 60 (factor -> STRING_1 .)
    VAL             reduce using rule 60 (factor -> STRING_1 .)
    ID              reduce using rule 60 (factor -> STRING_1 .)
    LPAREN          reduce using rule 60 (factor -> STRING_1 .)
    FOR             reduce using rule 60 (factor -> STRING_1 .)
    IF              reduce using rule 60 (factor -> STRING_1 .)
    WHILE           reduce using rule 60 (factor -> STRING_1 .)
    ARRAYLIST       reduce using rule 60 (factor -> STRING_1 .)
    STACK           reduce using rule 60 (factor -> STRING_1 .)
    INT             reduce using rule 60 (factor -> STRING_1 .)
    FLOAT           reduce using rule 60 (factor -> STRING_1 .)
    LONG            reduce using rule 60 (factor -> STRING_1 .)
    CHAR            reduce using rule 60 (factor -> STRING_1 .)
    BOOLEAN         reduce using rule 60 (factor -> STRING_1 .)
    STRING_1        reduce using rule 60 (factor -> STRING_1 .)
    RCURL           reduce using rule 60 (factor -> STRING_1 .)
    CONJ            reduce using rule 60 (factor -> STRING_1 .)
    DISJ            reduce using rule 60 (factor -> STRING_1 .)
    LANGLE          reduce using rule 60 (factor -> STRING_1 .)
    RANGLE          reduce using rule 60 (factor -> STRING_1 .)
    LE              reduce using rule 60 (factor -> STRING_1 .)
    GE              reduce using rule 60 (factor -> STRING_1 .)
    EXCL_EQ         reduce using rule 60 (factor -> STRING_1 .)
    EXCL_EQEQ       reduce using rule 60 (factor -> STRING_1 .)
    AS_SAFE         reduce using rule 60 (factor -> STRING_1 .)
    EQEQ            reduce using rule 60 (factor -> STRING_1 .)
    EQEQEQ          reduce using rule 60 (factor -> STRING_1 .)


state 43

    (1) line -> impresion SEMICOLON .

    $end            reduce using rule 1 (line -> impresion SEMICOLON .)
    PRINT           reduce using rule 1 (line -> impresion SEMICOLON .)
    PRINTLN         reduce using rule 1 (line -> impresion SEMICOLON .)
    VAR             reduce using rule 1 (line -> impresion SEMICOLON .)
    VAL             reduce using rule 1 (line -> impresion SEMICOLON .)
    ID              reduce using rule 1 (line -> impresion SEMICOLON .)
    LPAREN          reduce using rule 1 (line -> impresion SEMICOLON .)
    FOR             reduce using rule 1 (line -> impresion SEMICOLON .)
    IF              reduce using rule 1 (line -> impresion SEMICOLON .)
    WHILE           reduce using rule 1 (line -> impresion SEMICOLON .)
    ARRAYLIST       reduce using rule 1 (line -> impresion SEMICOLON .)
    STACK           reduce using rule 1 (line -> impresion SEMICOLON .)
    INT             reduce using rule 1 (line -> impresion SEMICOLON .)
    FLOAT           reduce using rule 1 (line -> impresion SEMICOLON .)
    LONG            reduce using rule 1 (line -> impresion SEMICOLON .)
    CHAR            reduce using rule 1 (line -> impresion SEMICOLON .)
    BOOLEAN         reduce using rule 1 (line -> impresion SEMICOLON .)
    STRING_1        reduce using rule 1 (line -> impresion SEMICOLON .)
    SEMICOLON       reduce using rule 1 (line -> impresion SEMICOLON .)
    RCURL           reduce using rule 1 (line -> impresion SEMICOLON .)


state 44

    (2) line -> asignacion SEMICOLON .

    $end            reduce using rule 2 (line -> asignacion SEMICOLON .)
    PRINT           reduce using rule 2 (line -> asignacion SEMICOLON .)
    PRINTLN         reduce using rule 2 (line -> asignacion SEMICOLON .)
    VAR             reduce using rule 2 (line -> asignacion SEMICOLON .)
    VAL             reduce using rule 2 (line -> asignacion SEMICOLON .)
    ID              reduce using rule 2 (line -> asignacion SEMICOLON .)
    LPAREN          reduce using rule 2 (line -> asignacion SEMICOLON .)
    FOR             reduce using rule 2 (line -> asignacion SEMICOLON .)
    IF              reduce using rule 2 (line -> asignacion SEMICOLON .)
    WHILE           reduce using rule 2 (line -> asignacion SEMICOLON .)
    ARRAYLIST       reduce using rule 2 (line -> asignacion SEMICOLON .)
    STACK           reduce using rule 2 (line -> asignacion SEMICOLON .)
    INT             reduce using rule 2 (line -> asignacion SEMICOLON .)
    FLOAT           reduce using rule 2 (line -> asignacion SEMICOLON .)
    LONG            reduce using rule 2 (line -> asignacion SEMICOLON .)
    CHAR            reduce using rule 2 (line -> asignacion SEMICOLON .)
    BOOLEAN         reduce using rule 2 (line -> asignacion SEMICOLON .)
    STRING_1        reduce using rule 2 (line -> asignacion SEMICOLON .)
    SEMICOLON       reduce using rule 2 (line -> asignacion SEMICOLON .)
    RCURL           reduce using rule 2 (line -> asignacion SEMICOLON .)


state 45

    (46) expression -> expression PLUS . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 66
    factor                         shift and go to state 27

state 46

    (47) expression -> expression MINUS . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 67
    factor                         shift and go to state 27

state 47

    (48) expression -> expression TIMES . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 68
    factor                         shift and go to state 27

state 48

    (49) expression -> expression DIVIDE . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 69
    factor                         shift and go to state 27

state 49

    (50) expression -> expression MOD . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 70
    factor                         shift and go to state 27

state 50

    (5) line -> estructurasDatos SEMICOLON .

    $end            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    PRINT           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    PRINTLN         reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    VAR             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    VAL             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    ID              reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    LPAREN          reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    FOR             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    IF              reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    WHILE           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    ARRAYLIST       reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    STACK           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    INT             reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    FLOAT           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    LONG            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    CHAR            reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    BOOLEAN         reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    STRING_1        reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    SEMICOLON       reduce using rule 5 (line -> estructurasDatos SEMICOLON .)
    RCURL           reduce using rule 5 (line -> estructurasDatos SEMICOLON .)


state 51

    (26) impresion -> PRINT LPAREN . expression RPAREN
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    expression                     shift and go to state 71
    term                           shift and go to state 12
    factor                         shift and go to state 27

state 52

    (53) term -> LPAREN expression . RPAREN
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term
    (48) expression -> expression . TIMES term
    (49) expression -> expression . DIVIDE term
    (50) expression -> expression . MOD term

    RPAREN          shift and go to state 72
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 53

    (59) factor -> ID .

    RPAREN          reduce using rule 59 (factor -> ID .)
    PLUS            reduce using rule 59 (factor -> ID .)
    MINUS           reduce using rule 59 (factor -> ID .)
    TIMES           reduce using rule 59 (factor -> ID .)
    DIVIDE          reduce using rule 59 (factor -> ID .)
    MOD             reduce using rule 59 (factor -> ID .)
    $end            reduce using rule 59 (factor -> ID .)
    SEMICOLON       reduce using rule 59 (factor -> ID .)
    PRINT           reduce using rule 59 (factor -> ID .)
    PRINTLN         reduce using rule 59 (factor -> ID .)
    VAR             reduce using rule 59 (factor -> ID .)
    VAL             reduce using rule 59 (factor -> ID .)
    ID              reduce using rule 59 (factor -> ID .)
    LPAREN          reduce using rule 59 (factor -> ID .)
    FOR             reduce using rule 59 (factor -> ID .)
    IF              reduce using rule 59 (factor -> ID .)
    WHILE           reduce using rule 59 (factor -> ID .)
    ARRAYLIST       reduce using rule 59 (factor -> ID .)
    STACK           reduce using rule 59 (factor -> ID .)
    INT             reduce using rule 59 (factor -> ID .)
    FLOAT           reduce using rule 59 (factor -> ID .)
    LONG            reduce using rule 59 (factor -> ID .)
    CHAR            reduce using rule 59 (factor -> ID .)
    BOOLEAN         reduce using rule 59 (factor -> ID .)
    STRING_1        reduce using rule 59 (factor -> ID .)
    RCURL           reduce using rule 59 (factor -> ID .)
    CONJ            reduce using rule 59 (factor -> ID .)
    DISJ            reduce using rule 59 (factor -> ID .)
    LANGLE          reduce using rule 59 (factor -> ID .)
    RANGLE          reduce using rule 59 (factor -> ID .)
    LE              reduce using rule 59 (factor -> ID .)
    GE              reduce using rule 59 (factor -> ID .)
    EXCL_EQ         reduce using rule 59 (factor -> ID .)
    EXCL_EQEQ       reduce using rule 59 (factor -> ID .)
    AS_SAFE         reduce using rule 59 (factor -> ID .)
    EQEQ            reduce using rule 59 (factor -> ID .)
    EQEQEQ          reduce using rule 59 (factor -> ID .)


state 54

    (27) impresion -> PRINTLN LPAREN . expression RPAREN
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    expression                     shift and go to state 73
    term                           shift and go to state 12
    factor                         shift and go to state 27

state 55

    (32) asignacion -> keywordVariables asignacionSimple .

    SEMICOLON       reduce using rule 32 (asignacion -> keywordVariables asignacionSimple .)


state 56

    (81) stack -> keywordVariables ID . DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (99) lista -> keywordVariables ID . DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (36) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> ID . EQUAL valor

    DOTS            shift and go to state 74
    EQUAL           shift and go to state 59


state 57

    (28) queue -> VAL ID . DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    DOTS            shift and go to state 75


state 58

    (36) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (38) tipoDato -> . TINT
    (39) tipoDato -> . TLONG
    (40) tipoDato -> . TFLOAT
    (41) tipoDato -> . TDOUBLE
    (42) tipoDato -> . TBOOLEAN
    (43) tipoDato -> . TCHAR
    (44) tipoDato -> . TSTRING

    TINT            shift and go to state 77
    TLONG           shift and go to state 78
    TFLOAT          shift and go to state 79
    TDOUBLE         shift and go to state 80
    TBOOLEAN        shift and go to state 81
    TCHAR           shift and go to state 82
    TSTRING         shift and go to state 83

    tipoDato                       shift and go to state 76

state 59

    (37) asignacionSimple -> ID EQUAL . valor
    (45) valor -> . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    valor                          shift and go to state 84
    expression                     shift and go to state 85
    term                           shift and go to state 12
    factor                         shift and go to state 27

state 60

    (84) stack_actuar -> ID DOT . stack_funciones
    (100) lsimplem -> ID DOT . Lmetod
    (22) queue_add -> ID DOT . ADD LPAREN factor RPAREN
    (23) queue_peek -> ID DOT . PEEK LPAREN RPAREN
    (25) queue_remove -> ID DOT . REMOVE LPAREN RPAREN
    (24) queue_poll -> ID DOT . POLL LPAREN RPAREN
    (85) stack_funciones -> . stack_isEmpty
    (86) stack_funciones -> . stack_push
    (87) stack_funciones -> . stack_pop
    (88) stack_funciones -> . stack_peek
    (89) stack_funciones -> . stack_size
    (95) Lmetod -> . FIRST LPAREN RPAREN
    (96) Lmetod -> . LAST LPAREN RPAREN
    (97) Lmetod -> . REMOVEL LPAREN RPAREN
    (90) stack_isEmpty -> . ISEMPTY LPAREN RPAREN
    (92) stack_push -> . PUSH LPAREN ID RPAREN
    (91) stack_pop -> . POP LPAREN RPAREN
    (93) stack_peek -> . PEEK LPAREN RPAREN
    (94) stack_size -> . SIZE LPAREN RPAREN

    ADD             shift and go to state 88
    PEEK            shift and go to state 89
    REMOVE          shift and go to state 90
    POLL            shift and go to state 91
    FIRST           shift and go to state 97
    LAST            shift and go to state 98
    REMOVEL         shift and go to state 99
    ISEMPTY         shift and go to state 100
    PUSH            shift and go to state 101
    POP             shift and go to state 102
    SIZE            shift and go to state 103

    stack_funciones                shift and go to state 86
    Lmetod                         shift and go to state 87
    stack_isEmpty                  shift and go to state 92
    stack_push                     shift and go to state 93
    stack_pop                      shift and go to state 94
    stack_peek                     shift and go to state 95
    stack_size                     shift and go to state 96

state 61

    (29) for -> FOR LPAREN . ID IN ID RPAREN LCURL morelines RCURL

    ID              shift and go to state 104


state 62

    (61) if -> IF LPAREN . condicion RPAREN LCURL morelines RCURL
    (62) if -> IF LPAREN . condicion RPAREN LCURL morelines RCURL else
    (64) condicion -> . condicionL
    (65) condicion -> . condicionR
    (66) condicion -> . condicionN
    (67) condicionL -> . term opL term
    (68) condicionR -> . term opR term
    (69) condicionN -> . EXCL_WS term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    EXCL_WS         shift and go to state 110
    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    condicion                      shift and go to state 105
    condicionL                     shift and go to state 106
    condicionR                     shift and go to state 107
    condicionN                     shift and go to state 108
    term                           shift and go to state 109
    factor                         shift and go to state 27

state 63

    (98) while -> WHILE DOTS . LPAREN ID opR TINT RPAREN LCURL morelines RCURL

    LPAREN          shift and go to state 111


state 64

    (83) instance_arraylist -> ARRAYLIST LPAREN . RPAREN

    RPAREN          shift and go to state 112


state 65

    (82) def_estruct_tipoDato -> STACK LANGLE . tipoDato RANGLE
    (38) tipoDato -> . TINT
    (39) tipoDato -> . TLONG
    (40) tipoDato -> . TFLOAT
    (41) tipoDato -> . TDOUBLE
    (42) tipoDato -> . TBOOLEAN
    (43) tipoDato -> . TCHAR
    (44) tipoDato -> . TSTRING

    TINT            shift and go to state 77
    TLONG           shift and go to state 78
    TFLOAT          shift and go to state 79
    TDOUBLE         shift and go to state 80
    TBOOLEAN        shift and go to state 81
    TCHAR           shift and go to state 82
    TSTRING         shift and go to state 83

    tipoDato                       shift and go to state 113

state 66

    (46) expression -> expression PLUS term .

    PLUS            reduce using rule 46 (expression -> expression PLUS term .)
    MINUS           reduce using rule 46 (expression -> expression PLUS term .)
    TIMES           reduce using rule 46 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 46 (expression -> expression PLUS term .)
    MOD             reduce using rule 46 (expression -> expression PLUS term .)
    $end            reduce using rule 46 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 46 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 46 (expression -> expression PLUS term .)
    PRINT           reduce using rule 46 (expression -> expression PLUS term .)
    PRINTLN         reduce using rule 46 (expression -> expression PLUS term .)
    VAR             reduce using rule 46 (expression -> expression PLUS term .)
    VAL             reduce using rule 46 (expression -> expression PLUS term .)
    ID              reduce using rule 46 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 46 (expression -> expression PLUS term .)
    FOR             reduce using rule 46 (expression -> expression PLUS term .)
    IF              reduce using rule 46 (expression -> expression PLUS term .)
    WHILE           reduce using rule 46 (expression -> expression PLUS term .)
    ARRAYLIST       reduce using rule 46 (expression -> expression PLUS term .)
    STACK           reduce using rule 46 (expression -> expression PLUS term .)
    INT             reduce using rule 46 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 46 (expression -> expression PLUS term .)
    LONG            reduce using rule 46 (expression -> expression PLUS term .)
    CHAR            reduce using rule 46 (expression -> expression PLUS term .)
    BOOLEAN         reduce using rule 46 (expression -> expression PLUS term .)
    STRING_1        reduce using rule 46 (expression -> expression PLUS term .)
    RCURL           reduce using rule 46 (expression -> expression PLUS term .)


state 67

    (47) expression -> expression MINUS term .

    PLUS            reduce using rule 47 (expression -> expression MINUS term .)
    MINUS           reduce using rule 47 (expression -> expression MINUS term .)
    TIMES           reduce using rule 47 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 47 (expression -> expression MINUS term .)
    MOD             reduce using rule 47 (expression -> expression MINUS term .)
    $end            reduce using rule 47 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 47 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 47 (expression -> expression MINUS term .)
    PRINT           reduce using rule 47 (expression -> expression MINUS term .)
    PRINTLN         reduce using rule 47 (expression -> expression MINUS term .)
    VAR             reduce using rule 47 (expression -> expression MINUS term .)
    VAL             reduce using rule 47 (expression -> expression MINUS term .)
    ID              reduce using rule 47 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 47 (expression -> expression MINUS term .)
    FOR             reduce using rule 47 (expression -> expression MINUS term .)
    IF              reduce using rule 47 (expression -> expression MINUS term .)
    WHILE           reduce using rule 47 (expression -> expression MINUS term .)
    ARRAYLIST       reduce using rule 47 (expression -> expression MINUS term .)
    STACK           reduce using rule 47 (expression -> expression MINUS term .)
    INT             reduce using rule 47 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 47 (expression -> expression MINUS term .)
    LONG            reduce using rule 47 (expression -> expression MINUS term .)
    CHAR            reduce using rule 47 (expression -> expression MINUS term .)
    BOOLEAN         reduce using rule 47 (expression -> expression MINUS term .)
    STRING_1        reduce using rule 47 (expression -> expression MINUS term .)
    RCURL           reduce using rule 47 (expression -> expression MINUS term .)


state 68

    (48) expression -> expression TIMES term .

    PLUS            reduce using rule 48 (expression -> expression TIMES term .)
    MINUS           reduce using rule 48 (expression -> expression TIMES term .)
    TIMES           reduce using rule 48 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 48 (expression -> expression TIMES term .)
    MOD             reduce using rule 48 (expression -> expression TIMES term .)
    $end            reduce using rule 48 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 48 (expression -> expression TIMES term .)
    SEMICOLON       reduce using rule 48 (expression -> expression TIMES term .)
    PRINT           reduce using rule 48 (expression -> expression TIMES term .)
    PRINTLN         reduce using rule 48 (expression -> expression TIMES term .)
    VAR             reduce using rule 48 (expression -> expression TIMES term .)
    VAL             reduce using rule 48 (expression -> expression TIMES term .)
    ID              reduce using rule 48 (expression -> expression TIMES term .)
    LPAREN          reduce using rule 48 (expression -> expression TIMES term .)
    FOR             reduce using rule 48 (expression -> expression TIMES term .)
    IF              reduce using rule 48 (expression -> expression TIMES term .)
    WHILE           reduce using rule 48 (expression -> expression TIMES term .)
    ARRAYLIST       reduce using rule 48 (expression -> expression TIMES term .)
    STACK           reduce using rule 48 (expression -> expression TIMES term .)
    INT             reduce using rule 48 (expression -> expression TIMES term .)
    FLOAT           reduce using rule 48 (expression -> expression TIMES term .)
    LONG            reduce using rule 48 (expression -> expression TIMES term .)
    CHAR            reduce using rule 48 (expression -> expression TIMES term .)
    BOOLEAN         reduce using rule 48 (expression -> expression TIMES term .)
    STRING_1        reduce using rule 48 (expression -> expression TIMES term .)
    RCURL           reduce using rule 48 (expression -> expression TIMES term .)


state 69

    (49) expression -> expression DIVIDE term .

    PLUS            reduce using rule 49 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 49 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 49 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 49 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 49 (expression -> expression DIVIDE term .)
    $end            reduce using rule 49 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 49 (expression -> expression DIVIDE term .)
    SEMICOLON       reduce using rule 49 (expression -> expression DIVIDE term .)
    PRINT           reduce using rule 49 (expression -> expression DIVIDE term .)
    PRINTLN         reduce using rule 49 (expression -> expression DIVIDE term .)
    VAR             reduce using rule 49 (expression -> expression DIVIDE term .)
    VAL             reduce using rule 49 (expression -> expression DIVIDE term .)
    ID              reduce using rule 49 (expression -> expression DIVIDE term .)
    LPAREN          reduce using rule 49 (expression -> expression DIVIDE term .)
    FOR             reduce using rule 49 (expression -> expression DIVIDE term .)
    IF              reduce using rule 49 (expression -> expression DIVIDE term .)
    WHILE           reduce using rule 49 (expression -> expression DIVIDE term .)
    ARRAYLIST       reduce using rule 49 (expression -> expression DIVIDE term .)
    STACK           reduce using rule 49 (expression -> expression DIVIDE term .)
    INT             reduce using rule 49 (expression -> expression DIVIDE term .)
    FLOAT           reduce using rule 49 (expression -> expression DIVIDE term .)
    LONG            reduce using rule 49 (expression -> expression DIVIDE term .)
    CHAR            reduce using rule 49 (expression -> expression DIVIDE term .)
    BOOLEAN         reduce using rule 49 (expression -> expression DIVIDE term .)
    STRING_1        reduce using rule 49 (expression -> expression DIVIDE term .)
    RCURL           reduce using rule 49 (expression -> expression DIVIDE term .)


state 70

    (50) expression -> expression MOD term .

    PLUS            reduce using rule 50 (expression -> expression MOD term .)
    MINUS           reduce using rule 50 (expression -> expression MOD term .)
    TIMES           reduce using rule 50 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 50 (expression -> expression MOD term .)
    MOD             reduce using rule 50 (expression -> expression MOD term .)
    $end            reduce using rule 50 (expression -> expression MOD term .)
    RPAREN          reduce using rule 50 (expression -> expression MOD term .)
    SEMICOLON       reduce using rule 50 (expression -> expression MOD term .)
    PRINT           reduce using rule 50 (expression -> expression MOD term .)
    PRINTLN         reduce using rule 50 (expression -> expression MOD term .)
    VAR             reduce using rule 50 (expression -> expression MOD term .)
    VAL             reduce using rule 50 (expression -> expression MOD term .)
    ID              reduce using rule 50 (expression -> expression MOD term .)
    LPAREN          reduce using rule 50 (expression -> expression MOD term .)
    FOR             reduce using rule 50 (expression -> expression MOD term .)
    IF              reduce using rule 50 (expression -> expression MOD term .)
    WHILE           reduce using rule 50 (expression -> expression MOD term .)
    ARRAYLIST       reduce using rule 50 (expression -> expression MOD term .)
    STACK           reduce using rule 50 (expression -> expression MOD term .)
    INT             reduce using rule 50 (expression -> expression MOD term .)
    FLOAT           reduce using rule 50 (expression -> expression MOD term .)
    LONG            reduce using rule 50 (expression -> expression MOD term .)
    CHAR            reduce using rule 50 (expression -> expression MOD term .)
    BOOLEAN         reduce using rule 50 (expression -> expression MOD term .)
    STRING_1        reduce using rule 50 (expression -> expression MOD term .)
    RCURL           reduce using rule 50 (expression -> expression MOD term .)


state 71

    (26) impresion -> PRINT LPAREN expression . RPAREN
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term
    (48) expression -> expression . TIMES term
    (49) expression -> expression . DIVIDE term
    (50) expression -> expression . MOD term

    RPAREN          shift and go to state 114
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 72

    (53) term -> LPAREN expression RPAREN .

    PLUS            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 53 (term -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    PRINTLN         reduce using rule 53 (term -> LPAREN expression RPAREN .)
    VAR             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    VAL             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    ID              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    ARRAYLIST       reduce using rule 53 (term -> LPAREN expression RPAREN .)
    STACK           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    INT             reduce using rule 53 (term -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LONG            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    CHAR            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    BOOLEAN         reduce using rule 53 (term -> LPAREN expression RPAREN .)
    STRING_1        reduce using rule 53 (term -> LPAREN expression RPAREN .)
    RCURL           reduce using rule 53 (term -> LPAREN expression RPAREN .)
    CONJ            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    DISJ            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LANGLE          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    RANGLE          reduce using rule 53 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 53 (term -> LPAREN expression RPAREN .)
    EXCL_EQ         reduce using rule 53 (term -> LPAREN expression RPAREN .)
    EXCL_EQEQ       reduce using rule 53 (term -> LPAREN expression RPAREN .)
    AS_SAFE         reduce using rule 53 (term -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 53 (term -> LPAREN expression RPAREN .)
    EQEQEQ          reduce using rule 53 (term -> LPAREN expression RPAREN .)


state 73

    (27) impresion -> PRINTLN LPAREN expression . RPAREN
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term
    (48) expression -> expression . TIMES term
    (49) expression -> expression . DIVIDE term
    (50) expression -> expression . MOD term

    RPAREN          shift and go to state 115
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 74

    (81) stack -> keywordVariables ID DOTS . def_estruct_tipoDato EQUAL instance_arraylist
    (99) lista -> keywordVariables ID DOTS . LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (36) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (38) tipoDato -> . TINT
    (39) tipoDato -> . TLONG
    (40) tipoDato -> . TFLOAT
    (41) tipoDato -> . TDOUBLE
    (42) tipoDato -> . TBOOLEAN
    (43) tipoDato -> . TCHAR
    (44) tipoDato -> . TSTRING

    LINKEDL         shift and go to state 117
    STACK           shift and go to state 36
    TINT            shift and go to state 77
    TLONG           shift and go to state 78
    TFLOAT          shift and go to state 79
    TDOUBLE         shift and go to state 80
    TBOOLEAN        shift and go to state 81
    TCHAR           shift and go to state 82
    TSTRING         shift and go to state 83

    def_estruct_tipoDato           shift and go to state 116
    tipoDato                       shift and go to state 76

state 75

    (28) queue -> VAL ID DOTS . QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    QUEUE           shift and go to state 118


state 76

    (36) asignacionSimple -> ID DOTS tipoDato . EQUAL valor

    EQUAL           shift and go to state 119


state 77

    (38) tipoDato -> TINT .

    EQUAL           reduce using rule 38 (tipoDato -> TINT .)
    RANGLE          reduce using rule 38 (tipoDato -> TINT .)


state 78

    (39) tipoDato -> TLONG .

    EQUAL           reduce using rule 39 (tipoDato -> TLONG .)
    RANGLE          reduce using rule 39 (tipoDato -> TLONG .)


state 79

    (40) tipoDato -> TFLOAT .

    EQUAL           reduce using rule 40 (tipoDato -> TFLOAT .)
    RANGLE          reduce using rule 40 (tipoDato -> TFLOAT .)


state 80

    (41) tipoDato -> TDOUBLE .

    EQUAL           reduce using rule 41 (tipoDato -> TDOUBLE .)
    RANGLE          reduce using rule 41 (tipoDato -> TDOUBLE .)


state 81

    (42) tipoDato -> TBOOLEAN .

    EQUAL           reduce using rule 42 (tipoDato -> TBOOLEAN .)
    RANGLE          reduce using rule 42 (tipoDato -> TBOOLEAN .)


state 82

    (43) tipoDato -> TCHAR .

    EQUAL           reduce using rule 43 (tipoDato -> TCHAR .)
    RANGLE          reduce using rule 43 (tipoDato -> TCHAR .)


state 83

    (44) tipoDato -> TSTRING .

    EQUAL           reduce using rule 44 (tipoDato -> TSTRING .)
    RANGLE          reduce using rule 44 (tipoDato -> TSTRING .)


state 84

    (37) asignacionSimple -> ID EQUAL valor .

    SEMICOLON       reduce using rule 37 (asignacionSimple -> ID EQUAL valor .)


state 85

    (45) valor -> expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term
    (48) expression -> expression . TIMES term
    (49) expression -> expression . DIVIDE term
    (50) expression -> expression . MOD term

    SEMICOLON       reduce using rule 45 (valor -> expression .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 86

    (84) stack_actuar -> ID DOT stack_funciones .

    SEMICOLON       reduce using rule 84 (stack_actuar -> ID DOT stack_funciones .)


state 87

    (100) lsimplem -> ID DOT Lmetod .

    SEMICOLON       reduce using rule 100 (lsimplem -> ID DOT Lmetod .)


state 88

    (22) queue_add -> ID DOT ADD . LPAREN factor RPAREN

    LPAREN          shift and go to state 120


state 89

    (23) queue_peek -> ID DOT PEEK . LPAREN RPAREN
    (93) stack_peek -> PEEK . LPAREN RPAREN

    LPAREN          shift and go to state 121


state 90

    (25) queue_remove -> ID DOT REMOVE . LPAREN RPAREN

    LPAREN          shift and go to state 122


state 91

    (24) queue_poll -> ID DOT POLL . LPAREN RPAREN

    LPAREN          shift and go to state 123


state 92

    (85) stack_funciones -> stack_isEmpty .

    SEMICOLON       reduce using rule 85 (stack_funciones -> stack_isEmpty .)


state 93

    (86) stack_funciones -> stack_push .

    SEMICOLON       reduce using rule 86 (stack_funciones -> stack_push .)


state 94

    (87) stack_funciones -> stack_pop .

    SEMICOLON       reduce using rule 87 (stack_funciones -> stack_pop .)


state 95

    (88) stack_funciones -> stack_peek .

    SEMICOLON       reduce using rule 88 (stack_funciones -> stack_peek .)


state 96

    (89) stack_funciones -> stack_size .

    SEMICOLON       reduce using rule 89 (stack_funciones -> stack_size .)


state 97

    (95) Lmetod -> FIRST . LPAREN RPAREN

    LPAREN          shift and go to state 124


state 98

    (96) Lmetod -> LAST . LPAREN RPAREN

    LPAREN          shift and go to state 125


state 99

    (97) Lmetod -> REMOVEL . LPAREN RPAREN

    LPAREN          shift and go to state 126


state 100

    (90) stack_isEmpty -> ISEMPTY . LPAREN RPAREN

    LPAREN          shift and go to state 127


state 101

    (92) stack_push -> PUSH . LPAREN ID RPAREN

    LPAREN          shift and go to state 128


state 102

    (91) stack_pop -> POP . LPAREN RPAREN

    LPAREN          shift and go to state 129


state 103

    (94) stack_size -> SIZE . LPAREN RPAREN

    LPAREN          shift and go to state 130


state 104

    (29) for -> FOR LPAREN ID . IN ID RPAREN LCURL morelines RCURL

    IN              shift and go to state 131


state 105

    (61) if -> IF LPAREN condicion . RPAREN LCURL morelines RCURL
    (62) if -> IF LPAREN condicion . RPAREN LCURL morelines RCURL else

    RPAREN          shift and go to state 132


state 106

    (64) condicion -> condicionL .

    RPAREN          reduce using rule 64 (condicion -> condicionL .)


state 107

    (65) condicion -> condicionR .

    RPAREN          reduce using rule 65 (condicion -> condicionR .)


state 108

    (66) condicion -> condicionN .

    RPAREN          reduce using rule 66 (condicion -> condicionN .)


state 109

    (67) condicionL -> term . opL term
    (68) condicionR -> term . opR term
    (70) opL -> . CONJ
    (71) opL -> . DISJ
    (72) opR -> . LANGLE
    (73) opR -> . RANGLE
    (74) opR -> . LE
    (75) opR -> . GE
    (76) opR -> . EXCL_EQ
    (77) opR -> . EXCL_EQEQ
    (78) opR -> . AS_SAFE
    (79) opR -> . EQEQ
    (80) opR -> . EQEQEQ

    CONJ            shift and go to state 135
    DISJ            shift and go to state 136
    LANGLE          shift and go to state 137
    RANGLE          shift and go to state 138
    LE              shift and go to state 139
    GE              shift and go to state 140
    EXCL_EQ         shift and go to state 141
    EXCL_EQEQ       shift and go to state 142
    AS_SAFE         shift and go to state 143
    EQEQ            shift and go to state 144
    EQEQEQ          shift and go to state 145

    opL                            shift and go to state 133
    opR                            shift and go to state 134

state 110

    (69) condicionN -> EXCL_WS . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 146
    factor                         shift and go to state 27

state 111

    (98) while -> WHILE DOTS LPAREN . ID opR TINT RPAREN LCURL morelines RCURL

    ID              shift and go to state 147


state 112

    (83) instance_arraylist -> ARRAYLIST LPAREN RPAREN .

    SEMICOLON       reduce using rule 83 (instance_arraylist -> ARRAYLIST LPAREN RPAREN .)


state 113

    (82) def_estruct_tipoDato -> STACK LANGLE tipoDato . RANGLE

    RANGLE          shift and go to state 148


state 114

    (26) impresion -> PRINT LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 26 (impresion -> PRINT LPAREN expression RPAREN .)


state 115

    (27) impresion -> PRINTLN LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 27 (impresion -> PRINTLN LPAREN expression RPAREN .)


state 116

    (81) stack -> keywordVariables ID DOTS def_estruct_tipoDato . EQUAL instance_arraylist

    EQUAL           shift and go to state 149


state 117

    (99) lista -> keywordVariables ID DOTS LINKEDL . LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 150


state 118

    (28) queue -> VAL ID DOTS QUEUE . LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 151


state 119

    (36) asignacionSimple -> ID DOTS tipoDato EQUAL . valor
    (45) valor -> . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    valor                          shift and go to state 152
    expression                     shift and go to state 85
    term                           shift and go to state 12
    factor                         shift and go to state 27

state 120

    (22) queue_add -> ID DOT ADD LPAREN . factor RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    factor                         shift and go to state 153

state 121

    (23) queue_peek -> ID DOT PEEK LPAREN . RPAREN
    (93) stack_peek -> PEEK LPAREN . RPAREN

    RPAREN          shift and go to state 154


state 122

    (25) queue_remove -> ID DOT REMOVE LPAREN . RPAREN

    RPAREN          shift and go to state 155


state 123

    (24) queue_poll -> ID DOT POLL LPAREN . RPAREN

    RPAREN          shift and go to state 156


state 124

    (95) Lmetod -> FIRST LPAREN . RPAREN

    RPAREN          shift and go to state 157


state 125

    (96) Lmetod -> LAST LPAREN . RPAREN

    RPAREN          shift and go to state 158


state 126

    (97) Lmetod -> REMOVEL LPAREN . RPAREN

    RPAREN          shift and go to state 159


state 127

    (90) stack_isEmpty -> ISEMPTY LPAREN . RPAREN

    RPAREN          shift and go to state 160


state 128

    (92) stack_push -> PUSH LPAREN . ID RPAREN

    ID              shift and go to state 161


state 129

    (91) stack_pop -> POP LPAREN . RPAREN

    RPAREN          shift and go to state 162


state 130

    (94) stack_size -> SIZE LPAREN . RPAREN

    RPAREN          shift and go to state 163


state 131

    (29) for -> FOR LPAREN ID IN . ID RPAREN LCURL morelines RCURL

    ID              shift and go to state 164


state 132

    (61) if -> IF LPAREN condicion RPAREN . LCURL morelines RCURL
    (62) if -> IF LPAREN condicion RPAREN . LCURL morelines RCURL else

    LCURL           shift and go to state 165


state 133

    (67) condicionL -> term opL . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 166
    factor                         shift and go to state 27

state 134

    (68) condicionR -> term opR . term
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    ID              shift and go to state 53
    STRING_1        shift and go to state 42

    term                           shift and go to state 167
    factor                         shift and go to state 27

state 135

    (70) opL -> CONJ .

    LPAREN          reduce using rule 70 (opL -> CONJ .)
    INT             reduce using rule 70 (opL -> CONJ .)
    FLOAT           reduce using rule 70 (opL -> CONJ .)
    LONG            reduce using rule 70 (opL -> CONJ .)
    CHAR            reduce using rule 70 (opL -> CONJ .)
    BOOLEAN         reduce using rule 70 (opL -> CONJ .)
    ID              reduce using rule 70 (opL -> CONJ .)
    STRING_1        reduce using rule 70 (opL -> CONJ .)


state 136

    (71) opL -> DISJ .

    LPAREN          reduce using rule 71 (opL -> DISJ .)
    INT             reduce using rule 71 (opL -> DISJ .)
    FLOAT           reduce using rule 71 (opL -> DISJ .)
    LONG            reduce using rule 71 (opL -> DISJ .)
    CHAR            reduce using rule 71 (opL -> DISJ .)
    BOOLEAN         reduce using rule 71 (opL -> DISJ .)
    ID              reduce using rule 71 (opL -> DISJ .)
    STRING_1        reduce using rule 71 (opL -> DISJ .)


state 137

    (72) opR -> LANGLE .

    LPAREN          reduce using rule 72 (opR -> LANGLE .)
    INT             reduce using rule 72 (opR -> LANGLE .)
    FLOAT           reduce using rule 72 (opR -> LANGLE .)
    LONG            reduce using rule 72 (opR -> LANGLE .)
    CHAR            reduce using rule 72 (opR -> LANGLE .)
    BOOLEAN         reduce using rule 72 (opR -> LANGLE .)
    ID              reduce using rule 72 (opR -> LANGLE .)
    STRING_1        reduce using rule 72 (opR -> LANGLE .)
    TINT            reduce using rule 72 (opR -> LANGLE .)


state 138

    (73) opR -> RANGLE .

    LPAREN          reduce using rule 73 (opR -> RANGLE .)
    INT             reduce using rule 73 (opR -> RANGLE .)
    FLOAT           reduce using rule 73 (opR -> RANGLE .)
    LONG            reduce using rule 73 (opR -> RANGLE .)
    CHAR            reduce using rule 73 (opR -> RANGLE .)
    BOOLEAN         reduce using rule 73 (opR -> RANGLE .)
    ID              reduce using rule 73 (opR -> RANGLE .)
    STRING_1        reduce using rule 73 (opR -> RANGLE .)
    TINT            reduce using rule 73 (opR -> RANGLE .)


state 139

    (74) opR -> LE .

    LPAREN          reduce using rule 74 (opR -> LE .)
    INT             reduce using rule 74 (opR -> LE .)
    FLOAT           reduce using rule 74 (opR -> LE .)
    LONG            reduce using rule 74 (opR -> LE .)
    CHAR            reduce using rule 74 (opR -> LE .)
    BOOLEAN         reduce using rule 74 (opR -> LE .)
    ID              reduce using rule 74 (opR -> LE .)
    STRING_1        reduce using rule 74 (opR -> LE .)
    TINT            reduce using rule 74 (opR -> LE .)


state 140

    (75) opR -> GE .

    LPAREN          reduce using rule 75 (opR -> GE .)
    INT             reduce using rule 75 (opR -> GE .)
    FLOAT           reduce using rule 75 (opR -> GE .)
    LONG            reduce using rule 75 (opR -> GE .)
    CHAR            reduce using rule 75 (opR -> GE .)
    BOOLEAN         reduce using rule 75 (opR -> GE .)
    ID              reduce using rule 75 (opR -> GE .)
    STRING_1        reduce using rule 75 (opR -> GE .)
    TINT            reduce using rule 75 (opR -> GE .)


state 141

    (76) opR -> EXCL_EQ .

    LPAREN          reduce using rule 76 (opR -> EXCL_EQ .)
    INT             reduce using rule 76 (opR -> EXCL_EQ .)
    FLOAT           reduce using rule 76 (opR -> EXCL_EQ .)
    LONG            reduce using rule 76 (opR -> EXCL_EQ .)
    CHAR            reduce using rule 76 (opR -> EXCL_EQ .)
    BOOLEAN         reduce using rule 76 (opR -> EXCL_EQ .)
    ID              reduce using rule 76 (opR -> EXCL_EQ .)
    STRING_1        reduce using rule 76 (opR -> EXCL_EQ .)
    TINT            reduce using rule 76 (opR -> EXCL_EQ .)


state 142

    (77) opR -> EXCL_EQEQ .

    LPAREN          reduce using rule 77 (opR -> EXCL_EQEQ .)
    INT             reduce using rule 77 (opR -> EXCL_EQEQ .)
    FLOAT           reduce using rule 77 (opR -> EXCL_EQEQ .)
    LONG            reduce using rule 77 (opR -> EXCL_EQEQ .)
    CHAR            reduce using rule 77 (opR -> EXCL_EQEQ .)
    BOOLEAN         reduce using rule 77 (opR -> EXCL_EQEQ .)
    ID              reduce using rule 77 (opR -> EXCL_EQEQ .)
    STRING_1        reduce using rule 77 (opR -> EXCL_EQEQ .)
    TINT            reduce using rule 77 (opR -> EXCL_EQEQ .)


state 143

    (78) opR -> AS_SAFE .

    LPAREN          reduce using rule 78 (opR -> AS_SAFE .)
    INT             reduce using rule 78 (opR -> AS_SAFE .)
    FLOAT           reduce using rule 78 (opR -> AS_SAFE .)
    LONG            reduce using rule 78 (opR -> AS_SAFE .)
    CHAR            reduce using rule 78 (opR -> AS_SAFE .)
    BOOLEAN         reduce using rule 78 (opR -> AS_SAFE .)
    ID              reduce using rule 78 (opR -> AS_SAFE .)
    STRING_1        reduce using rule 78 (opR -> AS_SAFE .)
    TINT            reduce using rule 78 (opR -> AS_SAFE .)


state 144

    (79) opR -> EQEQ .

    LPAREN          reduce using rule 79 (opR -> EQEQ .)
    INT             reduce using rule 79 (opR -> EQEQ .)
    FLOAT           reduce using rule 79 (opR -> EQEQ .)
    LONG            reduce using rule 79 (opR -> EQEQ .)
    CHAR            reduce using rule 79 (opR -> EQEQ .)
    BOOLEAN         reduce using rule 79 (opR -> EQEQ .)
    ID              reduce using rule 79 (opR -> EQEQ .)
    STRING_1        reduce using rule 79 (opR -> EQEQ .)
    TINT            reduce using rule 79 (opR -> EQEQ .)


state 145

    (80) opR -> EQEQEQ .

    LPAREN          reduce using rule 80 (opR -> EQEQEQ .)
    INT             reduce using rule 80 (opR -> EQEQEQ .)
    FLOAT           reduce using rule 80 (opR -> EQEQEQ .)
    LONG            reduce using rule 80 (opR -> EQEQEQ .)
    CHAR            reduce using rule 80 (opR -> EQEQEQ .)
    BOOLEAN         reduce using rule 80 (opR -> EQEQEQ .)
    ID              reduce using rule 80 (opR -> EQEQEQ .)
    STRING_1        reduce using rule 80 (opR -> EQEQEQ .)
    TINT            reduce using rule 80 (opR -> EQEQEQ .)


state 146

    (69) condicionN -> EXCL_WS term .

    RPAREN          reduce using rule 69 (condicionN -> EXCL_WS term .)


state 147

    (98) while -> WHILE DOTS LPAREN ID . opR TINT RPAREN LCURL morelines RCURL
    (72) opR -> . LANGLE
    (73) opR -> . RANGLE
    (74) opR -> . LE
    (75) opR -> . GE
    (76) opR -> . EXCL_EQ
    (77) opR -> . EXCL_EQEQ
    (78) opR -> . AS_SAFE
    (79) opR -> . EQEQ
    (80) opR -> . EQEQEQ

    LANGLE          shift and go to state 137
    RANGLE          shift and go to state 138
    LE              shift and go to state 139
    GE              shift and go to state 140
    EXCL_EQ         shift and go to state 141
    EXCL_EQEQ       shift and go to state 142
    AS_SAFE         shift and go to state 143
    EQEQ            shift and go to state 144
    EQEQEQ          shift and go to state 145

    opR                            shift and go to state 168

state 148

    (82) def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .

    SEMICOLON       reduce using rule 82 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)
    EQUAL           reduce using rule 82 (def_estruct_tipoDato -> STACK LANGLE tipoDato RANGLE .)


state 149

    (81) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL . instance_arraylist
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN

    ARRAYLIST       shift and go to state 35

    instance_arraylist             shift and go to state 169

state 150

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE . OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    OBJECT          shift and go to state 170


state 151

    (28) queue -> VAL ID DOTS QUEUE LANGLE . tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (38) tipoDato -> . TINT
    (39) tipoDato -> . TLONG
    (40) tipoDato -> . TFLOAT
    (41) tipoDato -> . TDOUBLE
    (42) tipoDato -> . TBOOLEAN
    (43) tipoDato -> . TCHAR
    (44) tipoDato -> . TSTRING

    TINT            shift and go to state 77
    TLONG           shift and go to state 78
    TFLOAT          shift and go to state 79
    TDOUBLE         shift and go to state 80
    TBOOLEAN        shift and go to state 81
    TCHAR           shift and go to state 82
    TSTRING         shift and go to state 83

    tipoDato                       shift and go to state 171

state 152

    (36) asignacionSimple -> ID DOTS tipoDato EQUAL valor .

    SEMICOLON       reduce using rule 36 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)


state 153

    (22) queue_add -> ID DOT ADD LPAREN factor . RPAREN

    RPAREN          shift and go to state 172


state 154

    (23) queue_peek -> ID DOT PEEK LPAREN RPAREN .
    (93) stack_peek -> PEEK LPAREN RPAREN .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 23 (queue_peek -> ID DOT PEEK LPAREN RPAREN .)
    SEMICOLON       reduce using rule 23 (queue_peek -> ID DOT PEEK LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 93 (stack_peek -> PEEK LPAREN RPAREN .) ]


state 155

    (25) queue_remove -> ID DOT REMOVE LPAREN RPAREN .

    SEMICOLON       reduce using rule 25 (queue_remove -> ID DOT REMOVE LPAREN RPAREN .)


state 156

    (24) queue_poll -> ID DOT POLL LPAREN RPAREN .

    SEMICOLON       reduce using rule 24 (queue_poll -> ID DOT POLL LPAREN RPAREN .)


state 157

    (95) Lmetod -> FIRST LPAREN RPAREN .

    SEMICOLON       reduce using rule 95 (Lmetod -> FIRST LPAREN RPAREN .)


state 158

    (96) Lmetod -> LAST LPAREN RPAREN .

    SEMICOLON       reduce using rule 96 (Lmetod -> LAST LPAREN RPAREN .)


state 159

    (97) Lmetod -> REMOVEL LPAREN RPAREN .

    SEMICOLON       reduce using rule 97 (Lmetod -> REMOVEL LPAREN RPAREN .)


state 160

    (90) stack_isEmpty -> ISEMPTY LPAREN RPAREN .

    SEMICOLON       reduce using rule 90 (stack_isEmpty -> ISEMPTY LPAREN RPAREN .)


state 161

    (92) stack_push -> PUSH LPAREN ID . RPAREN

    RPAREN          shift and go to state 173


state 162

    (91) stack_pop -> POP LPAREN RPAREN .

    SEMICOLON       reduce using rule 91 (stack_pop -> POP LPAREN RPAREN .)


state 163

    (94) stack_size -> SIZE LPAREN RPAREN .

    SEMICOLON       reduce using rule 94 (stack_size -> SIZE LPAREN RPAREN .)


state 164

    (29) for -> FOR LPAREN ID IN ID . RPAREN LCURL morelines RCURL

    RPAREN          shift and go to state 174


state 165

    (61) if -> IF LPAREN condicion RPAREN LCURL . morelines RCURL
    (62) if -> IF LPAREN condicion RPAREN LCURL . morelines RCURL else
    (30) morelines -> . line
    (31) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    morelines                      shift and go to state 175
    line                           shift and go to state 176
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 166

    (67) condicionL -> term opL term .

    RPAREN          reduce using rule 67 (condicionL -> term opL term .)


state 167

    (68) condicionR -> term opR term .

    RPAREN          reduce using rule 68 (condicionR -> term opR term .)


state 168

    (98) while -> WHILE DOTS LPAREN ID opR . TINT RPAREN LCURL morelines RCURL

    TINT            shift and go to state 177


state 169

    (81) stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .

    SEMICOLON       reduce using rule 81 (stack -> keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist .)


state 170

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT . RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 178


state 171

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato . RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 179


state 172

    (22) queue_add -> ID DOT ADD LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 22 (queue_add -> ID DOT ADD LPAREN factor RPAREN .)


state 173

    (92) stack_push -> PUSH LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 92 (stack_push -> PUSH LPAREN ID RPAREN .)


state 174

    (29) for -> FOR LPAREN ID IN ID RPAREN . LCURL morelines RCURL

    LCURL           shift and go to state 180


state 175

    (61) if -> IF LPAREN condicion RPAREN LCURL morelines . RCURL
    (62) if -> IF LPAREN condicion RPAREN LCURL morelines . RCURL else

    RCURL           shift and go to state 181


state 176

    (30) morelines -> line .
    (31) morelines -> line . morelines
    (30) morelines -> . line
    (31) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    RCURL           reduce using rule 30 (morelines -> line .)
    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    line                           shift and go to state 176
    morelines                      shift and go to state 182
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 177

    (98) while -> WHILE DOTS LPAREN ID opR TINT . RPAREN LCURL morelines RCURL

    RPAREN          shift and go to state 183


state 178

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE . EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    EQUAL           shift and go to state 184


state 179

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE . EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    EQUAL           shift and go to state 185


state 180

    (29) for -> FOR LPAREN ID IN ID RPAREN LCURL . morelines RCURL
    (30) morelines -> . line
    (31) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    morelines                      shift and go to state 186
    line                           shift and go to state 176
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 181

    (61) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .
    (62) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL . else
    (63) else -> . ELSE LCURL line RCURL

    $end            reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 61 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL .)
    ELSE            shift and go to state 188

    else                           shift and go to state 187

state 182

    (31) morelines -> line morelines .

    RCURL           reduce using rule 31 (morelines -> line morelines .)


state 183

    (98) while -> WHILE DOTS LPAREN ID opR TINT RPAREN . LCURL morelines RCURL

    LCURL           shift and go to state 189


state 184

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL . LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN

    LINKEDL         shift and go to state 190


state 185

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL . LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN

    LINKEDL         shift and go to state 191


state 186

    (29) for -> FOR LPAREN ID IN ID RPAREN LCURL morelines . RCURL

    RCURL           shift and go to state 192


state 187

    (62) if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .

    $end            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    PRINT           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    PRINTLN         reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    VAR             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    VAL             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    ID              reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    LPAREN          reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    FOR             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    IF              reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    WHILE           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    ARRAYLIST       reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    STACK           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    INT             reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    FLOAT           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    LONG            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    CHAR            reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    BOOLEAN         reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    STRING_1        reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    SEMICOLON       reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)
    RCURL           reduce using rule 62 (if -> IF LPAREN condicion RPAREN LCURL morelines RCURL else .)


state 188

    (63) else -> ELSE . LCURL line RCURL

    LCURL           shift and go to state 193


state 189

    (98) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL . morelines RCURL
    (30) morelines -> . line
    (31) morelines -> . line morelines
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    morelines                      shift and go to state 194
    line                           shift and go to state 176
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 190

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL . LANGLE OBJECT RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 195


state 191

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL . LANGLE tipoDato RANGLE LPAREN RPAREN

    LANGLE          shift and go to state 196


state 192

    (29) for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .

    $end            reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 29 (for -> FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL .)


state 193

    (63) else -> ELSE LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . asignacion SEMICOLON
    (3) line -> . expression
    (4) line -> . estructurasControl
    (5) line -> . estructurasDatos SEMICOLON
    (26) impresion -> . PRINT LPAREN expression RPAREN
    (27) impresion -> . PRINTLN LPAREN expression RPAREN
    (32) asignacion -> . keywordVariables asignacionSimple
    (33) asignacion -> . asignacionSimple
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (48) expression -> . expression TIMES term
    (49) expression -> . expression DIVIDE term
    (50) expression -> . expression MOD term
    (51) expression -> . term
    (15) estructurasControl -> . for
    (16) estructurasControl -> . if
    (17) estructurasControl -> . while
    (6) estructurasDatos -> . queue
    (7) estructurasDatos -> . queue_operations
    (8) estructurasDatos -> . stack
    (9) estructurasDatos -> . stack_actuar
    (10) estructurasDatos -> . instance_arraylist
    (11) estructurasDatos -> . def_estruct_tipoDato
    (12) estructurasDatos -> . lista
    (13) estructurasDatos -> . lsimplem
    (14) estructurasDatos -> .
    (34) keywordVariables -> . VAR
    (35) keywordVariables -> . VAL
    (36) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (37) asignacionSimple -> . ID EQUAL valor
    (52) term -> . factor
    (53) term -> . LPAREN expression RPAREN
    (29) for -> . FOR LPAREN ID IN ID RPAREN LCURL morelines RCURL
    (61) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL
    (62) if -> . IF LPAREN condicion RPAREN LCURL morelines RCURL else
    (98) while -> . WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL
    (28) queue -> . VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN
    (18) queue_operations -> . queue_add
    (19) queue_operations -> . queue_peek
    (20) queue_operations -> . queue_remove
    (21) queue_operations -> . queue_poll
    (81) stack -> . keywordVariables ID DOTS def_estruct_tipoDato EQUAL instance_arraylist
    (84) stack_actuar -> . ID DOT stack_funciones
    (83) instance_arraylist -> . ARRAYLIST LPAREN RPAREN
    (82) def_estruct_tipoDato -> . STACK LANGLE tipoDato RANGLE
    (99) lista -> . keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN
    (100) lsimplem -> . ID DOT Lmetod
    (54) factor -> . INT
    (55) factor -> . FLOAT
    (56) factor -> . LONG
    (57) factor -> . CHAR
    (58) factor -> . BOOLEAN
    (59) factor -> . ID
    (60) factor -> . STRING_1
    (22) queue_add -> . ID DOT ADD LPAREN factor RPAREN
    (23) queue_peek -> . ID DOT PEEK LPAREN RPAREN
    (25) queue_remove -> . ID DOT REMOVE LPAREN RPAREN
    (24) queue_poll -> . ID DOT POLL LPAREN RPAREN

    PRINT           shift and go to state 7
    PRINTLN         shift and go to state 9
    SEMICOLON       reduce using rule 14 (estructurasDatos -> .)
    VAR             shift and go to state 24
    VAL             shift and go to state 25
    ID              shift and go to state 26
    LPAREN          shift and go to state 8
    FOR             shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    ARRAYLIST       shift and go to state 35
    STACK           shift and go to state 36
    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    LONG            shift and go to state 39
    CHAR            shift and go to state 40
    BOOLEAN         shift and go to state 41
    STRING_1        shift and go to state 42

    line                           shift and go to state 197
    impresion                      shift and go to state 2
    asignacion                     shift and go to state 3
    expression                     shift and go to state 4
    estructurasControl             shift and go to state 5
    estructurasDatos               shift and go to state 6
    keywordVariables               shift and go to state 10
    asignacionSimple               shift and go to state 11
    term                           shift and go to state 12
    for                            shift and go to state 13
    if                             shift and go to state 14
    while                          shift and go to state 15
    queue                          shift and go to state 16
    queue_operations               shift and go to state 17
    stack                          shift and go to state 18
    stack_actuar                   shift and go to state 19
    instance_arraylist             shift and go to state 20
    def_estruct_tipoDato           shift and go to state 21
    lista                          shift and go to state 22
    lsimplem                       shift and go to state 23
    factor                         shift and go to state 27
    queue_add                      shift and go to state 31
    queue_peek                     shift and go to state 32
    queue_remove                   shift and go to state 33
    queue_poll                     shift and go to state 34

state 194

    (98) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines . RCURL

    RCURL           shift and go to state 198


state 195

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE . OBJECT RANGLE LPAREN RPAREN

    OBJECT          shift and go to state 199


state 196

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE . tipoDato RANGLE LPAREN RPAREN
    (38) tipoDato -> . TINT
    (39) tipoDato -> . TLONG
    (40) tipoDato -> . TFLOAT
    (41) tipoDato -> . TDOUBLE
    (42) tipoDato -> . TBOOLEAN
    (43) tipoDato -> . TCHAR
    (44) tipoDato -> . TSTRING

    TINT            shift and go to state 77
    TLONG           shift and go to state 78
    TFLOAT          shift and go to state 79
    TDOUBLE         shift and go to state 80
    TBOOLEAN        shift and go to state 81
    TCHAR           shift and go to state 82
    TSTRING         shift and go to state 83

    tipoDato                       shift and go to state 200

state 197

    (63) else -> ELSE LCURL line . RCURL

    RCURL           shift and go to state 201


state 198

    (98) while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .

    $end            reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    PRINT           reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    PRINTLN         reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    VAR             reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    VAL             reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    ID              reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    LPAREN          reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    FOR             reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    IF              reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    WHILE           reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    ARRAYLIST       reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    STACK           reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    INT             reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    FLOAT           reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    LONG            reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    CHAR            reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    BOOLEAN         reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    STRING_1        reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    SEMICOLON       reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)
    RCURL           reduce using rule 98 (while -> WHILE DOTS LPAREN ID opR TINT RPAREN LCURL morelines RCURL .)


state 199

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT . RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 202


state 200

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato . RANGLE LPAREN RPAREN

    RANGLE          shift and go to state 203


state 201

    (63) else -> ELSE LCURL line RCURL .

    $end            reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    PRINT           reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    PRINTLN         reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    VAR             reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    VAL             reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    ID              reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    LPAREN          reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    FOR             reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    IF              reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    WHILE           reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    ARRAYLIST       reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    STACK           reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    INT             reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    FLOAT           reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    LONG            reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    CHAR            reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    BOOLEAN         reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    STRING_1        reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    SEMICOLON       reduce using rule 63 (else -> ELSE LCURL line RCURL .)
    RCURL           reduce using rule 63 (else -> ELSE LCURL line RCURL .)


state 202

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE . LPAREN RPAREN

    LPAREN          shift and go to state 204


state 203

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE . LPAREN RPAREN

    LPAREN          shift and go to state 205


state 204

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN . RPAREN

    RPAREN          shift and go to state 206


state 205

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN . RPAREN

    RPAREN          shift and go to state 207


state 206

    (99) lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN .

    SEMICOLON       reduce using rule 99 (lista -> keywordVariables ID DOTS LINKEDL LANGLE OBJECT RANGLE EQUAL LINKEDL LANGLE OBJECT RANGLE LPAREN RPAREN .)


state 207

    (28) queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN .

    SEMICOLON       reduce using rule 28 (queue -> VAL ID DOTS QUEUE LANGLE tipoDato RANGLE EQUAL LINKEDL LANGLE tipoDato RANGLE LPAREN RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: reduce/reduce conflict in state 154 resolved using rule (queue_peek -> ID DOT PEEK LPAREN RPAREN)
WARNING: rejected rule (stack_peek -> PEEK LPAREN RPAREN) in state 154
WARNING: Rule (stack_peek -> PEEK LPAREN RPAREN) is never reduced
