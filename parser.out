Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ACTUAL
    ANNOTATION
    ARRAYOF
    ARROW
    AS
    AT_NO_WS
    BREAK
    BY
    CATCH
    CLASS
    COLONCOLON
    COMMA
    COMMENT
    COMPANION
    CONST
    CONSTRUCTOR
    CONTINUE
    CROSSINLINE
    DATA
    DECR
    DECREMENTIN
    DECREMENTONE
    DIVIDEIN
    DO
    DOT
    DOUBLE_ARROW
    DOUBLE_SEMICOLON
    DYNAMIC
    ENUM
    EXCL_NO_WS
    EXPECT
    EXTERNAL
    FIELD
    FILE
    FINAL
    FINALLY
    FUN
    GET
    HASH
    IMPORT
    INCR
    INCREMENTIN
    INCREMENTONE
    INCREMENTTIMES
    INFIX
    INIT
    INLINE
    INNER
    INTERFACE
    INTERNAL
    IS
    LATEINIT
    LINEBREAK
    LSQUARE
    MARK_1
    MARK_2
    MODIN
    NOINLINE
    OBJECT
    OPEN
    OPERATOR
    OUT
    OVERRIDE
    PACKAGE
    PARAM
    PRINTLN
    PRIVATE
    PROPERTY
    PROTECTED
    PUBLIC
    QUEST_WS
    RANGE
    RECEIVER
    REIFIED
    RETURN
    RSQUARE
    SEALED
    SET
    SETPARAM
    SINGLE_QUOTE
    SUM
    SUPER
    SUSPEND
    TAILREC
    TEMPLATE
    THIS
    THROW
    TRY
    TYPEOF
    TYPE_ALIAS
    VALUE
    VAL_TIPO_1
    VARARG
    VAR_TIPO_1
    WHEN
    WHERE
    WHILE

Grammar

Rule 0     S' -> line
Rule 1     line -> impresion SEMICOLON
Rule 2     line -> expression
Rule 3     line -> asignacion SEMICOLON
Rule 4     line -> for
Rule 5     line -> if
Rule 6     impresion -> PRINT LPAREN STRING_1 RPAREN
Rule 7     for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL
Rule 8     keywordVariables -> VAR
Rule 9     keywordVariables -> VAL
Rule 10    asignacion -> keywordVariables asignacionSimple
Rule 11    asignacion -> asignacionSimple
Rule 12    asignacionSimple -> ID DOTS tipoDato EQUAL valor
Rule 13    asignacionSimple -> ID EQUAL valor
Rule 14    tipoDato -> TINT
Rule 15    tipoDato -> TLONG
Rule 16    tipoDato -> TFLOAT
Rule 17    tipoDato -> TDOUBLE
Rule 18    tipoDato -> TBOOLEAN
Rule 19    tipoDato -> TCHAR
Rule 20    tipoDato -> TSTRING
Rule 21    valor -> expression
Rule 22    expression -> expression PLUS term
Rule 23    expression -> expression MINUS term
Rule 24    expression -> expression TIMES term
Rule 25    expression -> expression DIVIDE term
Rule 26    expression -> expression MOD term
Rule 27    expression -> term
Rule 28    term -> factor
Rule 29    term -> LPAREN expression RPAREN
Rule 30    factor -> INT
Rule 31    factor -> FLOAT
Rule 32    factor -> LONG
Rule 33    factor -> CHAR
Rule 34    factor -> BOOLEAN
Rule 35    factor -> ID
Rule 36    factor -> STRING_1
Rule 37    if -> IF LPAREN condicion RPAREN LCURL line RCURL
Rule 38    if -> IF LPAREN condicion RPAREN LCURL line RCURL else
Rule 39    else -> ELSE LCURL line RCURL
Rule 40    condicion -> condicionL
Rule 41    condicion -> condicionR
Rule 42    condicion -> condicionN
Rule 43    condicionL -> term opL term
Rule 44    condicionR -> term opR term
Rule 45    condicionN -> EXCL_WS term
Rule 46    opL -> CONJ
Rule 47    opL -> DISJ
Rule 48    opR -> LANGLE
Rule 49    opR -> RANGLE
Rule 50    opR -> LE
Rule 51    opR -> GE
Rule 52    opR -> EXCL_EQ
Rule 53    opR -> EXCL_EQEQ
Rule 54    opR -> AS_SAFE
Rule 55    opR -> EQEQ
Rule 56    opR -> EQEQEQ

Terminals, with rules where they appear

ABSTRACT             : 
ACTUAL               : 
ANNOTATION           : 
ARRAYOF              : 
ARROW                : 
AS                   : 
AS_SAFE              : 54
AT_NO_WS             : 
BOOLEAN              : 34
BREAK                : 
BY                   : 
CATCH                : 
CHAR                 : 33
CLASS                : 
COLONCOLON           : 
COMMA                : 
COMMENT              : 
COMPANION            : 
CONJ                 : 46
CONST                : 
CONSTRUCTOR          : 
CONTINUE             : 
CROSSINLINE          : 
DATA                 : 
DECR                 : 
DECREMENTIN          : 
DECREMENTONE         : 
DISJ                 : 47
DIVIDE               : 25
DIVIDEIN             : 
DO                   : 
DOT                  : 
DOTS                 : 12
DOUBLE_ARROW         : 
DOUBLE_SEMICOLON     : 
DYNAMIC              : 
ELSE                 : 39
ENUM                 : 
EQEQ                 : 55
EQEQEQ               : 56
EQUAL                : 12 13
EXCL_EQ              : 52
EXCL_EQEQ            : 53
EXCL_NO_WS           : 
EXCL_WS              : 45
EXPECT               : 
EXTERNAL             : 
FIELD                : 
FILE                 : 
FINAL                : 
FINALLY              : 
FLOAT                : 31
FOR                  : 7
FUN                  : 
GE                   : 51
GET                  : 
HASH                 : 
ID                   : 7 7 12 13 35
IF                   : 37 38
IMPORT               : 
IN                   : 7
INCR                 : 
INCREMENTIN          : 
INCREMENTONE         : 
INCREMENTTIMES       : 
INFIX                : 
INIT                 : 
INLINE               : 
INNER                : 
INT                  : 30
INTERFACE            : 
INTERNAL             : 
IS                   : 
LANGLE               : 48
LATEINIT             : 
LCURL                : 7 37 38 39
LE                   : 50
LINEBREAK            : 
LONG                 : 32
LPAREN               : 6 7 29 37 38
LSQUARE              : 
MARK_1               : 
MARK_2               : 
MINUS                : 23
MOD                  : 26
MODIN                : 
NOINLINE             : 
OBJECT               : 
OPEN                 : 
OPERATOR             : 
OUT                  : 
OVERRIDE             : 
PACKAGE              : 
PARAM                : 
PLUS                 : 22
PRINT                : 6
PRINTLN              : 
PRIVATE              : 
PROPERTY             : 
PROTECTED            : 
PUBLIC               : 
QUEST_WS             : 
RANGE                : 
RANGLE               : 49
RCURL                : 7 37 38 39
RECEIVER             : 
REIFIED              : 
RETURN               : 
RPAREN               : 6 7 29 37 38
RSQUARE              : 
SEALED               : 
SEMICOLON            : 1 3
SET                  : 
SETPARAM             : 
SINGLE_QUOTE         : 
STRING_1             : 6 36
SUM                  : 
SUPER                : 
SUSPEND              : 
TAILREC              : 
TBOOLEAN             : 18
TCHAR                : 19
TDOUBLE              : 17
TEMPLATE             : 
TFLOAT               : 16
THIS                 : 
THROW                : 
TIMES                : 24
TINT                 : 14
TLONG                : 15
TRY                  : 
TSTRING              : 20
TYPEOF               : 
TYPE_ALIAS           : 
VAL                  : 9
VALUE                : 
VAL_TIPO_1           : 
VAR                  : 8
VARARG               : 
VAR_TIPO_1           : 
WHEN                 : 
WHERE                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 3
asignacionSimple     : 10 11
condicion            : 37 38
condicionL           : 40
condicionN           : 42
condicionR           : 41
else                 : 38
expression           : 2 21 22 23 24 25 26 29
factor               : 28
for                  : 4
if                   : 5
impresion            : 1
keywordVariables     : 10
line                 : 7 37 38 39 0
opL                  : 43
opR                  : 44
term                 : 22 23 24 25 26 27 43 43 44 44 45
tipoDato             : 12
valor                : 12 13

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion SEMICOLON
    (4) line -> . for
    (5) line -> . if
    (6) impresion -> . PRINT LPAREN STRING_1 RPAREN
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (10) asignacion -> . keywordVariables asignacionSimple
    (11) asignacion -> . asignacionSimple
    (7) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (37) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (38) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (8) keywordVariables -> . VAR
    (9) keywordVariables -> . VAL
    (12) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> . ID EQUAL valor
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    PRINT           shift and go to state 7
    FOR             shift and go to state 13
    IF              shift and go to state 15
    LPAREN          shift and go to state 8
    VAR             shift and go to state 17
    VAL             shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    STRING_1        shift and go to state 9

    line                           shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    term                           shift and go to state 10
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    factor                         shift and go to state 16

state 1

    (0) S' -> line .



state 2

    (1) line -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 24


state 3

    (2) line -> expression .
    (22) expression -> expression . PLUS term
    (23) expression -> expression . MINUS term
    (24) expression -> expression . TIMES term
    (25) expression -> expression . DIVIDE term
    (26) expression -> expression . MOD term

    $end            reduce using rule 2 (line -> expression .)
    RCURL           reduce using rule 2 (line -> expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    MOD             shift and go to state 29


state 4

    (3) line -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 30


state 5

    (4) line -> for .

    $end            reduce using rule 4 (line -> for .)
    RCURL           reduce using rule 4 (line -> for .)


state 6

    (5) line -> if .

    $end            reduce using rule 5 (line -> if .)
    RCURL           reduce using rule 5 (line -> if .)


state 7

    (6) impresion -> PRINT . LPAREN STRING_1 RPAREN

    LPAREN          shift and go to state 31


state 8

    (29) term -> LPAREN . expression RPAREN
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    expression                     shift and go to state 32
    term                           shift and go to state 10
    factor                         shift and go to state 16

state 9

    (36) factor -> STRING_1 .

    PLUS            reduce using rule 36 (factor -> STRING_1 .)
    MINUS           reduce using rule 36 (factor -> STRING_1 .)
    TIMES           reduce using rule 36 (factor -> STRING_1 .)
    DIVIDE          reduce using rule 36 (factor -> STRING_1 .)
    MOD             reduce using rule 36 (factor -> STRING_1 .)
    $end            reduce using rule 36 (factor -> STRING_1 .)
    RPAREN          reduce using rule 36 (factor -> STRING_1 .)
    SEMICOLON       reduce using rule 36 (factor -> STRING_1 .)
    RCURL           reduce using rule 36 (factor -> STRING_1 .)
    CONJ            reduce using rule 36 (factor -> STRING_1 .)
    DISJ            reduce using rule 36 (factor -> STRING_1 .)
    LANGLE          reduce using rule 36 (factor -> STRING_1 .)
    RANGLE          reduce using rule 36 (factor -> STRING_1 .)
    LE              reduce using rule 36 (factor -> STRING_1 .)
    GE              reduce using rule 36 (factor -> STRING_1 .)
    EXCL_EQ         reduce using rule 36 (factor -> STRING_1 .)
    EXCL_EQEQ       reduce using rule 36 (factor -> STRING_1 .)
    AS_SAFE         reduce using rule 36 (factor -> STRING_1 .)
    EQEQ            reduce using rule 36 (factor -> STRING_1 .)
    EQEQEQ          reduce using rule 36 (factor -> STRING_1 .)


state 10

    (27) expression -> term .

    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    TIMES           reduce using rule 27 (expression -> term .)
    DIVIDE          reduce using rule 27 (expression -> term .)
    MOD             reduce using rule 27 (expression -> term .)
    $end            reduce using rule 27 (expression -> term .)
    RPAREN          reduce using rule 27 (expression -> term .)
    SEMICOLON       reduce using rule 27 (expression -> term .)
    RCURL           reduce using rule 27 (expression -> term .)


state 11

    (10) asignacion -> keywordVariables . asignacionSimple
    (12) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> . ID EQUAL valor

    ID              shift and go to state 35

    asignacionSimple               shift and go to state 34

state 12

    (11) asignacion -> asignacionSimple .

    SEMICOLON       reduce using rule 11 (asignacion -> asignacionSimple .)


state 13

    (7) for -> FOR . LPAREN ID IN ID RPAREN LCURL line RCURL

    LPAREN          shift and go to state 36


state 14

    (12) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> ID . EQUAL valor
    (35) factor -> ID .

    DOTS            shift and go to state 37
    EQUAL           shift and go to state 38
    PLUS            reduce using rule 35 (factor -> ID .)
    MINUS           reduce using rule 35 (factor -> ID .)
    TIMES           reduce using rule 35 (factor -> ID .)
    DIVIDE          reduce using rule 35 (factor -> ID .)
    MOD             reduce using rule 35 (factor -> ID .)
    $end            reduce using rule 35 (factor -> ID .)
    RCURL           reduce using rule 35 (factor -> ID .)


state 15

    (37) if -> IF . LPAREN condicion RPAREN LCURL line RCURL
    (38) if -> IF . LPAREN condicion RPAREN LCURL line RCURL else

    LPAREN          shift and go to state 39


state 16

    (28) term -> factor .

    PLUS            reduce using rule 28 (term -> factor .)
    MINUS           reduce using rule 28 (term -> factor .)
    TIMES           reduce using rule 28 (term -> factor .)
    DIVIDE          reduce using rule 28 (term -> factor .)
    MOD             reduce using rule 28 (term -> factor .)
    $end            reduce using rule 28 (term -> factor .)
    RPAREN          reduce using rule 28 (term -> factor .)
    SEMICOLON       reduce using rule 28 (term -> factor .)
    RCURL           reduce using rule 28 (term -> factor .)
    CONJ            reduce using rule 28 (term -> factor .)
    DISJ            reduce using rule 28 (term -> factor .)
    LANGLE          reduce using rule 28 (term -> factor .)
    RANGLE          reduce using rule 28 (term -> factor .)
    LE              reduce using rule 28 (term -> factor .)
    GE              reduce using rule 28 (term -> factor .)
    EXCL_EQ         reduce using rule 28 (term -> factor .)
    EXCL_EQEQ       reduce using rule 28 (term -> factor .)
    AS_SAFE         reduce using rule 28 (term -> factor .)
    EQEQ            reduce using rule 28 (term -> factor .)
    EQEQEQ          reduce using rule 28 (term -> factor .)


state 17

    (8) keywordVariables -> VAR .

    ID              reduce using rule 8 (keywordVariables -> VAR .)


state 18

    (9) keywordVariables -> VAL .

    ID              reduce using rule 9 (keywordVariables -> VAL .)


state 19

    (30) factor -> INT .

    PLUS            reduce using rule 30 (factor -> INT .)
    MINUS           reduce using rule 30 (factor -> INT .)
    TIMES           reduce using rule 30 (factor -> INT .)
    DIVIDE          reduce using rule 30 (factor -> INT .)
    MOD             reduce using rule 30 (factor -> INT .)
    $end            reduce using rule 30 (factor -> INT .)
    RPAREN          reduce using rule 30 (factor -> INT .)
    SEMICOLON       reduce using rule 30 (factor -> INT .)
    RCURL           reduce using rule 30 (factor -> INT .)
    CONJ            reduce using rule 30 (factor -> INT .)
    DISJ            reduce using rule 30 (factor -> INT .)
    LANGLE          reduce using rule 30 (factor -> INT .)
    RANGLE          reduce using rule 30 (factor -> INT .)
    LE              reduce using rule 30 (factor -> INT .)
    GE              reduce using rule 30 (factor -> INT .)
    EXCL_EQ         reduce using rule 30 (factor -> INT .)
    EXCL_EQEQ       reduce using rule 30 (factor -> INT .)
    AS_SAFE         reduce using rule 30 (factor -> INT .)
    EQEQ            reduce using rule 30 (factor -> INT .)
    EQEQEQ          reduce using rule 30 (factor -> INT .)


state 20

    (31) factor -> FLOAT .

    PLUS            reduce using rule 31 (factor -> FLOAT .)
    MINUS           reduce using rule 31 (factor -> FLOAT .)
    TIMES           reduce using rule 31 (factor -> FLOAT .)
    DIVIDE          reduce using rule 31 (factor -> FLOAT .)
    MOD             reduce using rule 31 (factor -> FLOAT .)
    $end            reduce using rule 31 (factor -> FLOAT .)
    RPAREN          reduce using rule 31 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 31 (factor -> FLOAT .)
    RCURL           reduce using rule 31 (factor -> FLOAT .)
    CONJ            reduce using rule 31 (factor -> FLOAT .)
    DISJ            reduce using rule 31 (factor -> FLOAT .)
    LANGLE          reduce using rule 31 (factor -> FLOAT .)
    RANGLE          reduce using rule 31 (factor -> FLOAT .)
    LE              reduce using rule 31 (factor -> FLOAT .)
    GE              reduce using rule 31 (factor -> FLOAT .)
    EXCL_EQ         reduce using rule 31 (factor -> FLOAT .)
    EXCL_EQEQ       reduce using rule 31 (factor -> FLOAT .)
    AS_SAFE         reduce using rule 31 (factor -> FLOAT .)
    EQEQ            reduce using rule 31 (factor -> FLOAT .)
    EQEQEQ          reduce using rule 31 (factor -> FLOAT .)


state 21

    (32) factor -> LONG .

    PLUS            reduce using rule 32 (factor -> LONG .)
    MINUS           reduce using rule 32 (factor -> LONG .)
    TIMES           reduce using rule 32 (factor -> LONG .)
    DIVIDE          reduce using rule 32 (factor -> LONG .)
    MOD             reduce using rule 32 (factor -> LONG .)
    $end            reduce using rule 32 (factor -> LONG .)
    RPAREN          reduce using rule 32 (factor -> LONG .)
    SEMICOLON       reduce using rule 32 (factor -> LONG .)
    RCURL           reduce using rule 32 (factor -> LONG .)
    CONJ            reduce using rule 32 (factor -> LONG .)
    DISJ            reduce using rule 32 (factor -> LONG .)
    LANGLE          reduce using rule 32 (factor -> LONG .)
    RANGLE          reduce using rule 32 (factor -> LONG .)
    LE              reduce using rule 32 (factor -> LONG .)
    GE              reduce using rule 32 (factor -> LONG .)
    EXCL_EQ         reduce using rule 32 (factor -> LONG .)
    EXCL_EQEQ       reduce using rule 32 (factor -> LONG .)
    AS_SAFE         reduce using rule 32 (factor -> LONG .)
    EQEQ            reduce using rule 32 (factor -> LONG .)
    EQEQEQ          reduce using rule 32 (factor -> LONG .)


state 22

    (33) factor -> CHAR .

    PLUS            reduce using rule 33 (factor -> CHAR .)
    MINUS           reduce using rule 33 (factor -> CHAR .)
    TIMES           reduce using rule 33 (factor -> CHAR .)
    DIVIDE          reduce using rule 33 (factor -> CHAR .)
    MOD             reduce using rule 33 (factor -> CHAR .)
    $end            reduce using rule 33 (factor -> CHAR .)
    RPAREN          reduce using rule 33 (factor -> CHAR .)
    SEMICOLON       reduce using rule 33 (factor -> CHAR .)
    RCURL           reduce using rule 33 (factor -> CHAR .)
    CONJ            reduce using rule 33 (factor -> CHAR .)
    DISJ            reduce using rule 33 (factor -> CHAR .)
    LANGLE          reduce using rule 33 (factor -> CHAR .)
    RANGLE          reduce using rule 33 (factor -> CHAR .)
    LE              reduce using rule 33 (factor -> CHAR .)
    GE              reduce using rule 33 (factor -> CHAR .)
    EXCL_EQ         reduce using rule 33 (factor -> CHAR .)
    EXCL_EQEQ       reduce using rule 33 (factor -> CHAR .)
    AS_SAFE         reduce using rule 33 (factor -> CHAR .)
    EQEQ            reduce using rule 33 (factor -> CHAR .)
    EQEQEQ          reduce using rule 33 (factor -> CHAR .)


state 23

    (34) factor -> BOOLEAN .

    PLUS            reduce using rule 34 (factor -> BOOLEAN .)
    MINUS           reduce using rule 34 (factor -> BOOLEAN .)
    TIMES           reduce using rule 34 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 34 (factor -> BOOLEAN .)
    MOD             reduce using rule 34 (factor -> BOOLEAN .)
    $end            reduce using rule 34 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 34 (factor -> BOOLEAN .)
    SEMICOLON       reduce using rule 34 (factor -> BOOLEAN .)
    RCURL           reduce using rule 34 (factor -> BOOLEAN .)
    CONJ            reduce using rule 34 (factor -> BOOLEAN .)
    DISJ            reduce using rule 34 (factor -> BOOLEAN .)
    LANGLE          reduce using rule 34 (factor -> BOOLEAN .)
    RANGLE          reduce using rule 34 (factor -> BOOLEAN .)
    LE              reduce using rule 34 (factor -> BOOLEAN .)
    GE              reduce using rule 34 (factor -> BOOLEAN .)
    EXCL_EQ         reduce using rule 34 (factor -> BOOLEAN .)
    EXCL_EQEQ       reduce using rule 34 (factor -> BOOLEAN .)
    AS_SAFE         reduce using rule 34 (factor -> BOOLEAN .)
    EQEQ            reduce using rule 34 (factor -> BOOLEAN .)
    EQEQEQ          reduce using rule 34 (factor -> BOOLEAN .)


state 24

    (1) line -> impresion SEMICOLON .

    $end            reduce using rule 1 (line -> impresion SEMICOLON .)
    RCURL           reduce using rule 1 (line -> impresion SEMICOLON .)


state 25

    (22) expression -> expression PLUS . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 40
    factor                         shift and go to state 16

state 26

    (23) expression -> expression MINUS . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 41
    factor                         shift and go to state 16

state 27

    (24) expression -> expression TIMES . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 42
    factor                         shift and go to state 16

state 28

    (25) expression -> expression DIVIDE . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 43
    factor                         shift and go to state 16

state 29

    (26) expression -> expression MOD . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 44
    factor                         shift and go to state 16

state 30

    (3) line -> asignacion SEMICOLON .

    $end            reduce using rule 3 (line -> asignacion SEMICOLON .)
    RCURL           reduce using rule 3 (line -> asignacion SEMICOLON .)


state 31

    (6) impresion -> PRINT LPAREN . STRING_1 RPAREN

    STRING_1        shift and go to state 45


state 32

    (29) term -> LPAREN expression . RPAREN
    (22) expression -> expression . PLUS term
    (23) expression -> expression . MINUS term
    (24) expression -> expression . TIMES term
    (25) expression -> expression . DIVIDE term
    (26) expression -> expression . MOD term

    RPAREN          shift and go to state 46
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    MOD             shift and go to state 29


state 33

    (35) factor -> ID .

    RPAREN          reduce using rule 35 (factor -> ID .)
    PLUS            reduce using rule 35 (factor -> ID .)
    MINUS           reduce using rule 35 (factor -> ID .)
    TIMES           reduce using rule 35 (factor -> ID .)
    DIVIDE          reduce using rule 35 (factor -> ID .)
    MOD             reduce using rule 35 (factor -> ID .)
    $end            reduce using rule 35 (factor -> ID .)
    SEMICOLON       reduce using rule 35 (factor -> ID .)
    RCURL           reduce using rule 35 (factor -> ID .)
    CONJ            reduce using rule 35 (factor -> ID .)
    DISJ            reduce using rule 35 (factor -> ID .)
    LANGLE          reduce using rule 35 (factor -> ID .)
    RANGLE          reduce using rule 35 (factor -> ID .)
    LE              reduce using rule 35 (factor -> ID .)
    GE              reduce using rule 35 (factor -> ID .)
    EXCL_EQ         reduce using rule 35 (factor -> ID .)
    EXCL_EQEQ       reduce using rule 35 (factor -> ID .)
    AS_SAFE         reduce using rule 35 (factor -> ID .)
    EQEQ            reduce using rule 35 (factor -> ID .)
    EQEQEQ          reduce using rule 35 (factor -> ID .)


state 34

    (10) asignacion -> keywordVariables asignacionSimple .

    SEMICOLON       reduce using rule 10 (asignacion -> keywordVariables asignacionSimple .)


state 35

    (12) asignacionSimple -> ID . DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> ID . EQUAL valor

    DOTS            shift and go to state 37
    EQUAL           shift and go to state 38


state 36

    (7) for -> FOR LPAREN . ID IN ID RPAREN LCURL line RCURL

    ID              shift and go to state 47


state 37

    (12) asignacionSimple -> ID DOTS . tipoDato EQUAL valor
    (14) tipoDato -> . TINT
    (15) tipoDato -> . TLONG
    (16) tipoDato -> . TFLOAT
    (17) tipoDato -> . TDOUBLE
    (18) tipoDato -> . TBOOLEAN
    (19) tipoDato -> . TCHAR
    (20) tipoDato -> . TSTRING

    TINT            shift and go to state 49
    TLONG           shift and go to state 50
    TFLOAT          shift and go to state 51
    TDOUBLE         shift and go to state 52
    TBOOLEAN        shift and go to state 53
    TCHAR           shift and go to state 54
    TSTRING         shift and go to state 55

    tipoDato                       shift and go to state 48

state 38

    (13) asignacionSimple -> ID EQUAL . valor
    (21) valor -> . expression
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    valor                          shift and go to state 56
    expression                     shift and go to state 57
    term                           shift and go to state 10
    factor                         shift and go to state 16

state 39

    (37) if -> IF LPAREN . condicion RPAREN LCURL line RCURL
    (38) if -> IF LPAREN . condicion RPAREN LCURL line RCURL else
    (40) condicion -> . condicionL
    (41) condicion -> . condicionR
    (42) condicion -> . condicionN
    (43) condicionL -> . term opL term
    (44) condicionR -> . term opR term
    (45) condicionN -> . EXCL_WS term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    EXCL_WS         shift and go to state 63
    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    condicion                      shift and go to state 58
    condicionL                     shift and go to state 59
    condicionR                     shift and go to state 60
    condicionN                     shift and go to state 61
    term                           shift and go to state 62
    factor                         shift and go to state 16

state 40

    (22) expression -> expression PLUS term .

    PLUS            reduce using rule 22 (expression -> expression PLUS term .)
    MINUS           reduce using rule 22 (expression -> expression PLUS term .)
    TIMES           reduce using rule 22 (expression -> expression PLUS term .)
    DIVIDE          reduce using rule 22 (expression -> expression PLUS term .)
    MOD             reduce using rule 22 (expression -> expression PLUS term .)
    $end            reduce using rule 22 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 22 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 22 (expression -> expression PLUS term .)
    RCURL           reduce using rule 22 (expression -> expression PLUS term .)


state 41

    (23) expression -> expression MINUS term .

    PLUS            reduce using rule 23 (expression -> expression MINUS term .)
    MINUS           reduce using rule 23 (expression -> expression MINUS term .)
    TIMES           reduce using rule 23 (expression -> expression MINUS term .)
    DIVIDE          reduce using rule 23 (expression -> expression MINUS term .)
    MOD             reduce using rule 23 (expression -> expression MINUS term .)
    $end            reduce using rule 23 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 23 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 23 (expression -> expression MINUS term .)
    RCURL           reduce using rule 23 (expression -> expression MINUS term .)


state 42

    (24) expression -> expression TIMES term .

    PLUS            reduce using rule 24 (expression -> expression TIMES term .)
    MINUS           reduce using rule 24 (expression -> expression TIMES term .)
    TIMES           reduce using rule 24 (expression -> expression TIMES term .)
    DIVIDE          reduce using rule 24 (expression -> expression TIMES term .)
    MOD             reduce using rule 24 (expression -> expression TIMES term .)
    $end            reduce using rule 24 (expression -> expression TIMES term .)
    RPAREN          reduce using rule 24 (expression -> expression TIMES term .)
    SEMICOLON       reduce using rule 24 (expression -> expression TIMES term .)
    RCURL           reduce using rule 24 (expression -> expression TIMES term .)


state 43

    (25) expression -> expression DIVIDE term .

    PLUS            reduce using rule 25 (expression -> expression DIVIDE term .)
    MINUS           reduce using rule 25 (expression -> expression DIVIDE term .)
    TIMES           reduce using rule 25 (expression -> expression DIVIDE term .)
    DIVIDE          reduce using rule 25 (expression -> expression DIVIDE term .)
    MOD             reduce using rule 25 (expression -> expression DIVIDE term .)
    $end            reduce using rule 25 (expression -> expression DIVIDE term .)
    RPAREN          reduce using rule 25 (expression -> expression DIVIDE term .)
    SEMICOLON       reduce using rule 25 (expression -> expression DIVIDE term .)
    RCURL           reduce using rule 25 (expression -> expression DIVIDE term .)


state 44

    (26) expression -> expression MOD term .

    PLUS            reduce using rule 26 (expression -> expression MOD term .)
    MINUS           reduce using rule 26 (expression -> expression MOD term .)
    TIMES           reduce using rule 26 (expression -> expression MOD term .)
    DIVIDE          reduce using rule 26 (expression -> expression MOD term .)
    MOD             reduce using rule 26 (expression -> expression MOD term .)
    $end            reduce using rule 26 (expression -> expression MOD term .)
    RPAREN          reduce using rule 26 (expression -> expression MOD term .)
    SEMICOLON       reduce using rule 26 (expression -> expression MOD term .)
    RCURL           reduce using rule 26 (expression -> expression MOD term .)


state 45

    (6) impresion -> PRINT LPAREN STRING_1 . RPAREN

    RPAREN          shift and go to state 64


state 46

    (29) term -> LPAREN expression RPAREN .

    PLUS            reduce using rule 29 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 29 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 29 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 29 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 29 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 29 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 29 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 29 (term -> LPAREN expression RPAREN .)
    RCURL           reduce using rule 29 (term -> LPAREN expression RPAREN .)
    CONJ            reduce using rule 29 (term -> LPAREN expression RPAREN .)
    DISJ            reduce using rule 29 (term -> LPAREN expression RPAREN .)
    LANGLE          reduce using rule 29 (term -> LPAREN expression RPAREN .)
    RANGLE          reduce using rule 29 (term -> LPAREN expression RPAREN .)
    LE              reduce using rule 29 (term -> LPAREN expression RPAREN .)
    GE              reduce using rule 29 (term -> LPAREN expression RPAREN .)
    EXCL_EQ         reduce using rule 29 (term -> LPAREN expression RPAREN .)
    EXCL_EQEQ       reduce using rule 29 (term -> LPAREN expression RPAREN .)
    AS_SAFE         reduce using rule 29 (term -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 29 (term -> LPAREN expression RPAREN .)
    EQEQEQ          reduce using rule 29 (term -> LPAREN expression RPAREN .)


state 47

    (7) for -> FOR LPAREN ID . IN ID RPAREN LCURL line RCURL

    IN              shift and go to state 65


state 48

    (12) asignacionSimple -> ID DOTS tipoDato . EQUAL valor

    EQUAL           shift and go to state 66


state 49

    (14) tipoDato -> TINT .

    EQUAL           reduce using rule 14 (tipoDato -> TINT .)


state 50

    (15) tipoDato -> TLONG .

    EQUAL           reduce using rule 15 (tipoDato -> TLONG .)


state 51

    (16) tipoDato -> TFLOAT .

    EQUAL           reduce using rule 16 (tipoDato -> TFLOAT .)


state 52

    (17) tipoDato -> TDOUBLE .

    EQUAL           reduce using rule 17 (tipoDato -> TDOUBLE .)


state 53

    (18) tipoDato -> TBOOLEAN .

    EQUAL           reduce using rule 18 (tipoDato -> TBOOLEAN .)


state 54

    (19) tipoDato -> TCHAR .

    EQUAL           reduce using rule 19 (tipoDato -> TCHAR .)


state 55

    (20) tipoDato -> TSTRING .

    EQUAL           reduce using rule 20 (tipoDato -> TSTRING .)


state 56

    (13) asignacionSimple -> ID EQUAL valor .

    SEMICOLON       reduce using rule 13 (asignacionSimple -> ID EQUAL valor .)


state 57

    (21) valor -> expression .
    (22) expression -> expression . PLUS term
    (23) expression -> expression . MINUS term
    (24) expression -> expression . TIMES term
    (25) expression -> expression . DIVIDE term
    (26) expression -> expression . MOD term

    SEMICOLON       reduce using rule 21 (valor -> expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28
    MOD             shift and go to state 29


state 58

    (37) if -> IF LPAREN condicion . RPAREN LCURL line RCURL
    (38) if -> IF LPAREN condicion . RPAREN LCURL line RCURL else

    RPAREN          shift and go to state 67


state 59

    (40) condicion -> condicionL .

    RPAREN          reduce using rule 40 (condicion -> condicionL .)


state 60

    (41) condicion -> condicionR .

    RPAREN          reduce using rule 41 (condicion -> condicionR .)


state 61

    (42) condicion -> condicionN .

    RPAREN          reduce using rule 42 (condicion -> condicionN .)


state 62

    (43) condicionL -> term . opL term
    (44) condicionR -> term . opR term
    (46) opL -> . CONJ
    (47) opL -> . DISJ
    (48) opR -> . LANGLE
    (49) opR -> . RANGLE
    (50) opR -> . LE
    (51) opR -> . GE
    (52) opR -> . EXCL_EQ
    (53) opR -> . EXCL_EQEQ
    (54) opR -> . AS_SAFE
    (55) opR -> . EQEQ
    (56) opR -> . EQEQEQ

    CONJ            shift and go to state 70
    DISJ            shift and go to state 71
    LANGLE          shift and go to state 72
    RANGLE          shift and go to state 73
    LE              shift and go to state 74
    GE              shift and go to state 75
    EXCL_EQ         shift and go to state 76
    EXCL_EQEQ       shift and go to state 77
    AS_SAFE         shift and go to state 78
    EQEQ            shift and go to state 79
    EQEQEQ          shift and go to state 80

    opL                            shift and go to state 68
    opR                            shift and go to state 69

state 63

    (45) condicionN -> EXCL_WS . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 81
    factor                         shift and go to state 16

state 64

    (6) impresion -> PRINT LPAREN STRING_1 RPAREN .

    SEMICOLON       reduce using rule 6 (impresion -> PRINT LPAREN STRING_1 RPAREN .)


state 65

    (7) for -> FOR LPAREN ID IN . ID RPAREN LCURL line RCURL

    ID              shift and go to state 82


state 66

    (12) asignacionSimple -> ID DOTS tipoDato EQUAL . valor
    (21) valor -> . expression
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    valor                          shift and go to state 83
    expression                     shift and go to state 57
    term                           shift and go to state 10
    factor                         shift and go to state 16

state 67

    (37) if -> IF LPAREN condicion RPAREN . LCURL line RCURL
    (38) if -> IF LPAREN condicion RPAREN . LCURL line RCURL else

    LCURL           shift and go to state 84


state 68

    (43) condicionL -> term opL . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 85
    factor                         shift and go to state 16

state 69

    (44) condicionR -> term opR . term
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    LPAREN          shift and go to state 8
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    ID              shift and go to state 33
    STRING_1        shift and go to state 9

    term                           shift and go to state 86
    factor                         shift and go to state 16

state 70

    (46) opL -> CONJ .

    LPAREN          reduce using rule 46 (opL -> CONJ .)
    INT             reduce using rule 46 (opL -> CONJ .)
    FLOAT           reduce using rule 46 (opL -> CONJ .)
    LONG            reduce using rule 46 (opL -> CONJ .)
    CHAR            reduce using rule 46 (opL -> CONJ .)
    BOOLEAN         reduce using rule 46 (opL -> CONJ .)
    ID              reduce using rule 46 (opL -> CONJ .)
    STRING_1        reduce using rule 46 (opL -> CONJ .)


state 71

    (47) opL -> DISJ .

    LPAREN          reduce using rule 47 (opL -> DISJ .)
    INT             reduce using rule 47 (opL -> DISJ .)
    FLOAT           reduce using rule 47 (opL -> DISJ .)
    LONG            reduce using rule 47 (opL -> DISJ .)
    CHAR            reduce using rule 47 (opL -> DISJ .)
    BOOLEAN         reduce using rule 47 (opL -> DISJ .)
    ID              reduce using rule 47 (opL -> DISJ .)
    STRING_1        reduce using rule 47 (opL -> DISJ .)


state 72

    (48) opR -> LANGLE .

    LPAREN          reduce using rule 48 (opR -> LANGLE .)
    INT             reduce using rule 48 (opR -> LANGLE .)
    FLOAT           reduce using rule 48 (opR -> LANGLE .)
    LONG            reduce using rule 48 (opR -> LANGLE .)
    CHAR            reduce using rule 48 (opR -> LANGLE .)
    BOOLEAN         reduce using rule 48 (opR -> LANGLE .)
    ID              reduce using rule 48 (opR -> LANGLE .)
    STRING_1        reduce using rule 48 (opR -> LANGLE .)


state 73

    (49) opR -> RANGLE .

    LPAREN          reduce using rule 49 (opR -> RANGLE .)
    INT             reduce using rule 49 (opR -> RANGLE .)
    FLOAT           reduce using rule 49 (opR -> RANGLE .)
    LONG            reduce using rule 49 (opR -> RANGLE .)
    CHAR            reduce using rule 49 (opR -> RANGLE .)
    BOOLEAN         reduce using rule 49 (opR -> RANGLE .)
    ID              reduce using rule 49 (opR -> RANGLE .)
    STRING_1        reduce using rule 49 (opR -> RANGLE .)


state 74

    (50) opR -> LE .

    LPAREN          reduce using rule 50 (opR -> LE .)
    INT             reduce using rule 50 (opR -> LE .)
    FLOAT           reduce using rule 50 (opR -> LE .)
    LONG            reduce using rule 50 (opR -> LE .)
    CHAR            reduce using rule 50 (opR -> LE .)
    BOOLEAN         reduce using rule 50 (opR -> LE .)
    ID              reduce using rule 50 (opR -> LE .)
    STRING_1        reduce using rule 50 (opR -> LE .)


state 75

    (51) opR -> GE .

    LPAREN          reduce using rule 51 (opR -> GE .)
    INT             reduce using rule 51 (opR -> GE .)
    FLOAT           reduce using rule 51 (opR -> GE .)
    LONG            reduce using rule 51 (opR -> GE .)
    CHAR            reduce using rule 51 (opR -> GE .)
    BOOLEAN         reduce using rule 51 (opR -> GE .)
    ID              reduce using rule 51 (opR -> GE .)
    STRING_1        reduce using rule 51 (opR -> GE .)


state 76

    (52) opR -> EXCL_EQ .

    LPAREN          reduce using rule 52 (opR -> EXCL_EQ .)
    INT             reduce using rule 52 (opR -> EXCL_EQ .)
    FLOAT           reduce using rule 52 (opR -> EXCL_EQ .)
    LONG            reduce using rule 52 (opR -> EXCL_EQ .)
    CHAR            reduce using rule 52 (opR -> EXCL_EQ .)
    BOOLEAN         reduce using rule 52 (opR -> EXCL_EQ .)
    ID              reduce using rule 52 (opR -> EXCL_EQ .)
    STRING_1        reduce using rule 52 (opR -> EXCL_EQ .)


state 77

    (53) opR -> EXCL_EQEQ .

    LPAREN          reduce using rule 53 (opR -> EXCL_EQEQ .)
    INT             reduce using rule 53 (opR -> EXCL_EQEQ .)
    FLOAT           reduce using rule 53 (opR -> EXCL_EQEQ .)
    LONG            reduce using rule 53 (opR -> EXCL_EQEQ .)
    CHAR            reduce using rule 53 (opR -> EXCL_EQEQ .)
    BOOLEAN         reduce using rule 53 (opR -> EXCL_EQEQ .)
    ID              reduce using rule 53 (opR -> EXCL_EQEQ .)
    STRING_1        reduce using rule 53 (opR -> EXCL_EQEQ .)


state 78

    (54) opR -> AS_SAFE .

    LPAREN          reduce using rule 54 (opR -> AS_SAFE .)
    INT             reduce using rule 54 (opR -> AS_SAFE .)
    FLOAT           reduce using rule 54 (opR -> AS_SAFE .)
    LONG            reduce using rule 54 (opR -> AS_SAFE .)
    CHAR            reduce using rule 54 (opR -> AS_SAFE .)
    BOOLEAN         reduce using rule 54 (opR -> AS_SAFE .)
    ID              reduce using rule 54 (opR -> AS_SAFE .)
    STRING_1        reduce using rule 54 (opR -> AS_SAFE .)


state 79

    (55) opR -> EQEQ .

    LPAREN          reduce using rule 55 (opR -> EQEQ .)
    INT             reduce using rule 55 (opR -> EQEQ .)
    FLOAT           reduce using rule 55 (opR -> EQEQ .)
    LONG            reduce using rule 55 (opR -> EQEQ .)
    CHAR            reduce using rule 55 (opR -> EQEQ .)
    BOOLEAN         reduce using rule 55 (opR -> EQEQ .)
    ID              reduce using rule 55 (opR -> EQEQ .)
    STRING_1        reduce using rule 55 (opR -> EQEQ .)


state 80

    (56) opR -> EQEQEQ .

    LPAREN          reduce using rule 56 (opR -> EQEQEQ .)
    INT             reduce using rule 56 (opR -> EQEQEQ .)
    FLOAT           reduce using rule 56 (opR -> EQEQEQ .)
    LONG            reduce using rule 56 (opR -> EQEQEQ .)
    CHAR            reduce using rule 56 (opR -> EQEQEQ .)
    BOOLEAN         reduce using rule 56 (opR -> EQEQEQ .)
    ID              reduce using rule 56 (opR -> EQEQEQ .)
    STRING_1        reduce using rule 56 (opR -> EQEQEQ .)


state 81

    (45) condicionN -> EXCL_WS term .

    RPAREN          reduce using rule 45 (condicionN -> EXCL_WS term .)


state 82

    (7) for -> FOR LPAREN ID IN ID . RPAREN LCURL line RCURL

    RPAREN          shift and go to state 87


state 83

    (12) asignacionSimple -> ID DOTS tipoDato EQUAL valor .

    SEMICOLON       reduce using rule 12 (asignacionSimple -> ID DOTS tipoDato EQUAL valor .)


state 84

    (37) if -> IF LPAREN condicion RPAREN LCURL . line RCURL
    (38) if -> IF LPAREN condicion RPAREN LCURL . line RCURL else
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion SEMICOLON
    (4) line -> . for
    (5) line -> . if
    (6) impresion -> . PRINT LPAREN STRING_1 RPAREN
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (10) asignacion -> . keywordVariables asignacionSimple
    (11) asignacion -> . asignacionSimple
    (7) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (37) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (38) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (8) keywordVariables -> . VAR
    (9) keywordVariables -> . VAL
    (12) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> . ID EQUAL valor
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    PRINT           shift and go to state 7
    FOR             shift and go to state 13
    IF              shift and go to state 15
    LPAREN          shift and go to state 8
    VAR             shift and go to state 17
    VAL             shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    STRING_1        shift and go to state 9

    line                           shift and go to state 88
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    term                           shift and go to state 10
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    factor                         shift and go to state 16

state 85

    (43) condicionL -> term opL term .

    RPAREN          reduce using rule 43 (condicionL -> term opL term .)


state 86

    (44) condicionR -> term opR term .

    RPAREN          reduce using rule 44 (condicionR -> term opR term .)


state 87

    (7) for -> FOR LPAREN ID IN ID RPAREN . LCURL line RCURL

    LCURL           shift and go to state 89


state 88

    (37) if -> IF LPAREN condicion RPAREN LCURL line . RCURL
    (38) if -> IF LPAREN condicion RPAREN LCURL line . RCURL else

    RCURL           shift and go to state 90


state 89

    (7) for -> FOR LPAREN ID IN ID RPAREN LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion SEMICOLON
    (4) line -> . for
    (5) line -> . if
    (6) impresion -> . PRINT LPAREN STRING_1 RPAREN
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (10) asignacion -> . keywordVariables asignacionSimple
    (11) asignacion -> . asignacionSimple
    (7) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (37) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (38) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (8) keywordVariables -> . VAR
    (9) keywordVariables -> . VAL
    (12) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> . ID EQUAL valor
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    PRINT           shift and go to state 7
    FOR             shift and go to state 13
    IF              shift and go to state 15
    LPAREN          shift and go to state 8
    VAR             shift and go to state 17
    VAL             shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    STRING_1        shift and go to state 9

    line                           shift and go to state 91
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    term                           shift and go to state 10
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    factor                         shift and go to state 16

state 90

    (37) if -> IF LPAREN condicion RPAREN LCURL line RCURL .
    (38) if -> IF LPAREN condicion RPAREN LCURL line RCURL . else
    (39) else -> . ELSE LCURL line RCURL

    $end            reduce using rule 37 (if -> IF LPAREN condicion RPAREN LCURL line RCURL .)
    RCURL           reduce using rule 37 (if -> IF LPAREN condicion RPAREN LCURL line RCURL .)
    ELSE            shift and go to state 93

    else                           shift and go to state 92

state 91

    (7) for -> FOR LPAREN ID IN ID RPAREN LCURL line . RCURL

    RCURL           shift and go to state 94


state 92

    (38) if -> IF LPAREN condicion RPAREN LCURL line RCURL else .

    $end            reduce using rule 38 (if -> IF LPAREN condicion RPAREN LCURL line RCURL else .)
    RCURL           reduce using rule 38 (if -> IF LPAREN condicion RPAREN LCURL line RCURL else .)


state 93

    (39) else -> ELSE . LCURL line RCURL

    LCURL           shift and go to state 95


state 94

    (7) for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .

    $end            reduce using rule 7 (for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .)
    RCURL           reduce using rule 7 (for -> FOR LPAREN ID IN ID RPAREN LCURL line RCURL .)


state 95

    (39) else -> ELSE LCURL . line RCURL
    (1) line -> . impresion SEMICOLON
    (2) line -> . expression
    (3) line -> . asignacion SEMICOLON
    (4) line -> . for
    (5) line -> . if
    (6) impresion -> . PRINT LPAREN STRING_1 RPAREN
    (22) expression -> . expression PLUS term
    (23) expression -> . expression MINUS term
    (24) expression -> . expression TIMES term
    (25) expression -> . expression DIVIDE term
    (26) expression -> . expression MOD term
    (27) expression -> . term
    (10) asignacion -> . keywordVariables asignacionSimple
    (11) asignacion -> . asignacionSimple
    (7) for -> . FOR LPAREN ID IN ID RPAREN LCURL line RCURL
    (37) if -> . IF LPAREN condicion RPAREN LCURL line RCURL
    (38) if -> . IF LPAREN condicion RPAREN LCURL line RCURL else
    (28) term -> . factor
    (29) term -> . LPAREN expression RPAREN
    (8) keywordVariables -> . VAR
    (9) keywordVariables -> . VAL
    (12) asignacionSimple -> . ID DOTS tipoDato EQUAL valor
    (13) asignacionSimple -> . ID EQUAL valor
    (30) factor -> . INT
    (31) factor -> . FLOAT
    (32) factor -> . LONG
    (33) factor -> . CHAR
    (34) factor -> . BOOLEAN
    (35) factor -> . ID
    (36) factor -> . STRING_1

    PRINT           shift and go to state 7
    FOR             shift and go to state 13
    IF              shift and go to state 15
    LPAREN          shift and go to state 8
    VAR             shift and go to state 17
    VAL             shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    LONG            shift and go to state 21
    CHAR            shift and go to state 22
    BOOLEAN         shift and go to state 23
    STRING_1        shift and go to state 9

    line                           shift and go to state 96
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    asignacion                     shift and go to state 4
    for                            shift and go to state 5
    if                             shift and go to state 6
    term                           shift and go to state 10
    keywordVariables               shift and go to state 11
    asignacionSimple               shift and go to state 12
    factor                         shift and go to state 16

state 96

    (39) else -> ELSE LCURL line . RCURL

    RCURL           shift and go to state 97


state 97

    (39) else -> ELSE LCURL line RCURL .

    $end            reduce using rule 39 (else -> ELSE LCURL line RCURL .)
    RCURL           reduce using rule 39 (else -> ELSE LCURL line RCURL .)

